// Generated by Futhark 0.20.4

// We need to define _GNU_SOURCE before
// _any_ headers files are imported to get
// the usage statistics of a thread (i.e. have RUSAGE_THREAD) on GNU/Linux
// https://manpages.courier-mta.org/htmlman2/getrusage.2.html
#ifndef _GNU_SOURCE // Avoid possible double-definition warning.
#define _GNU_SOURCE
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wparentheses"
#pragma clang diagnostic ignored "-Wunused-label"
#elif __GNUC__
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

// Headers\n")
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <float.h>

#define CL_TARGET_OPENCL_VERSION 120
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#ifdef __APPLE__
#define CL_SILENCE_DEPRECATION
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Initialisation
struct futhark_context_config;
struct futhark_context_config *futhark_context_config_new(void);
void futhark_context_config_free(struct futhark_context_config *cfg);
void futhark_context_config_add_build_option(struct futhark_context_config *cfg,
                                             const char *opt);
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag);
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int flag);
void futhark_context_config_set_device(struct futhark_context_config *cfg, const
                                       char *s);
void futhark_context_config_set_platform(struct futhark_context_config *cfg,
                                         const char *s);
void
futhark_context_config_select_device_interactively(struct futhark_context_config *cfg);
void futhark_context_config_list_devices(struct futhark_context_config *cfg);
void futhark_context_config_dump_program_to(struct futhark_context_config *cfg,
                                            const char *path);
void
futhark_context_config_load_program_from(struct futhark_context_config *cfg,
                                         const char *path);
void futhark_context_config_dump_binary_to(struct futhark_context_config *cfg,
                                           const char *path);
void futhark_context_config_load_binary_from(struct futhark_context_config *cfg,
                                             const char *path);
void
futhark_context_config_set_default_group_size(struct futhark_context_config *cfg,
                                              int size);
void
futhark_context_config_set_default_num_groups(struct futhark_context_config *cfg,
                                              int num);
void
futhark_context_config_set_default_tile_size(struct futhark_context_config *cfg,
                                             int num);
void
futhark_context_config_set_default_reg_tile_size(struct futhark_context_config *cfg,
                                                 int num);
void
futhark_context_config_set_default_threshold(struct futhark_context_config *cfg,
                                             int num);
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t new_value);
struct futhark_context;
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg);
struct futhark_context
*futhark_context_new_with_command_queue(struct futhark_context_config *cfg,
                                        cl_command_queue queue);
void futhark_context_free(struct futhark_context *ctx);
cl_command_queue futhark_context_get_command_queue(struct futhark_context *ctx);
int futhark_get_tuning_param_count(void);
const char *futhark_get_tuning_param_name(int);
const char *futhark_get_tuning_param_class(int);

// Arrays
struct futhark_f32_1d;
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0);
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              cl_mem data, int64_t offset,
                                              int64_t dim0);
int futhark_free_f32_1d(struct futhark_context *ctx,
                        struct futhark_f32_1d *arr);
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data);
cl_mem futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                 struct futhark_f32_1d *arr);
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr);
struct futhark_f32_2d;
struct futhark_f32_2d *futhark_new_f32_2d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0,
                                          int64_t dim1);
struct futhark_f32_2d *futhark_new_raw_f32_2d(struct futhark_context *ctx, const
                                              cl_mem data, int64_t offset,
                                              int64_t dim0, int64_t dim1);
int futhark_free_f32_2d(struct futhark_context *ctx,
                        struct futhark_f32_2d *arr);
int futhark_values_f32_2d(struct futhark_context *ctx,
                          struct futhark_f32_2d *arr, float *data);
cl_mem futhark_values_raw_f32_2d(struct futhark_context *ctx,
                                 struct futhark_f32_2d *arr);
const int64_t *futhark_shape_f32_2d(struct futhark_context *ctx,
                                    struct futhark_f32_2d *arr);
struct futhark_u8_3d;
struct futhark_u8_3d *futhark_new_u8_3d(struct futhark_context *ctx, const
                                        uint8_t *data, int64_t dim0,
                                        int64_t dim1, int64_t dim2);
struct futhark_u8_3d *futhark_new_raw_u8_3d(struct futhark_context *ctx, const
                                            cl_mem data, int64_t offset,
                                            int64_t dim0, int64_t dim1,
                                            int64_t dim2);
int futhark_free_u8_3d(struct futhark_context *ctx, struct futhark_u8_3d *arr);
int futhark_values_u8_3d(struct futhark_context *ctx, struct futhark_u8_3d *arr,
                         uint8_t *data);
cl_mem futhark_values_raw_u8_3d(struct futhark_context *ctx,
                                struct futhark_u8_3d *arr);
const int64_t *futhark_shape_u8_3d(struct futhark_context *ctx,
                                   struct futhark_u8_3d *arr);

// Opaque values


// Entry points
int futhark_entry_dot(struct futhark_context *ctx, float *out0, const
                      struct futhark_f32_1d *in0, const
                      struct futhark_f32_1d *in1);
int futhark_entry_main(struct futhark_context *ctx, struct futhark_u8_3d **out0,
                       const int64_t in0);
int futhark_entry_matrixAbs(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0);
int futhark_entry_matrixAdd(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0, const
                            struct futhark_f32_2d *in1);
int futhark_entry_matrixMatrixMul(struct futhark_context *ctx,
                                  struct futhark_f32_2d **out0, const
                                  struct futhark_f32_2d *in0, const
                                  struct futhark_f32_2d *in1);
int futhark_entry_matrixMul(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0, const
                            struct futhark_f32_2d *in1);
int futhark_entry_matrixSgn(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0);
int futhark_entry_matrixSub(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0, const
                            struct futhark_f32_2d *in1);
int futhark_entry_matrixVectorMul(struct futhark_context *ctx,
                                  struct futhark_f32_1d **out0, const
                                  struct futhark_f32_2d *in0, const
                                  struct futhark_f32_1d *in1);
int futhark_entry_normalizeV(struct futhark_context *ctx,
                             struct futhark_f32_1d **out0, const
                             struct futhark_f32_1d *in0);
int futhark_entry_scaleM(struct futhark_context *ctx,
                         struct futhark_f32_2d **out0, const float in0, const
                         struct futhark_f32_2d *in1);
int futhark_entry_scaleV(struct futhark_context *ctx,
                         struct futhark_f32_1d **out0, const float in0, const
                         struct futhark_f32_1d *in1);
int futhark_entry_vectorAbs(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0);
int futhark_entry_vectorAdd(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0, const
                            struct futhark_f32_1d *in1);
int futhark_entry_vectorMatrixMul(struct futhark_context *ctx,
                                  struct futhark_f32_1d **out0, const
                                  struct futhark_f32_1d *in0, const
                                  struct futhark_f32_2d *in1);
int futhark_entry_vectorMul(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0, const
                            struct futhark_f32_1d *in1);
int futhark_entry_vectorNorm(struct futhark_context *ctx, float *out0, const
                             struct futhark_f32_1d *in0);
int futhark_entry_vectorSgn(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0);
int futhark_entry_vectorSub(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0, const
                            struct futhark_f32_1d *in1);

// Miscellaneous
int futhark_context_sync(struct futhark_context *ctx);
char *futhark_context_report(struct futhark_context *ctx);
char *futhark_context_get_error(struct futhark_context *ctx);
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f);
void futhark_context_pause_profiling(struct futhark_context *ctx);
void futhark_context_unpause_profiling(struct futhark_context *ctx);
int futhark_context_clear_caches(struct futhark_context *ctx);
#define FUTHARK_BACKEND_opencl

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <stdint.h>
// If NDEBUG is set, the assert() macro will do nothing. Since Futhark
// (unfortunately) makes use of assert() for error detection (and even some
// side effects), we want to avoid that.
#undef NDEBUG
#include <assert.h>
#include <stdarg.h>
// Start of util.h.
//
// Various helper functions that are useful in all generated C code.

#include <errno.h>
#include <string.h>

static const char *fut_progname = "(embedded Futhark)";

static void futhark_panic(int eval, const char *fmt, ...) __attribute__((noreturn));
static char* msgprintf(const char *s, ...);
static void* slurp_file(const char *filename, size_t *size);
static int dump_file(const char *file, const void *buf, size_t n);
struct str_builder;
static void str_builder_init(struct str_builder *b);
static void str_builder(struct str_builder *b, const char *s, ...);

static void futhark_panic(int eval, const char *fmt, ...) {
  va_list ap;
  va_start(ap, fmt);
  fprintf(stderr, "%s: ", fut_progname);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  exit(eval);
}

// For generating arbitrary-sized error messages.  It is the callers
// responsibility to free the buffer at some point.
static char* msgprintf(const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = 1 + (size_t)vsnprintf(NULL, 0, s, vl);
  char *buffer = (char*) malloc(needed);
  va_start(vl, s); // Must re-init.
  vsnprintf(buffer, needed, s, vl);
  return buffer;
}

static inline void check_err(int errval, int sets_errno, const char *fun, int line,
                            const char *msg, ...) {
  if (errval) {
    char errnum[10];

    va_list vl;
    va_start(vl, msg);

    fprintf(stderr, "ERROR: ");
    vfprintf(stderr, msg, vl);
    fprintf(stderr, " in %s() at line %d with error code %s\n",
            fun, line,
            sets_errno ? strerror(errno) : errnum);
    exit(errval);
  }
}

#define CHECK_ERR(err, ...) check_err(err, 0, __func__, __LINE__, __VA_ARGS__)
#define CHECK_ERRNO(err, ...) check_err(err, 1, __func__, __LINE__, __VA_ARGS__)

// Read the rest of an open file into a NUL-terminated string; returns
// NULL on error.
static void* fslurp_file(FILE *f, size_t *size) {
  long start = ftell(f);
  fseek(f, 0, SEEK_END);
  long src_size = ftell(f)-start;
  fseek(f, start, SEEK_SET);
  unsigned char *s = (unsigned char*) malloc((size_t)src_size + 1);
  if (fread(s, 1, (size_t)src_size, f) != (size_t)src_size) {
    free(s);
    s = NULL;
  } else {
    s[src_size] = '\0';
  }

  if (size) {
    *size = (size_t)src_size;
  }

  return s;
}

// Read a file into a NUL-terminated string; returns NULL on error.
static void* slurp_file(const char *filename, size_t *size) {
  FILE *f = fopen(filename, "rb"); // To avoid Windows messing with linebreaks.
  if (f == NULL) return NULL;
  unsigned char *s = fslurp_file(f, size);
  fclose(f);
  return s;
}

// Dump 'n' bytes from 'buf' into the file at the designated location.
// Returns 0 on success.
static int dump_file(const char *file, const void *buf, size_t n) {
  FILE *f = fopen(file, "w");

  if (f == NULL) {
    return 1;
  }

  if (fwrite(buf, sizeof(char), n, f) != n) {
    return 1;
  }

  if (fclose(f) != 0) {
    return 1;
  }

  return 0;
}

struct str_builder {
  char *str;
  size_t capacity; // Size of buffer.
  size_t used; // Bytes used, *not* including final zero.
};

static void str_builder_init(struct str_builder *b) {
  b->capacity = 10;
  b->used = 0;
  b->str = malloc(b->capacity);
  b->str[0] = 0;
}

static void str_builder(struct str_builder *b, const char *s, ...) {
  va_list vl;
  va_start(vl, s);
  size_t needed = (size_t)vsnprintf(NULL, 0, s, vl);

  while (b->capacity < b->used + needed + 1) {
    b->capacity *= 2;
    b->str = realloc(b->str, b->capacity);
  }

  va_start(vl, s); // Must re-init.
  vsnprintf(b->str+b->used, b->capacity-b->used, s, vl);
  b->used += needed;
}

// End of util.h.
// Start of half.h.

// Conversion functions are from http://half.sourceforge.net/, but
// translated to C.
//
// Copyright (c) 2012-2021 Christian Rau
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef __OPENCL_VERSION__
#define __constant
#endif

__constant static const uint16_t base_table[512] = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };

__constant static const unsigned char shift_table[512] = {
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };

__constant static const uint32_t mantissa_table[2048] = {
  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
  0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
  0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
  0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
__constant static const uint32_t exponent_table[64] = {
  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
__constant static const unsigned short offset_table[64] = {
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };

static uint16_t float2halfbits(float value) {
  union { float x; uint32_t y; } u;
  u.x = value;
  uint32_t bits = u.y;

  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;

  return hbits;
}

static float halfbits2float(uint16_t value) {
  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];

  union { uint32_t x; float y; } u;
  u.x = bits;
  return u.y;
}

// End of half.h.
// Start of timing.h.

// The function get_wall_time() returns the wall time in microseconds
// (with an unspecified offset).

#ifdef _WIN32

#include <windows.h>

static int64_t get_wall_time(void) {
  LARGE_INTEGER time,freq;
  assert(QueryPerformanceFrequency(&freq));
  assert(QueryPerformanceCounter(&time));
  return ((double)time.QuadPart / freq.QuadPart) * 1000000;
}

#else
// Assuming POSIX

#include <time.h>
#include <sys/time.h>

static int64_t get_wall_time(void) {
  struct timeval time;
  assert(gettimeofday(&time,NULL) == 0);
  return time.tv_sec * 1000000 + time.tv_usec;
}

static int64_t get_wall_time_ns(void) {
  struct timespec time;
  assert(clock_gettime(CLOCK_REALTIME, &time) == 0);
  return time.tv_sec * 1000000000 + time.tv_nsec;
}

#endif

// End of timing.h.

#ifdef _MSC_VER
#define inline __inline
#endif
#include <string.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include <ctype.h>


#define CL_TARGET_OPENCL_VERSION 120
#define CL_USE_DEPRECATED_OPENCL_1_2_APIS
#ifdef __APPLE__
#define CL_SILENCE_DEPRECATION
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif


// Start of lock.h.

// A very simple cross-platform implementation of locks.  Uses
// pthreads on Unix and some Windows thing there.  Futhark's
// host-level code is not multithreaded, but user code may be, so we
// need some mechanism for ensuring atomic access to API functions.
// This is that mechanism.  It is not exposed to user code at all, so
// we do not have to worry about name collisions.

#ifdef _WIN32

typedef HANDLE lock_t;

static void create_lock(lock_t *lock) {
  *lock = CreateMutex(NULL,  // Default security attributes.
                      FALSE, // Initially unlocked.
                      NULL); // Unnamed.
}

static void lock_lock(lock_t *lock) {
  assert(WaitForSingleObject(*lock, INFINITE) == WAIT_OBJECT_0);
}

static void lock_unlock(lock_t *lock) {
  assert(ReleaseMutex(*lock));
}

static void free_lock(lock_t *lock) {
  CloseHandle(*lock);
}

#else
// Assuming POSIX

#include <pthread.h>

typedef pthread_mutex_t lock_t;

static void create_lock(lock_t *lock) {
  int r = pthread_mutex_init(lock, NULL);
  assert(r == 0);
}

static void lock_lock(lock_t *lock) {
  int r = pthread_mutex_lock(lock);
  assert(r == 0);
}

static void lock_unlock(lock_t *lock) {
  int r = pthread_mutex_unlock(lock);
  assert(r == 0);
}

static void free_lock(lock_t *lock) {
  // Nothing to do for pthreads.
  (void)lock;
}

#endif

// End of lock.h.

#define FUTHARK_F64_ENABLED

// Start of scalar.h.

// Implementation of the primitive scalar operations.  Very
// repetitive.  This code is inserted directly into both CUDA and
// OpenCL programs, as well as the CPU code, so it has some #ifdefs to
// work everywhere.  Some operations are defined as macros because
// this allows us to use them as constant expressions in things like
// array sizes and static initialisers.

// Some of the #ifdefs are because OpenCL uses type-generic functions
// for some operations (e.g. sqrt), while C and CUDA sensibly use
// distinct functions for different precisions (e.g. sqrtf() and
// sqrt()).  This is quite annoying.  Due to C's unfortunate casting
// rules, it is also really easy to accidentally implement
// floating-point functions in the wrong precision, so be careful.

// Double-precision definitions are only included if the preprocessor
// macro FUTHARK_F64_ENABLED is set.

static inline uint8_t add8(uint8_t x, uint8_t y) {
  return x + y;
}

static inline uint16_t add16(uint16_t x, uint16_t y) {
  return x + y;
}

static inline uint32_t add32(uint32_t x, uint32_t y) {
  return x + y;
}

static inline uint64_t add64(uint64_t x, uint64_t y) {
  return x + y;
}

static inline uint8_t sub8(uint8_t x, uint8_t y) {
  return x - y;
}

static inline uint16_t sub16(uint16_t x, uint16_t y) {
  return x - y;
}

static inline uint32_t sub32(uint32_t x, uint32_t y) {
  return x - y;
}

static inline uint64_t sub64(uint64_t x, uint64_t y) {
  return x - y;
}

static inline uint8_t mul8(uint8_t x, uint8_t y) {
  return x * y;
}

static inline uint16_t mul16(uint16_t x, uint16_t y) {
  return x * y;
}

static inline uint32_t mul32(uint32_t x, uint32_t y) {
  return x * y;
}

static inline uint64_t mul64(uint64_t x, uint64_t y) {
  return x * y;
}

static inline uint8_t udiv8(uint8_t x, uint8_t y) {
  return x / y;
}

static inline uint16_t udiv16(uint16_t x, uint16_t y) {
  return x / y;
}

static inline uint32_t udiv32(uint32_t x, uint32_t y) {
  return x / y;
}

static inline uint64_t udiv64(uint64_t x, uint64_t y) {
  return x / y;
}

static inline uint8_t udiv_up8(uint8_t x, uint8_t y) {
  return (x + y - 1) / y;
}

static inline uint16_t udiv_up16(uint16_t x, uint16_t y) {
  return (x + y - 1) / y;
}

static inline uint32_t udiv_up32(uint32_t x, uint32_t y) {
  return (x + y - 1) / y;
}

static inline uint64_t udiv_up64(uint64_t x, uint64_t y) {
  return (x + y - 1) / y;
}

static inline uint8_t umod8(uint8_t x, uint8_t y) {
  return x % y;
}

static inline uint16_t umod16(uint16_t x, uint16_t y) {
  return x % y;
}

static inline uint32_t umod32(uint32_t x, uint32_t y) {
  return x % y;
}

static inline uint64_t umod64(uint64_t x, uint64_t y) {
  return x % y;
}

static inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : (x + y - 1) / y;
}

static inline uint8_t umod_safe8(uint8_t x, uint8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint16_t umod_safe16(uint16_t x, uint16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint32_t umod_safe32(uint32_t x, uint32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline uint64_t umod_safe64(uint64_t x, uint64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t sdiv8(int8_t x, int8_t y) {
  int8_t q = x / y;
  int8_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int16_t sdiv16(int16_t x, int16_t y) {
  int16_t q = x / y;
  int16_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int32_t sdiv32(int32_t x, int32_t y) {
  int32_t q = x / y;
  int32_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int64_t sdiv64(int64_t x, int64_t y) {
  int64_t q = x / y;
  int64_t r = x % y;

  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);
}

static inline int8_t sdiv_up8(int8_t x, int8_t y) {
  return sdiv8(x + y - 1, y);
}

static inline int16_t sdiv_up16(int16_t x, int16_t y) {
  return sdiv16(x + y - 1, y);
}

static inline int32_t sdiv_up32(int32_t x, int32_t y) {
  return sdiv32(x + y - 1, y);
}

static inline int64_t sdiv_up64(int64_t x, int64_t y) {
  return sdiv64(x + y - 1, y);
}

static inline int8_t smod8(int8_t x, int8_t y) {
  int8_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int16_t smod16(int16_t x, int16_t y) {
  int16_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int32_t smod32(int32_t x, int32_t y) {
  int32_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int64_t smod64(int64_t x, int64_t y) {
  int64_t r = x % y;

  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);
}

static inline int8_t sdiv_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : sdiv8(x, y);
}

static inline int16_t sdiv_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : sdiv16(x, y);
}

static inline int32_t sdiv_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : sdiv32(x, y);
}

static inline int64_t sdiv_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : sdiv64(x, y);
}

static inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {
  return sdiv_safe8(x + y - 1, y);
}

static inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {
  return sdiv_safe16(x + y - 1, y);
}

static inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {
  return sdiv_safe32(x + y - 1, y);
}

static inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {
  return sdiv_safe64(x + y - 1, y);
}

static inline int8_t smod_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : smod8(x, y);
}

static inline int16_t smod_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : smod16(x, y);
}

static inline int32_t smod_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : smod32(x, y);
}

static inline int64_t smod_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : smod64(x, y);
}

static inline int8_t squot8(int8_t x, int8_t y) {
  return x / y;
}

static inline int16_t squot16(int16_t x, int16_t y) {
  return x / y;
}

static inline int32_t squot32(int32_t x, int32_t y) {
  return x / y;
}

static inline int64_t squot64(int64_t x, int64_t y) {
  return x / y;
}

static inline int8_t srem8(int8_t x, int8_t y) {
  return x % y;
}

static inline int16_t srem16(int16_t x, int16_t y) {
  return x % y;
}

static inline int32_t srem32(int32_t x, int32_t y) {
  return x % y;
}

static inline int64_t srem64(int64_t x, int64_t y) {
  return x % y;
}

static inline int8_t squot_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int16_t squot_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int32_t squot_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int64_t squot_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x / y;
}

static inline int8_t srem_safe8(int8_t x, int8_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int16_t srem_safe16(int16_t x, int16_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int32_t srem_safe32(int32_t x, int32_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int64_t srem_safe64(int64_t x, int64_t y) {
  return y == 0 ? 0 : x % y;
}

static inline int8_t smin8(int8_t x, int8_t y) {
  return x < y ? x : y;
}

static inline int16_t smin16(int16_t x, int16_t y) {
  return x < y ? x : y;
}

static inline int32_t smin32(int32_t x, int32_t y) {
  return x < y ? x : y;
}

static inline int64_t smin64(int64_t x, int64_t y) {
  return x < y ? x : y;
}

static inline uint8_t umin8(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint16_t umin16(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint32_t umin32(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint64_t umin64(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline int8_t smax8(int8_t x, int8_t y) {
  return x < y ? y : x;
}

static inline int16_t smax16(int16_t x, int16_t y) {
  return x < y ? y : x;
}

static inline int32_t smax32(int32_t x, int32_t y) {
  return x < y ? y : x;
}

static inline int64_t smax64(int64_t x, int64_t y) {
  return x < y ? y : x;
}

static inline uint8_t umax8(uint8_t x, uint8_t y) {
  return x < y ? y : x;
}

static inline uint16_t umax16(uint16_t x, uint16_t y) {
  return x < y ? y : x;
}

static inline uint32_t umax32(uint32_t x, uint32_t y) {
  return x < y ? y : x;
}

static inline uint64_t umax64(uint64_t x, uint64_t y) {
  return x < y ? y : x;
}

static inline uint8_t shl8(uint8_t x, uint8_t y) {
  return (uint8_t)(x << y);
}

static inline uint16_t shl16(uint16_t x, uint16_t y) {
  return (uint16_t)(x << y);
}

static inline uint32_t shl32(uint32_t x, uint32_t y) {
  return x << y;
}

static inline uint64_t shl64(uint64_t x, uint64_t y) {
  return x << y;
}

static inline uint8_t lshr8(uint8_t x, uint8_t y) {
  return x >> y;
}

static inline uint16_t lshr16(uint16_t x, uint16_t y) {
  return x >> y;
}

static inline uint32_t lshr32(uint32_t x, uint32_t y) {
  return x >> y;
}

static inline uint64_t lshr64(uint64_t x, uint64_t y) {
  return x >> y;
}

static inline int8_t ashr8(int8_t x, int8_t y) {
  return x >> y;
}

static inline int16_t ashr16(int16_t x, int16_t y) {
  return x >> y;
}

static inline int32_t ashr32(int32_t x, int32_t y) {
  return x >> y;
}

static inline int64_t ashr64(int64_t x, int64_t y) {
  return x >> y;
}

static inline uint8_t and8(uint8_t x, uint8_t y) {
  return x & y;
}

static inline uint16_t and16(uint16_t x, uint16_t y) {
  return x & y;
}

static inline uint32_t and32(uint32_t x, uint32_t y) {
  return x & y;
}

static inline uint64_t and64(uint64_t x, uint64_t y) {
  return x & y;
}

static inline uint8_t or8(uint8_t x, uint8_t y) {
  return x | y;
}

static inline uint16_t or16(uint16_t x, uint16_t y) {
  return x | y;
}

static inline uint32_t or32(uint32_t x, uint32_t y) {
  return x | y;
}

static inline uint64_t or64(uint64_t x, uint64_t y) {
  return x | y;
}

static inline uint8_t xor8(uint8_t x, uint8_t y) {
  return x ^ y;
}

static inline uint16_t xor16(uint16_t x, uint16_t y) {
  return x ^ y;
}

static inline uint32_t xor32(uint32_t x, uint32_t y) {
  return x ^ y;
}

static inline uint64_t xor64(uint64_t x, uint64_t y) {
  return x ^ y;
}

static inline bool ult8(uint8_t x, uint8_t y) {
  return x < y;
}

static inline bool ult16(uint16_t x, uint16_t y) {
  return x < y;
}

static inline bool ult32(uint32_t x, uint32_t y) {
  return x < y;
}

static inline bool ult64(uint64_t x, uint64_t y) {
  return x < y;
}

static inline bool ule8(uint8_t x, uint8_t y) {
  return x <= y;
}

static inline bool ule16(uint16_t x, uint16_t y) {
  return x <= y;
}

static inline bool ule32(uint32_t x, uint32_t y) {
  return x <= y;
}

static inline bool ule64(uint64_t x, uint64_t y) {
  return x <= y;
}

static inline bool slt8(int8_t x, int8_t y) {
  return x < y;
}

static inline bool slt16(int16_t x, int16_t y) {
  return x < y;
}

static inline bool slt32(int32_t x, int32_t y) {
  return x < y;
}

static inline bool slt64(int64_t x, int64_t y) {
  return x < y;
}

static inline bool sle8(int8_t x, int8_t y) {
  return x <= y;
}

static inline bool sle16(int16_t x, int16_t y) {
  return x <= y;
}

static inline bool sle32(int32_t x, int32_t y) {
  return x <= y;
}

static inline bool sle64(int64_t x, int64_t y) {
  return x <= y;
}

static inline uint8_t pow8(uint8_t x, uint8_t y) {
  uint8_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint16_t pow16(uint16_t x, uint16_t y) {
  uint16_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint32_t pow32(uint32_t x, uint32_t y) {
  uint32_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline uint64_t pow64(uint64_t x, uint64_t y) {
  uint64_t res = 1, rem = y;

  while (rem != 0) {
    if (rem & 1)
      res *= x;
    rem >>= 1;
    x *= x;
  }
  return res;
}

static inline bool itob_i8_bool(int8_t x) {
  return x;
}

static inline bool itob_i16_bool(int16_t x) {
  return x;
}

static inline bool itob_i32_bool(int32_t x) {
  return x;
}

static inline bool itob_i64_bool(int64_t x) {
  return x;
}

static inline int8_t btoi_bool_i8(bool x) {
  return x;
}

static inline int16_t btoi_bool_i16(bool x) {
  return x;
}

static inline int32_t btoi_bool_i32(bool x) {
  return x;
}

static inline int64_t btoi_bool_i64(bool x) {
  return x;
}

#define sext_i8_i8(x) ((int8_t) (int8_t) (x))
#define sext_i8_i16(x) ((int16_t) (int8_t) (x))
#define sext_i8_i32(x) ((int32_t) (int8_t) (x))
#define sext_i8_i64(x) ((int64_t) (int8_t) (x))
#define sext_i16_i8(x) ((int8_t) (int16_t) (x))
#define sext_i16_i16(x) ((int16_t) (int16_t) (x))
#define sext_i16_i32(x) ((int32_t) (int16_t) (x))
#define sext_i16_i64(x) ((int64_t) (int16_t) (x))
#define sext_i32_i8(x) ((int8_t) (int32_t) (x))
#define sext_i32_i16(x) ((int16_t) (int32_t) (x))
#define sext_i32_i32(x) ((int32_t) (int32_t) (x))
#define sext_i32_i64(x) ((int64_t) (int32_t) (x))
#define sext_i64_i8(x) ((int8_t) (int64_t) (x))
#define sext_i64_i16(x) ((int16_t) (int64_t) (x))
#define sext_i64_i32(x) ((int32_t) (int64_t) (x))
#define sext_i64_i64(x) ((int64_t) (int64_t) (x))
#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))
#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))
#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))
#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))
#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))
#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))
#define zext_i16_i32(x) ((int32_t) (uint16_t) (x))
#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))
#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))
#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))
#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))
#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))
#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))
#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))
#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))
#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))

static int8_t abs8(int8_t x) {
  return (int8_t)abs(x);
}

static int16_t abs16(int16_t x) {
  return (int16_t)abs(x);
}

static int32_t abs32(int32_t x) {
  return abs(x);
}

static int64_t abs64(int64_t x) {
#if defined(__OPENCL_VERSION__)
  return abs(x);
#else
  return llabs(x);
#endif
}

#if defined(__OPENCL_VERSION__)
static int32_t futrts_popc8(int8_t x) {
  return popcount(x);
}

static int32_t futrts_popc16(int16_t x) {
  return popcount(x);
}

static int32_t futrts_popc32(int32_t x) {
  return popcount(x);
}

static int32_t futrts_popc64(int64_t x) {
  return popcount(x);
}
#elif defined(__CUDA_ARCH__)

static int32_t futrts_popc8(int8_t x) {
  return __popc(zext_i8_i32(x));
}

static int32_t futrts_popc16(int16_t x) {
  return __popc(zext_i16_i32(x));
}

static int32_t futrts_popc32(int32_t x) {
  return __popc(x);
}

static int32_t futrts_popc64(int64_t x) {
  return __popcll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_popc8(uint8_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc16(uint16_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc32(uint32_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}

static int32_t futrts_popc64(uint64_t x) {
  int c = 0;
  for (; x; ++c) { x &= x - 1; }
  return c;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  return mul_hi(a, b);
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  return mul_hi(a, b);
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mul_hi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul_hi(a, b);
}

#elif defined(__CUDA_ARCH__)

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  return mulhi(a, b);
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  return mul64hi(a, b);
}

#else // Not OpenCL or CUDA, but plain C.

static uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {
  uint16_t aa = a;
  uint16_t bb = b;

  return aa * bb >> 8;
}

static uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {
  uint32_t aa = a;
  uint32_t bb = b;

  return aa * bb >> 16;
}

static uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {
  uint64_t aa = a;
  uint64_t bb = b;

  return aa * bb >> 32;
}

static uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {
  __uint128_t aa = a;
  __uint128_t bb = b;

  return aa * bb >> 64;
}
#endif

#if defined(__OPENCL_VERSION__)
static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return mad_hi(a, b, c);
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return mad_hi(a, b, c);
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return mad_hi(a, b, c);
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return mad_hi(a, b, c);
}

#else // Not OpenCL

static uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {
  return futrts_mul_hi8(a, b) + c;
}

static uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {
  return futrts_mul_hi16(a, b) + c;
}

static uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {
  return futrts_mul_hi32(a, b) + c;
}

static uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {
  return futrts_mul_hi64(a, b) + c;
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_clzz8(int8_t x) {
  return clz(x);
}

static int32_t futrts_clzz16(int16_t x) {
  return clz(x);
}

static int32_t futrts_clzz32(int32_t x) {
  return clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return clz(x);
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_clzz8(int8_t x) {
  return __clz(zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return __clz(zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return __clz(x);
}

static int32_t futrts_clzz64(int64_t x) {
  return __clzll(x);
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_clzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;
}

static int32_t futrts_clzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;
}

static int32_t futrts_clzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_clz((uint32_t)x);
}

static int32_t futrts_clzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);
}
#endif

#if defined(__OPENCL_VERSION__)
static int32_t futrts_ctzz8(int8_t x) {
  int i = 0;
  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz16(int16_t x) {
  int i = 0;
  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz32(int32_t x) {
  int i = 0;
  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

static int32_t futrts_ctzz64(int64_t x) {
  int i = 0;
  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)
    ;
  return i;
}

#elif defined(__CUDA_ARCH__)

static int32_t futrts_ctzz8(int8_t x) {
  int y = __ffs(x);
  return y == 0 ? 8 : y - 1;
}

static int32_t futrts_ctzz16(int16_t x) {
  int y = __ffs(x);
  return y == 0 ? 16 : y - 1;
}

static int32_t futrts_ctzz32(int32_t x) {
  int y = __ffs(x);
  return y == 0 ? 32 : y - 1;
}

static int32_t futrts_ctzz64(int64_t x) {
  int y = __ffsll(x);
  return y == 0 ? 64 : y - 1;
}

#else // Not OpenCL or CUDA, but plain C.

static int32_t futrts_ctzz8(int8_t x) {
  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz16(int16_t x) {
  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz32(int32_t x) {
  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);
}

static int32_t futrts_ctzz64(int64_t x) {
  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);
}
#endif

static inline float fdiv32(float x, float y) {
  return x / y;
}

static inline float fadd32(float x, float y) {
  return x + y;
}

static inline float fsub32(float x, float y) {
  return x - y;
}

static inline float fmul32(float x, float y) {
  return x * y;
}

static inline bool cmplt32(float x, float y) {
  return x < y;
}

static inline bool cmple32(float x, float y) {
  return x <= y;
}

static inline float sitofp_i8_f32(int8_t x) {
  return (float) x;
}

static inline float sitofp_i16_f32(int16_t x) {
  return (float) x;
}

static inline float sitofp_i32_f32(int32_t x) {
  return (float) x;
}

static inline float sitofp_i64_f32(int64_t x) {
  return (float) x;
}

static inline float uitofp_i8_f32(uint8_t x) {
  return (float) x;
}

static inline float uitofp_i16_f32(uint16_t x) {
  return (float) x;
}

static inline float uitofp_i32_f32(uint32_t x) {
  return (float) x;
}

static inline float uitofp_i64_f32(uint64_t x) {
  return (float) x;
}

static inline int8_t fptosi_f32_i8(float x) {
  return (int8_t) x;
}

static inline int16_t fptosi_f32_i16(float x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f32_i32(float x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f32_i64(float x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f32_i8(float x) {
  return (uint8_t) x;
}

static inline uint16_t fptoui_f32_i16(float x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f32_i32(float x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f32_i64(float x) {
  return (uint64_t) x;
}

#ifdef __OPENCL_VERSION__
static inline float fabs32(float x) {
  return fabs(x);
}

static inline float fmax32(float x, float y) {
  return fmax(x, y);
}

static inline float fmin32(float x, float y) {
  return fmin(x, y);
}

static inline float fpow32(float x, float y) {
  return pow(x, y);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float fabs32(float x) {
  return fabsf(x);
}

static inline float fmax32(float x, float y) {
  return fmaxf(x, y);
}

static inline float fmin32(float x, float y) {
  return fminf(x, y);
}

static inline float fpow32(float x, float y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan32(float x) {
  return isnan(x);
}

static inline bool futrts_isinf32(float x) {
  return isinf(x);
}

#ifdef __OPENCL_VERSION__
static inline float futrts_log32(float x) {
  return log(x);
}

static inline float futrts_log2_32(float x) {
  return log2(x);
}

static inline float futrts_log10_32(float x) {
  return log10(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrt(x);
}

static inline float futrts_exp32(float x) {
  return exp(x);
}

static inline float futrts_cos32(float x) {
  return cos(x);
}

static inline float futrts_sin32(float x) {
  return sin(x);
}

static inline float futrts_tan32(float x) {
  return tan(x);
}

static inline float futrts_acos32(float x) {
  return acos(x);
}

static inline float futrts_asin32(float x) {
  return asin(x);
}

static inline float futrts_atan32(float x) {
  return atan(x);
}

static inline float futrts_cosh32(float x) {
  return cosh(x);
}

static inline float futrts_sinh32(float x) {
  return sinh(x);
}

static inline float futrts_tanh32(float x) {
  return tanh(x);
}

static inline float futrts_acosh32(float x) {
  return acosh(x);
}

static inline float futrts_asinh32(float x) {
  return asinh(x);
}

static inline float futrts_atanh32(float x) {
  return atanh(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypot(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgamma(x);
}

static inline float futrts_lgamma32(float x) {
  return lgamma(x);
}

static inline float fmod32(float x, float y) {
  return fmod(x, y);
}

static inline float futrts_round32(float x) {
  return rint(x);
}

static inline float futrts_floor32(float x) {
  return floor(x);
}

static inline float futrts_ceil32(float x) {
  return ceil(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return mix(v0, v1, t);
}

static inline float futrts_mad32(float a, float b, float c) {
  return mad(a, b, c);
}

static inline float futrts_fma32(float a, float b, float c) {
  return fma(a, b, c);
}

#else // Not OpenCL, but CUDA or plain C.

static inline float futrts_log32(float x) {
  return logf(x);
}

static inline float futrts_log2_32(float x) {
  return log2f(x);
}

static inline float futrts_log10_32(float x) {
  return log10f(x);
}

static inline float futrts_sqrt32(float x) {
  return sqrtf(x);
}

static inline float futrts_exp32(float x) {
  return expf(x);
}

static inline float futrts_cos32(float x) {
  return cosf(x);
}

static inline float futrts_sin32(float x) {
  return sinf(x);
}

static inline float futrts_tan32(float x) {
  return tanf(x);
}

static inline float futrts_acos32(float x) {
  return acosf(x);
}

static inline float futrts_asin32(float x) {
  return asinf(x);
}

static inline float futrts_atan32(float x) {
  return atanf(x);
}

static inline float futrts_cosh32(float x) {
  return coshf(x);
}

static inline float futrts_sinh32(float x) {
  return sinhf(x);
}

static inline float futrts_tanh32(float x) {
  return tanhf(x);
}

static inline float futrts_acosh32(float x) {
  return acoshf(x);
}

static inline float futrts_asinh32(float x) {
  return asinhf(x);
}

static inline float futrts_atanh32(float x) {
  return atanhf(x);
}

static inline float futrts_atan2_32(float x, float y) {
  return atan2f(x, y);
}

static inline float futrts_hypot32(float x, float y) {
  return hypotf(x, y);
}

static inline float futrts_gamma32(float x) {
  return tgammaf(x);
}

static inline float futrts_lgamma32(float x) {
  return lgammaf(x);
}

static inline float fmod32(float x, float y) {
  return fmodf(x, y);
}

static inline float futrts_round32(float x) {
  return rintf(x);
}

static inline float futrts_floor32(float x) {
  return floorf(x);
}

static inline float futrts_ceil32(float x) {
  return ceilf(x);
}

static inline float futrts_lerp32(float v0, float v1, float t) {
  return v0 + (v1 - v0) * t;
}

static inline float futrts_mad32(float a, float b, float c) {
  return a * b + c;
}

static inline float futrts_fma32(float a, float b, float c) {
  return fmaf(a, b, c);
}
#endif

static inline int32_t futrts_to_bits32(float x) {
  union {
    float f;
    int32_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline float futrts_from_bits32(int32_t x) {
  union {
    int32_t f;
    float t;
  } p;

  p.f = x;
  return p.t;
}

static inline float fsignum32(float x) {
  return futrts_isnan32(x) ? x : (x > 0) - (x < 0);
}

#ifdef FUTHARK_F64_ENABLED

static inline double fdiv64(double x, double y) {
  return x / y;
}

static inline double fadd64(double x, double y) {
  return x + y;
}

static inline double fsub64(double x, double y) {
  return x - y;
}

static inline double fmul64(double x, double y) {
  return x * y;
}

static inline bool cmplt64(double x, double y) {
  return x < y;
}

static inline bool cmple64(double x, double y) {
  return x <= y;
}

static inline double sitofp_i8_f64(int8_t x) {
  return (double) x;
}

static inline double sitofp_i16_f64(int16_t x) {
  return (double) x;
}

static inline double sitofp_i32_f64(int32_t x) {
  return (double) x;
}

static inline double sitofp_i64_f64(int64_t x) {
  return (double) x;
}

static inline double uitofp_i8_f64(uint8_t x) {
  return (double) x;
}

static inline double uitofp_i16_f64(uint16_t x) {
  return (double) x;
}

static inline double uitofp_i32_f64(uint32_t x) {
  return (double) x;
}

static inline double uitofp_i64_f64(uint64_t x) {
  return (double) x;
}

static inline int8_t fptosi_f64_i8(double x) {
  return (int8_t) x;
}

static inline int16_t fptosi_f64_i16(double x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f64_i32(double x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f64_i64(double x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f64_i8(double x) {
  return (uint8_t) x;
}

static inline uint16_t fptoui_f64_i16(double x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f64_i32(double x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f64_i64(double x) {
  return (uint64_t) x;
}

static inline double fabs64(double x) {
  return fabs(x);
}

static inline double fmax64(double x, double y) {
  return fmax(x, y);
}

static inline double fmin64(double x, double y) {
  return fmin(x, y);
}

static inline double fpow64(double x, double y) {
  return pow(x, y);
}

static inline double futrts_log64(double x) {
  return log(x);
}

static inline double futrts_log2_64(double x) {
  return log2(x);
}

static inline double futrts_log10_64(double x) {
  return log10(x);
}

static inline double futrts_sqrt64(double x) {
  return sqrt(x);
}

static inline double futrts_exp64(double x) {
  return exp(x);
}

static inline double futrts_cos64(double x) {
  return cos(x);
}

static inline double futrts_sin64(double x) {
  return sin(x);
}

static inline double futrts_tan64(double x) {
  return tan(x);
}

static inline double futrts_acos64(double x) {
  return acos(x);
}

static inline double futrts_asin64(double x) {
  return asin(x);
}

static inline double futrts_atan64(double x) {
  return atan(x);
}

static inline double futrts_cosh64(double x) {
  return cosh(x);
}

static inline double futrts_sinh64(double x) {
  return sinh(x);
}

static inline double futrts_tanh64(double x) {
  return tanh(x);
}

static inline double futrts_acosh64(double x) {
  return acosh(x);
}

static inline double futrts_asinh64(double x) {
  return asinh(x);
}

static inline double futrts_atanh64(double x) {
  return atanh(x);
}

static inline double futrts_atan2_64(double x, double y) {
  return atan2(x, y);
}

static inline double futrts_hypot64(double x, double y) {
  return hypot(x, y);
}

static inline double futrts_gamma64(double x) {
  return tgamma(x);
}

static inline double futrts_lgamma64(double x) {
  return lgamma(x);
}

static inline double futrts_fma64(double a, double b, double c) {
  return fma(a, b, c);
}

static inline double futrts_round64(double x) {
  return rint(x);
}

static inline double futrts_ceil64(double x) {
  return ceil(x);
}

static inline double futrts_floor64(double x) {
  return floor(x);
}

static inline bool futrts_isnan64(double x) {
  return isnan(x);
}

static inline bool futrts_isinf64(double x) {
  return isinf(x);
}

static inline int64_t futrts_to_bits64(double x) {
  union {
    double f;
    int64_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline double futrts_from_bits64(int64_t x) {
  union {
    int64_t f;
    double t;
  } p;

  p.f = x;
  return p.t;
}

static inline double fmod64(double x, double y) {
  return fmod(x, y);
}

static inline double fsignum64(double x) {
  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);
}

static inline double futrts_lerp64(double v0, double v1, double t) {
#ifdef __OPENCL_VERSION__
  return mix(v0, v1, t);
#else
  return v0 + (v1 - v0) * t;
#endif
}

static inline double futrts_mad64(double a, double b, double c) {
#ifdef __OPENCL_VERSION__
  return mad(a, b, c);
#else
  return a * b + c;
#endif
}

static inline float fpconv_f32_f32(float x) {
  return (float) x;
}

static inline double fpconv_f32_f64(float x) {
  return (double) x;
}

static inline float fpconv_f64_f32(double x) {
  return (float) x;
}

static inline double fpconv_f64_f64(double x) {
  return (double) x;
}

#endif

// End of scalar.h.
// Start of scalar_f16.h.

// Half-precision is emulated if needed (e.g. in straight C) with the
// native type used if possible.  The emulation works by typedef'ing
// 'float' to 'f16', and then implementing all operations on single
// precision.  To cut down on duplication, we use the same code for
// those Futhark functions that require just operators or casts.  The
// in-memory representation for arrays will still be 16 bits even
// under emulation, so the compiler will have to be careful when
// generating reads or writes.

#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600)
#define EMULATE_F16
#endif

#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#endif

#ifdef EMULATE_F16

// Note that the half-precision storage format is still 16 bits - the
// compiler will have to be real careful!
typedef float f16;

#else

#ifdef __CUDA_ARCH__
#include <cuda_fp16.h>
#endif

typedef half f16;

#endif

// Some of these functions convert to single precision because half
// precision versions are not available.

static inline f16 fadd16(f16 x, f16 y) {
  return x + y;
}

static inline f16 fsub16(f16 x, f16 y) {
  return x - y;
}

static inline f16 fmul16(f16 x, f16 y) {
  return x * y;
}

static inline bool cmplt16(f16 x, f16 y) {
  return x < y;
}

static inline bool cmple16(f16 x, f16 y) {
  return x <= y;
}

static inline f16 sitofp_i8_f16(int8_t x) {
  return (f16) x;
}

static inline f16 sitofp_i16_f16(int16_t x) {
  return (f16) x;
}

static inline f16 sitofp_i32_f16(int32_t x) {
  return (f16) x;
}

static inline f16 sitofp_i64_f16(int64_t x) {
  return (f16) x;
}

static inline f16 uitofp_i8_f16(uint8_t x) {
  return (f16) x;
}

static inline f16 uitofp_i16_f16(uint16_t x) {
  return (f16) x;
}

static inline f16 uitofp_i32_f16(uint32_t x) {
  return (f16) x;
}

static inline f16 uitofp_i64_f16(uint64_t x) {
  return (f16) x;
}

static inline int8_t fptosi_f16_i8(f16 x) {
  return (int8_t) (float) x;
}

static inline int16_t fptosi_f16_i16(f16 x) {
  return (int16_t) x;
}

static inline int32_t fptosi_f16_i32(f16 x) {
  return (int32_t) x;
}

static inline int64_t fptosi_f16_i64(f16 x) {
  return (int64_t) x;
}

static inline uint8_t fptoui_f16_i8(f16 x) {
  return (uint8_t) (float) x;
}

static inline uint16_t fptoui_f16_i16(f16 x) {
  return (uint16_t) x;
}

static inline uint32_t fptoui_f16_i32(f16 x) {
  return (uint32_t) x;
}

static inline uint64_t fptoui_f16_i64(f16 x) {
  return (uint64_t) x;
}

#ifndef EMULATE_F16

#ifdef __OPENCL_VERSION__
static inline f16 fabs16(f16 x) {
  return fabs(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return pow(x, y);
}

#else // Assuming CUDA.

static inline f16 fabs16(f16 x) {
  return fabsf(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmaxf(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fminf(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return powf(x, y);
}
#endif

static inline bool futrts_isnan16(f16 x) {
  return isnan((float)x);
}

static inline bool futrts_isinf16(f16 x) {
  return isinf((float)x);
}

#ifdef __OPENCL_VERSION__
static inline f16 futrts_log16(f16 x) {
  return log(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return log2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return log10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return sqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return exp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return cos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return sin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tan(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acos(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asin(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atan(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return cosh(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinh(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanh(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acosh(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinh(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanh(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypot(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgamma(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgamma(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rint(x);
}

static inline f16 futrts_floor16(f16 x) {
  return floor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return ceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return mix(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return mad(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fma(a, b, c);
}

#else // Assume CUDA.

static inline f16 futrts_log16(f16 x) {
  return hlog(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return hlog2(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return hlog10(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return hsqrt(x);
}

static inline f16 futrts_exp16(f16 x) {
  return hexp(x);
}

static inline f16 futrts_cos16(f16 x) {
  return hcos(x);
}

static inline f16 futrts_sin16(f16 x) {
  return hsin(x);
}

static inline f16 futrts_tan16(f16 x) {
  return tanf(x);
}

static inline f16 futrts_acos16(f16 x) {
  return acosf(x);
}

static inline f16 futrts_asin16(f16 x) {
  return asinf(x);
}

static inline f16 futrts_atan16(f16 x) {
  return atanf(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return coshf(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return sinhf(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return tanhf(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return acoshf(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return asinhf(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return atanhf(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return atan2f(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return hypotf(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return tgammaf(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return lgammaf(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmodf(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return rintf(x);
}

static inline f16 futrts_floor16(f16 x) {
  return hfloor(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return hceil(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return v0 + (v1 - v0) * t;
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return a * b + c;
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return fmaf(a, b, c);
}

#endif

// The CUDA __half type cannot be put in unions for some reason, so we
// use bespoke conversion functions instead.
#ifdef __CUDA_ARCH__
static inline int16_t futrts_to_bits16(f16 x) {
  return __half_as_ushort(x);
}
static inline f16 futrts_from_bits16(int16_t x) {
  return __ushort_as_half(x);
}
#else
static inline int16_t futrts_to_bits16(f16 x) {
  union {
    f16 f;
    int16_t t;
  } p;

  p.f = x;
  return p.t;
}

static inline f16 futrts_from_bits16(int16_t x) {
  union {
    int16_t f;
    f16 t;
  } p;

  p.f = x;
  return p.t;
}
#endif

#else // No native f16 - emulate.

static inline f16 fabs16(f16 x) {
  return fabs32(x);
}

static inline f16 fmax16(f16 x, f16 y) {
  return fmax32(x, y);
}

static inline f16 fmin16(f16 x, f16 y) {
  return fmin32(x, y);
}

static inline f16 fpow16(f16 x, f16 y) {
  return fpow32(x, y);
}

static inline bool futrts_isnan16(f16 x) {
  return futrts_isnan32(x);
}

static inline bool futrts_isinf16(f16 x) {
  return futrts_isinf32(x);
}

static inline f16 futrts_log16(f16 x) {
  return futrts_log32(x);
}

static inline f16 futrts_log2_16(f16 x) {
  return futrts_log2_32(x);
}

static inline f16 futrts_log10_16(f16 x) {
  return futrts_log10_32(x);
}

static inline f16 futrts_sqrt16(f16 x) {
  return futrts_sqrt32(x);
}

static inline f16 futrts_exp16(f16 x) {
  return futrts_exp32(x);
}

static inline f16 futrts_cos16(f16 x) {
  return futrts_cos32(x);
}

static inline f16 futrts_sin16(f16 x) {
  return futrts_sin32(x);
}

static inline f16 futrts_tan16(f16 x) {
  return futrts_tan32(x);
}

static inline f16 futrts_acos16(f16 x) {
  return futrts_acos32(x);
}

static inline f16 futrts_asin16(f16 x) {
  return futrts_asin32(x);
}

static inline f16 futrts_atan16(f16 x) {
  return futrts_atan32(x);
}

static inline f16 futrts_cosh16(f16 x) {
  return futrts_cosh32(x);
}

static inline f16 futrts_sinh16(f16 x) {
  return futrts_sinh32(x);
}

static inline f16 futrts_tanh16(f16 x) {
  return futrts_tanh32(x);
}

static inline f16 futrts_acosh16(f16 x) {
  return futrts_acosh32(x);
}

static inline f16 futrts_asinh16(f16 x) {
  return futrts_asinh32(x);
}

static inline f16 futrts_atanh16(f16 x) {
  return futrts_atanh32(x);
}

static inline f16 futrts_atan2_16(f16 x, f16 y) {
  return futrts_atan2_32(x, y);
}

static inline f16 futrts_hypot16(f16 x, f16 y) {
  return futrts_hypot32(x, y);
}

static inline f16 futrts_gamma16(f16 x) {
  return futrts_gamma32(x);
}

static inline f16 futrts_lgamma16(f16 x) {
  return futrts_lgamma32(x);
}

static inline f16 fmod16(f16 x, f16 y) {
  return fmod32(x, y);
}

static inline f16 futrts_round16(f16 x) {
  return futrts_round32(x);
}

static inline f16 futrts_floor16(f16 x) {
  return futrts_floor32(x);
}

static inline f16 futrts_ceil16(f16 x) {
  return futrts_ceil32(x);
}

static inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {
  return futrts_lerp32(v0, v1, t);
}

static inline f16 futrts_mad16(f16 a, f16 b, f16 c) {
  return futrts_mad32(a, b, c);
}

static inline f16 futrts_fma16(f16 a, f16 b, f16 c) {
  return futrts_fma32(a, b, c);
}

// Even when we are using an OpenCL that does not support cl_khr_fp16,
// it must still support vload_half for actually creating a
// half-precision number, which can then be efficiently converted to a
// float.  Similarly for vstore_half.
#ifdef __OPENCL_VERSION__

static inline int16_t futrts_to_bits16(f16 x) {
  int16_t y;
  // Violating strict aliasing here.
  vstore_half((float)x, 0, (half*)&y);
  return y;
}

static inline f16 futrts_from_bits16(int16_t x) {
  return (f16)vload_half(0, (half*)&x);
}

#else

static inline int16_t futrts_to_bits16(f16 x) {
  return (int16_t)float2halfbits(x);
}

static inline f16 futrts_from_bits16(int16_t x) {
  return halfbits2float((uint16_t)x);
}

static inline f16 fsignum16(f16 x) {
  return futrts_isnan16(x) ? x : (x > 0) - (x < 0);
}

#endif

#endif

static inline float fpconv_f16_f16(f16 x) {
  return x;
}

static inline float fpconv_f16_f32(f16 x) {
  return x;
}

static inline f16 fpconv_f32_f16(float x) {
  return x;
}

#ifdef FUTHARK_F64_ENABLED

static inline double fpconv_f16_f64(f16 x) {
  return (double) x;
}

static inline f16 fpconv_f64_f16(double x) {
  return (f16) x;
}

#endif


// End of scalar_f16.h.

static int init_constants(struct futhark_context *);
static int free_constants(struct futhark_context *);
static int32_t dotzicounter_mem_realtype_20782[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0,
                                                      0};
static int32_t matrixMatrixMulzicounter_mem_realtype_20853[10240];
static int32_t matrixVectorMulzicounter_mem_realtype_20888[10240];
static int32_t normalizzeVzicounter_mem_realtype_20895[10] = {0, 0, 0, 0, 0, 0,
                                                              0, 0, 0, 0};
static int32_t vectorMatrixMulzicounter_mem_realtype_20942[10240];
static int32_t vectorNormzicounter_mem_realtype_20955[10] = {0, 0, 0, 0, 0, 0,
                                                             0, 0, 0, 0};
struct memblock_device {
    int *references;
    cl_mem mem;
    int64_t size;
    const char *desc;
};
struct memblock {
    int *references;
    unsigned char *mem;
    int64_t size;
    const char *desc;
};
typedef cl_mem fl_mem_t;
// Start of free_list.h.

// An entry in the free list.  May be invalid, to avoid having to
// deallocate entries as soon as they are removed.  There is also a
// tag, to help with memory reuse.
struct free_list_entry {
  size_t size;
  fl_mem_t mem;
  const char *tag;
  unsigned char valid;
};

struct free_list {
  struct free_list_entry *entries;        // Pointer to entries.
  int capacity;                           // Number of entries.
  int used;                               // Number of valid entries.
};

static void free_list_init(struct free_list *l) {
  l->capacity = 30; // Picked arbitrarily.
  l->used = 0;
  l->entries = (struct free_list_entry*) malloc(sizeof(struct free_list_entry) * l->capacity);
  for (int i = 0; i < l->capacity; i++) {
    l->entries[i].valid = 0;
  }
}

// Remove invalid entries from the free list.
static void free_list_pack(struct free_list *l) {
  int p = 0;
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[p] = l->entries[i];
      if (i > p) {
        l->entries[i].valid = 0;
      }
      p++;
    }
  }

  // Now p is the number of used elements.  We don't want it to go
  // less than the default capacity (although in practice it's OK as
  // long as it doesn't become 1).
  if (p < 30) {
    p = 30;
  }
  l->entries = realloc(l->entries, p * sizeof(struct free_list_entry));
  l->capacity = p;
}

static void free_list_destroy(struct free_list *l) {
  assert(l->used == 0);
  free(l->entries);
}

static int free_list_find_invalid(struct free_list *l) {
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (!l->entries[i].valid) {
      break;
    }
  }
  return i;
}

static void free_list_insert(struct free_list *l, size_t size, fl_mem_t mem, const char *tag) {
  int i = free_list_find_invalid(l);

  if (i == l->capacity) {
    // List is full; so we have to grow it.
    int new_capacity = l->capacity * 2 * sizeof(struct free_list_entry);
    l->entries = realloc(l->entries, new_capacity);
    for (int j = 0; j < l->capacity; j++) {
      l->entries[j+l->capacity].valid = 0;
    }
    l->capacity *= 2;
  }

  // Now 'i' points to the first invalid entry.
  l->entries[i].valid = 1;
  l->entries[i].size = size;
  l->entries[i].mem = mem;
  l->entries[i].tag = tag;

  l->used++;
}

// Find and remove a memory block of the indicated tag, or if that
// does not exist, another memory block with exactly the desired size.
// Returns 0 on success.
static int free_list_find(struct free_list *l, size_t size,
                          size_t *size_out, fl_mem_t *mem_out) {
  int size_match = -1;
  int i;
  for (i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid &&
        size <= l->entries[i].size &&
        (size_match < 0 || l->entries[i].size < l->entries[size_match].size)) {
      // If this entry is valid, has sufficient size, and is smaller than the
      // best entry found so far, use this entry.
      size_match = i;
    }
  }

  if (size_match >= 0) {
    l->entries[size_match].valid = 0;
    *size_out = l->entries[size_match].size;
    *mem_out = l->entries[size_match].mem;
    l->used--;
    return 0;
  } else {
    return 1;
  }
}

// Remove the first block in the free list.  Returns 0 if a block was
// removed, and nonzero if the free list was already empty.
static int free_list_first(struct free_list *l, fl_mem_t *mem_out) {
  for (int i = 0; i < l->capacity; i++) {
    if (l->entries[i].valid) {
      l->entries[i].valid = 0;
      *mem_out = l->entries[i].mem;
      l->used--;
      return 0;
    }
  }

  return 1;
}

// End of free_list.h.

// Start of opencl.h.

#define OPENCL_SUCCEED_FATAL(e) opencl_succeed_fatal(e, #e, __FILE__, __LINE__)
#define OPENCL_SUCCEED_NONFATAL(e) opencl_succeed_nonfatal(e, #e, __FILE__, __LINE__)
// Take care not to override an existing error.
#define OPENCL_SUCCEED_OR_RETURN(e) {             \
    char *serror = OPENCL_SUCCEED_NONFATAL(e);    \
    if (serror) {                                 \
      if (!ctx->error) {                          \
        ctx->error = serror;                      \
        return bad;                               \
      } else {                                    \
        free(serror);                             \
      }                                           \
    }                                             \
  }

// OPENCL_SUCCEED_OR_RETURN returns the value of the variable 'bad' in
// scope.  By default, it will be this one.  Create a local variable
// of some other type if needed.  This is a bit of a hack, but it
// saves effort in the code generator.
static const int bad = 1;

struct opencl_config {
  int debugging;
  int profiling;
  int logging;
  int preferred_device_num;
  const char *preferred_platform;
  const char *preferred_device;
  int ignore_blacklist;

  const char* dump_program_to;
  const char* load_program_from;
  const char* dump_binary_to;
  const char* load_binary_from;

  size_t default_group_size;
  size_t default_num_groups;
  size_t default_tile_size;
  size_t default_reg_tile_size;
  size_t default_threshold;

  int default_group_size_changed;
  int default_tile_size_changed;

  int num_sizes;
  const char **size_names;
  const char **size_vars;
  int64_t *size_values;
  const char **size_classes;
};

static void opencl_config_init(struct opencl_config *cfg,
                               int num_sizes,
                               const char *size_names[],
                               const char *size_vars[],
                               int64_t *size_values,
                               const char *size_classes[]) {
  cfg->debugging = 0;
  cfg->logging = 0;
  cfg->profiling = 0;
  cfg->preferred_device_num = 0;
  cfg->preferred_platform = "";
  cfg->preferred_device = "";
  cfg->ignore_blacklist = 0;
  cfg->dump_program_to = NULL;
  cfg->load_program_from = NULL;
  cfg->dump_binary_to = NULL;
  cfg->load_binary_from = NULL;

  // The following are dummy sizes that mean the concrete defaults
  // will be set during initialisation via hardware-inspection-based
  // heuristics.
  cfg->default_group_size = 0;
  cfg->default_num_groups = 0;
  cfg->default_tile_size = 0;
  cfg->default_reg_tile_size = 0;
  cfg->default_threshold = 0;

  cfg->default_group_size_changed = 0;
  cfg->default_tile_size_changed = 0;

  cfg->num_sizes = num_sizes;
  cfg->size_names = size_names;
  cfg->size_vars = size_vars;
  cfg->size_values = size_values;
  cfg->size_classes = size_classes;
}

// A record of something that happened.
struct profiling_record {
  cl_event *event;
  int *runs;
  int64_t *runtime;
};

struct opencl_context {
  cl_device_id device;
  cl_context ctx;
  cl_command_queue queue;

  struct opencl_config cfg;

  struct free_list free_list;

  size_t max_group_size;
  size_t max_num_groups;
  size_t max_tile_size;
  size_t max_threshold;
  size_t max_local_memory;

  size_t lockstep_width;

  struct profiling_record *profiling_records;
  int profiling_records_capacity;
  int profiling_records_used;
};

struct opencl_device_option {
  cl_platform_id platform;
  cl_device_id device;
  cl_device_type device_type;
  char *platform_name;
  char *device_name;
};

// This function must be defined by the user.  It is invoked by
// setup_opencl() after the platform and device has been found, but
// before the program is loaded.  Its intended use is to tune
// constants based on the selected platform and device.
static void post_opencl_setup(struct opencl_context*, struct opencl_device_option*);

static char *strclone(const char *str) {
  size_t size = strlen(str) + 1;
  char *copy = (char*) malloc(size);
  if (copy == NULL) {
    return NULL;
  }

  memcpy(copy, str, size);
  return copy;
}

static const char* opencl_error_string(cl_int err)
{
    switch (err) {
        case CL_SUCCESS:                            return "Success!";
        case CL_DEVICE_NOT_FOUND:                   return "Device not found.";
        case CL_DEVICE_NOT_AVAILABLE:               return "Device not available";
        case CL_COMPILER_NOT_AVAILABLE:             return "Compiler not available";
        case CL_MEM_OBJECT_ALLOCATION_FAILURE:      return "Memory object allocation failure";
        case CL_OUT_OF_RESOURCES:                   return "Out of resources";
        case CL_OUT_OF_HOST_MEMORY:                 return "Out of host memory";
        case CL_PROFILING_INFO_NOT_AVAILABLE:       return "Profiling information not available";
        case CL_MEM_COPY_OVERLAP:                   return "Memory copy overlap";
        case CL_IMAGE_FORMAT_MISMATCH:              return "Image format mismatch";
        case CL_IMAGE_FORMAT_NOT_SUPPORTED:         return "Image format not supported";
        case CL_BUILD_PROGRAM_FAILURE:              return "Program build failure";
        case CL_MAP_FAILURE:                        return "Map failure";
        case CL_INVALID_VALUE:                      return "Invalid value";
        case CL_INVALID_DEVICE_TYPE:                return "Invalid device type";
        case CL_INVALID_PLATFORM:                   return "Invalid platform";
        case CL_INVALID_DEVICE:                     return "Invalid device";
        case CL_INVALID_CONTEXT:                    return "Invalid context";
        case CL_INVALID_QUEUE_PROPERTIES:           return "Invalid queue properties";
        case CL_INVALID_COMMAND_QUEUE:              return "Invalid command queue";
        case CL_INVALID_HOST_PTR:                   return "Invalid host pointer";
        case CL_INVALID_MEM_OBJECT:                 return "Invalid memory object";
        case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:    return "Invalid image format descriptor";
        case CL_INVALID_IMAGE_SIZE:                 return "Invalid image size";
        case CL_INVALID_SAMPLER:                    return "Invalid sampler";
        case CL_INVALID_BINARY:                     return "Invalid binary";
        case CL_INVALID_BUILD_OPTIONS:              return "Invalid build options";
        case CL_INVALID_PROGRAM:                    return "Invalid program";
        case CL_INVALID_PROGRAM_EXECUTABLE:         return "Invalid program executable";
        case CL_INVALID_KERNEL_NAME:                return "Invalid kernel name";
        case CL_INVALID_KERNEL_DEFINITION:          return "Invalid kernel definition";
        case CL_INVALID_KERNEL:                     return "Invalid kernel";
        case CL_INVALID_ARG_INDEX:                  return "Invalid argument index";
        case CL_INVALID_ARG_VALUE:                  return "Invalid argument value";
        case CL_INVALID_ARG_SIZE:                   return "Invalid argument size";
        case CL_INVALID_KERNEL_ARGS:                return "Invalid kernel arguments";
        case CL_INVALID_WORK_DIMENSION:             return "Invalid work dimension";
        case CL_INVALID_WORK_GROUP_SIZE:            return "Invalid work group size";
        case CL_INVALID_WORK_ITEM_SIZE:             return "Invalid work item size";
        case CL_INVALID_GLOBAL_OFFSET:              return "Invalid global offset";
        case CL_INVALID_EVENT_WAIT_LIST:            return "Invalid event wait list";
        case CL_INVALID_EVENT:                      return "Invalid event";
        case CL_INVALID_OPERATION:                  return "Invalid operation";
        case CL_INVALID_GL_OBJECT:                  return "Invalid OpenGL object";
        case CL_INVALID_BUFFER_SIZE:                return "Invalid buffer size";
        case CL_INVALID_MIP_LEVEL:                  return "Invalid mip-map level";
        default:                                    return "Unknown";
    }
}

static void opencl_succeed_fatal(cl_int ret,
                                 const char *call,
                                 const char *file,
                                 int line) {
  if (ret != CL_SUCCESS) {
    futhark_panic(-1, "%s:%d: OpenCL call\n  %s\nfailed with error code %d (%s)\n",
          file, line, call, ret, opencl_error_string(ret));
  }
}

static char* opencl_succeed_nonfatal(cl_int ret,
                                     const char *call,
                                     const char *file,
                                     int line) {
  if (ret != CL_SUCCESS) {
    return msgprintf("%s:%d: OpenCL call\n  %s\nfailed with error code %d (%s)\n",
                     file, line, call, ret, opencl_error_string(ret));
  } else {
    return NULL;
  }
}

static void set_preferred_platform(struct opencl_config *cfg, const char *s) {
  cfg->preferred_platform = s;
  cfg->ignore_blacklist = 1;
}

static void set_preferred_device(struct opencl_config *cfg, const char *s) {
  int x = 0;
  if (*s == '#') {
    s++;
    while (isdigit(*s)) {
      x = x * 10 + (*s++)-'0';
    }
    // Skip trailing spaces.
    while (isspace(*s)) {
      s++;
    }
  }
  cfg->preferred_device = s;
  cfg->preferred_device_num = x;
  cfg->ignore_blacklist = 1;
}

static char* opencl_platform_info(cl_platform_id platform,
                                  cl_platform_info param) {
  size_t req_bytes;
  char *info;

  OPENCL_SUCCEED_FATAL(clGetPlatformInfo(platform, param, 0, NULL, &req_bytes));

  info = (char*) malloc(req_bytes);

  OPENCL_SUCCEED_FATAL(clGetPlatformInfo(platform, param, req_bytes, info, NULL));

  return info;
}

static char* opencl_device_info(cl_device_id device,
                                cl_device_info param) {
  size_t req_bytes;
  char *info;

  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device, param, 0, NULL, &req_bytes));

  info = (char*) malloc(req_bytes);

  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device, param, req_bytes, info, NULL));

  return info;
}

static void opencl_all_device_options(struct opencl_device_option **devices_out,
                                      size_t *num_devices_out) {
  size_t num_devices = 0, num_devices_added = 0;

  cl_platform_id *all_platforms;
  cl_uint *platform_num_devices;

  cl_uint num_platforms;

  // Find the number of platforms.
  OPENCL_SUCCEED_FATAL(clGetPlatformIDs(0, NULL, &num_platforms));

  // Make room for them.
  all_platforms = calloc(num_platforms, sizeof(cl_platform_id));
  platform_num_devices = calloc(num_platforms, sizeof(cl_uint));

  // Fetch all the platforms.
  OPENCL_SUCCEED_FATAL(clGetPlatformIDs(num_platforms, all_platforms, NULL));

  // Count the number of devices for each platform, as well as the
  // total number of devices.
  for (cl_uint i = 0; i < num_platforms; i++) {
    if (clGetDeviceIDs(all_platforms[i], CL_DEVICE_TYPE_ALL,
                       0, NULL, &platform_num_devices[i]) == CL_SUCCESS) {
      num_devices += platform_num_devices[i];
    } else {
      platform_num_devices[i] = 0;
    }
  }

  // Make room for all the device options.
  struct opencl_device_option *devices =
    calloc(num_devices, sizeof(struct opencl_device_option));

  // Loop through the platforms, getting information about their devices.
  for (cl_uint i = 0; i < num_platforms; i++) {
    cl_platform_id platform = all_platforms[i];
    cl_uint num_platform_devices = platform_num_devices[i];

    if (num_platform_devices == 0) {
      continue;
    }

    char *platform_name = opencl_platform_info(platform, CL_PLATFORM_NAME);
    cl_device_id *platform_devices =
      calloc(num_platform_devices, sizeof(cl_device_id));

    // Fetch all the devices.
    OPENCL_SUCCEED_FATAL(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL,
                                  num_platform_devices, platform_devices, NULL));

    // Loop through the devices, adding them to the devices array.
    for (cl_uint i = 0; i < num_platform_devices; i++) {
      char *device_name = opencl_device_info(platform_devices[i], CL_DEVICE_NAME);
      devices[num_devices_added].platform = platform;
      devices[num_devices_added].device = platform_devices[i];
      OPENCL_SUCCEED_FATAL(clGetDeviceInfo(platform_devices[i], CL_DEVICE_TYPE,
                                     sizeof(cl_device_type),
                                     &devices[num_devices_added].device_type,
                                     NULL));
      // We don't want the structs to share memory, so copy the platform name.
      // Each device name is already unique.
      devices[num_devices_added].platform_name = strclone(platform_name);
      devices[num_devices_added].device_name = device_name;
      num_devices_added++;
    }
    free(platform_devices);
    free(platform_name);
  }
  free(all_platforms);
  free(platform_num_devices);

  *devices_out = devices;
  *num_devices_out = num_devices;
}

// Returns 0 on success.
static int list_devices(void) {
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  const char *cur_platform = "";
  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strcmp(cur_platform, device.platform_name) != 0) {
      printf("Platform: %s\n", device.platform_name);
      cur_platform = device.platform_name;
    }
    printf("[%d]: %s\n", (int)i, device.device_name);
  }

  // Free all the platform and device names.
  for (size_t j = 0; j < num_devices; j++) {
    free(devices[j].platform_name);
    free(devices[j].device_name);
  }
  free(devices);

  return 0;
}

// Returns 0 on success.
static int select_device_interactively(struct opencl_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;
  int ret = 1;

  opencl_all_device_options(&devices, &num_devices);

  printf("Choose OpenCL device:\n");
  const char *cur_platform = "";
  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strcmp(cur_platform, device.platform_name) != 0) {
      printf("Platform: %s\n", device.platform_name);
      cur_platform = device.platform_name;
    }
    printf("[%d] %s\n", (int)i, device.device_name);
  }

  int selection;
  printf("Choice: ");
  if (scanf("%d", &selection) == 1) {
    ret = 0;
    cfg->preferred_platform = "";
    cfg->preferred_device = "";
    cfg->preferred_device_num = selection;
    cfg->ignore_blacklist = 1;
  }

  // Free all the platform and device names.
  for (size_t j = 0; j < num_devices; j++) {
    free(devices[j].platform_name);
    free(devices[j].device_name);
  }
  free(devices);

  return ret;
}

static int is_blacklisted(const char *platform_name, const char *device_name,
                          const struct opencl_config *cfg) {
  if (strcmp(cfg->preferred_platform, "") != 0 ||
      strcmp(cfg->preferred_device, "") != 0) {
    return 0;
  } else if (strstr(platform_name, "Apple") != NULL &&
             strstr(device_name, "Intel(R) Core(TM)") != NULL) {
    return 1;
  } else {
    return 0;
  }
}

static struct opencl_device_option get_preferred_device(const struct opencl_config *cfg) {
  struct opencl_device_option *devices;
  size_t num_devices;

  opencl_all_device_options(&devices, &num_devices);

  int num_device_matches = 0;

  for (size_t i = 0; i < num_devices; i++) {
    struct opencl_device_option device = devices[i];
    if (strstr(device.platform_name, cfg->preferred_platform) != NULL &&
        strstr(device.device_name, cfg->preferred_device) != NULL &&
        (cfg->ignore_blacklist ||
         !is_blacklisted(device.platform_name, device.device_name, cfg)) &&
        num_device_matches++ == cfg->preferred_device_num) {
      // Free all the platform and device names, except the ones we have chosen.
      for (size_t j = 0; j < num_devices; j++) {
        if (j != i) {
          free(devices[j].platform_name);
          free(devices[j].device_name);
        }
      }
      free(devices);
      return device;
    }
  }

  futhark_panic(1, "Could not find acceptable OpenCL device.\n");
  exit(1); // Never reached
}

static void describe_device_option(struct opencl_device_option device) {
  fprintf(stderr, "Using platform: %s\n", device.platform_name);
  fprintf(stderr, "Using device: %s\n", device.device_name);
}

static cl_build_status build_opencl_program(cl_program program, cl_device_id device, const char* options) {
  cl_int clBuildProgram_error = clBuildProgram(program, 1, &device, options, NULL, NULL);

  // Avoid termination due to CL_BUILD_PROGRAM_FAILURE
  if (clBuildProgram_error != CL_SUCCESS &&
      clBuildProgram_error != CL_BUILD_PROGRAM_FAILURE) {
    OPENCL_SUCCEED_FATAL(clBuildProgram_error);
  }

  cl_build_status build_status;
  OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program,
                                             device,
                                             CL_PROGRAM_BUILD_STATUS,
                                             sizeof(cl_build_status),
                                             &build_status,
                                             NULL));

  if (build_status != CL_SUCCESS) {
    char *build_log;
    size_t ret_val_size;
    OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &ret_val_size));

    build_log = (char*) malloc(ret_val_size+1);
    OPENCL_SUCCEED_FATAL(clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, ret_val_size, build_log, NULL));

    // The spec technically does not say whether the build log is zero-terminated, so let's be careful.
    build_log[ret_val_size] = '\0';

    fprintf(stderr, "Build log:\n%s\n", build_log);

    free(build_log);
  }

  return build_status;
}

// Fields in a bitmask indicating which types we must be sure are
// available.
enum opencl_required_type { OPENCL_F64 = 1 };

// We take as input several strings representing the program, because
// C does not guarantee that the compiler supports particularly large
// literals.  Notably, Visual C has a limit of 2048 characters.  The
// array must be NULL-terminated.
static cl_program setup_opencl_with_command_queue(struct opencl_context *ctx,
                                                  cl_command_queue queue,
                                                  const char *srcs[],
                                                  int required_types,
                                                  const char *extra_build_opts[]) {
  int error;

  free_list_init(&ctx->free_list);
  ctx->queue = queue;

  OPENCL_SUCCEED_FATAL(clGetCommandQueueInfo(ctx->queue, CL_QUEUE_CONTEXT, sizeof(cl_context), &ctx->ctx, NULL));

  // Fill out the device info.  This is redundant work if we are
  // called from setup_opencl() (which is the common case), but I
  // doubt it matters much.
  struct opencl_device_option device_option;
  OPENCL_SUCCEED_FATAL(clGetCommandQueueInfo(ctx->queue, CL_QUEUE_DEVICE,
                                       sizeof(cl_device_id),
                                       &device_option.device,
                                       NULL));
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_PLATFORM,
                                 sizeof(cl_platform_id),
                                 &device_option.platform,
                                 NULL));
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_TYPE,
                                 sizeof(cl_device_type),
                                 &device_option.device_type,
                                 NULL));
  device_option.platform_name = opencl_platform_info(device_option.platform, CL_PLATFORM_NAME);
  device_option.device_name = opencl_device_info(device_option.device, CL_DEVICE_NAME);

  ctx->device = device_option.device;

  if (required_types & OPENCL_F64) {
    cl_uint supported;
    OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE,
                                   sizeof(cl_uint), &supported, NULL));
    if (!supported) {
      futhark_panic(1, "Program uses double-precision floats, but this is not supported on the chosen device: %s\n",
            device_option.device_name);
    }
  }

  size_t max_group_size;
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_MAX_WORK_GROUP_SIZE,
                                 sizeof(size_t), &max_group_size, NULL));

  size_t max_tile_size = sqrt(max_group_size);

  cl_ulong max_local_memory;
  OPENCL_SUCCEED_FATAL(clGetDeviceInfo(device_option.device, CL_DEVICE_LOCAL_MEM_SIZE,
                                       sizeof(size_t), &max_local_memory, NULL));

  // Futhark reserves 4 bytes for bookkeeping information.
  max_local_memory -= 4;

  // The OpenCL implementation may reserve some local memory bytes for
  // various purposes.  In principle, we should use
  // clGetKernelWorkGroupInfo() to figure out for each kernel how much
  // is actually available, but our current code generator design
  // makes this infeasible.  Instead, we have this nasty hack where we
  // arbitrarily subtract some bytes, based on empirical measurements
  // (but which might be arbitrarily wrong).  Fortunately, we rarely
  // try to really push the local memory usage.
  if (strstr(device_option.platform_name, "NVIDIA CUDA") != NULL) {
    max_local_memory -= 12;
  } else if (strstr(device_option.platform_name, "AMD") != NULL) {
    max_local_memory -= 16;
  }

  // Make sure this function is defined.
  post_opencl_setup(ctx, &device_option);

  if (max_group_size < ctx->cfg.default_group_size) {
    if (ctx->cfg.default_group_size_changed) {
      fprintf(stderr, "Note: Device limits default group size to %zu (down from %zu).\n",
              max_group_size, ctx->cfg.default_group_size);
    }
    ctx->cfg.default_group_size = max_group_size;
  }

  if (max_tile_size < ctx->cfg.default_tile_size) {
    if (ctx->cfg.default_tile_size_changed) {
      fprintf(stderr, "Note: Device limits default tile size to %zu (down from %zu).\n",
              max_tile_size, ctx->cfg.default_tile_size);
    }
    ctx->cfg.default_tile_size = max_tile_size;
  }

  ctx->max_group_size = max_group_size;
  ctx->max_tile_size = max_tile_size; // No limit.
  ctx->max_threshold = ctx->max_num_groups = 0; // No limit.
  ctx->max_local_memory = max_local_memory;

  // Now we go through all the sizes, clamp them to the valid range,
  // or set them to the default.
  for (int i = 0; i < ctx->cfg.num_sizes; i++) {
    const char *size_class = ctx->cfg.size_classes[i];
    int64_t *size_value = &ctx->cfg.size_values[i];
    const char* size_name = ctx->cfg.size_names[i];
    int64_t max_value = 0, default_value = 0;

    if (strstr(size_class, "group_size") == size_class) {
      max_value = max_group_size;
      default_value = ctx->cfg.default_group_size;
    } else if (strstr(size_class, "num_groups") == size_class) {
      max_value = max_group_size; // Futhark assumes this constraint.
      default_value = ctx->cfg.default_num_groups;
      // XXX: as a quick and dirty hack, use twice as many threads for
      // histograms by default.  We really should just be smarter
      // about sizes somehow.
      if (strstr(size_name, ".seghist_") != NULL) {
        default_value *= 2;
      }
    } else if (strstr(size_class, "tile_size") == size_class) {
      max_value = sqrt(max_group_size);
      default_value = ctx->cfg.default_tile_size;
    } else if (strstr(size_class, "reg_tile_size") == size_class) {
      max_value = 0; // No limit.
      default_value = ctx->cfg.default_reg_tile_size;
    } else if (strstr(size_class, "threshold") == size_class) {
      // Threshold can be as large as it takes.
      default_value = ctx->cfg.default_threshold;
    } else {
      // Bespoke sizes have no limit or default.
    }
    if (*size_value == 0) {
      *size_value = default_value;
    } else if (max_value > 0 && *size_value > max_value) {
      fprintf(stderr, "Note: Device limits %s to %d (down from %d)\n",
              size_name, (int)max_value, (int)*size_value);
      *size_value = max_value;
    }
  }

  if (ctx->lockstep_width == 0) {
    ctx->lockstep_width = 1;
  }

  if (ctx->cfg.logging) {
    fprintf(stderr, "Lockstep width: %d\n", (int)ctx->lockstep_width);
    fprintf(stderr, "Default group size: %d\n", (int)ctx->cfg.default_group_size);
    fprintf(stderr, "Default number of groups: %d\n", (int)ctx->cfg.default_num_groups);
  }

  char *fut_opencl_src = NULL;
  cl_program prog;
  error = CL_SUCCESS;

  if (ctx->cfg.load_binary_from == NULL) {
    size_t src_size = 0;

    // Maybe we have to read OpenCL source from somewhere else (used for debugging).
    if (ctx->cfg.load_program_from != NULL) {
      fut_opencl_src = slurp_file(ctx->cfg.load_program_from, NULL);
      assert(fut_opencl_src != NULL);
    } else {
      // Construct the OpenCL source concatenating all the fragments.
      for (const char **src = srcs; src && *src; src++) {
        src_size += strlen(*src);
      }

      fut_opencl_src = (char*) malloc(src_size + 1);

      size_t n, i;
      for (i = 0, n = 0; srcs && srcs[i]; i++) {
        strncpy(fut_opencl_src+n, srcs[i], src_size-n);
        n += strlen(srcs[i]);
      }
      fut_opencl_src[src_size] = 0;
    }

    if (ctx->cfg.dump_program_to != NULL) {
      if (ctx->cfg.debugging) {
        fprintf(stderr, "Dumping OpenCL source to %s...\n", ctx->cfg.dump_program_to);
      }

      dump_file(ctx->cfg.dump_program_to, fut_opencl_src, strlen(fut_opencl_src));
    }

    if (ctx->cfg.debugging) {
      fprintf(stderr, "Creating OpenCL program...\n");
    }

    const char* src_ptr[] = {fut_opencl_src};
    prog = clCreateProgramWithSource(ctx->ctx, 1, src_ptr, &src_size, &error);
    OPENCL_SUCCEED_FATAL(error);
  } else {
    if (ctx->cfg.debugging) {
      fprintf(stderr, "Loading OpenCL binary from %s...\n", ctx->cfg.load_binary_from);
    }
    size_t binary_size;
    unsigned char *fut_opencl_bin =
      (unsigned char*) slurp_file(ctx->cfg.load_binary_from, &binary_size);
    assert(fut_opencl_bin != NULL);
    const unsigned char *binaries[1] = { fut_opencl_bin };
    cl_int status = 0;

    prog = clCreateProgramWithBinary(ctx->ctx, 1, &device_option.device,
                                     &binary_size, binaries,
                                     &status, &error);

    OPENCL_SUCCEED_FATAL(status);
    OPENCL_SUCCEED_FATAL(error);
  }

  int compile_opts_size = 1024;

  for (int i = 0; i < ctx->cfg.num_sizes; i++) {
    compile_opts_size += strlen(ctx->cfg.size_names[i]) + 20;
  }

  for (int i = 0; extra_build_opts[i] != NULL; i++) {
    compile_opts_size += strlen(extra_build_opts[i] + 1);
  }

  char *compile_opts = (char*) malloc(compile_opts_size);

  int w = snprintf(compile_opts, compile_opts_size,
                   "-DLOCKSTEP_WIDTH=%d ",
                   (int)ctx->lockstep_width);

  for (int i = 0; i < ctx->cfg.num_sizes; i++) {
    w += snprintf(compile_opts+w, compile_opts_size-w,
                  "-D%s=%d ",
                  ctx->cfg.size_vars[i],
                  (int)ctx->cfg.size_values[i]);
  }

  for (int i = 0; extra_build_opts[i] != NULL; i++) {
    w += snprintf(compile_opts+w, compile_opts_size-w,
                  "%s ", extra_build_opts[i]);
  }

  // Oclgrind claims to support cl_khr_fp16, but this is not actually
  // the case.
  if (strcmp(device_option.platform_name, "Oclgrind") == 0) {
    w += snprintf(compile_opts+w, compile_opts_size-w, "-DEMULATE_F16 ");
  }

  if (ctx->cfg.debugging) {
    fprintf(stderr, "OpenCL compiler options: %s\n", compile_opts);
    fprintf(stderr, "Building OpenCL program...\n");
  }
  OPENCL_SUCCEED_FATAL(build_opencl_program(prog, device_option.device, compile_opts));

  free(compile_opts);
  free(fut_opencl_src);

  if (ctx->cfg.dump_binary_to != NULL) {
    if (ctx->cfg.debugging) {
      fprintf(stderr, "Dumping OpenCL binary to %s...\n", ctx->cfg.dump_binary_to);
    }

    size_t binary_size;
    OPENCL_SUCCEED_FATAL(clGetProgramInfo(prog, CL_PROGRAM_BINARY_SIZES,
                                          sizeof(size_t), &binary_size, NULL));
    unsigned char *binary = (unsigned char*) malloc(binary_size);
    unsigned char *binaries[1] = { binary };
    OPENCL_SUCCEED_FATAL(clGetProgramInfo(prog, CL_PROGRAM_BINARIES,
                                          sizeof(unsigned char*), binaries, NULL));

    dump_file(ctx->cfg.dump_binary_to, binary, binary_size);
  }

  return prog;
}

static cl_program setup_opencl(struct opencl_context *ctx,
                               const char *srcs[],
                               int required_types,
                               const char *extra_build_opts[]) {

  ctx->lockstep_width = 0; // Real value set later.

  struct opencl_device_option device_option = get_preferred_device(&ctx->cfg);

  if (ctx->cfg.logging) {
    describe_device_option(device_option);
  }

  // Note that NVIDIA's OpenCL requires the platform property
  cl_context_properties properties[] = {
    CL_CONTEXT_PLATFORM,
    (cl_context_properties)device_option.platform,
    0
  };

  cl_int clCreateContext_error;
  ctx->ctx = clCreateContext(properties, 1, &device_option.device, NULL, NULL, &clCreateContext_error);
  OPENCL_SUCCEED_FATAL(clCreateContext_error);

  cl_int clCreateCommandQueue_error;
  cl_command_queue queue =
    clCreateCommandQueue(ctx->ctx,
                         device_option.device,
                         ctx->cfg.profiling ? CL_QUEUE_PROFILING_ENABLE : 0,
                         &clCreateCommandQueue_error);
  OPENCL_SUCCEED_FATAL(clCreateCommandQueue_error);

  return setup_opencl_with_command_queue(ctx, queue, srcs, required_types, extra_build_opts);
}

// Count up the runtime all the profiling_records that occured during execution.
// Also clears the buffer of profiling_records.
static cl_int opencl_tally_profiling_records(struct opencl_context *ctx) {
  cl_int err;
  for (int i = 0; i < ctx->profiling_records_used; i++) {
    struct profiling_record record = ctx->profiling_records[i];

    cl_ulong start_t, end_t;

    if ((err = clGetEventProfilingInfo(*record.event,
                                       CL_PROFILING_COMMAND_START,
                                       sizeof(start_t),
                                       &start_t,
                                       NULL)) != CL_SUCCESS) {
      return err;
    }

    if ((err = clGetEventProfilingInfo(*record.event,
                                       CL_PROFILING_COMMAND_END,
                                       sizeof(end_t),
                                       &end_t,
                                       NULL)) != CL_SUCCESS) {
      return err;
    }

    // OpenCL provides nanosecond resolution, but we want
    // microseconds.
    *record.runs += 1;
    *record.runtime += (end_t - start_t)/1000;

    if ((err = clReleaseEvent(*record.event)) != CL_SUCCESS) {
      return err;
    }
    free(record.event);
  }

  ctx->profiling_records_used = 0;

  return CL_SUCCESS;
}

// If profiling, produce an event associated with a profiling record.
static cl_event* opencl_get_event(struct opencl_context *ctx, int *runs, int64_t *runtime) {
    if (ctx->profiling_records_used == ctx->profiling_records_capacity) {
      ctx->profiling_records_capacity *= 2;
      ctx->profiling_records =
        realloc(ctx->profiling_records,
                ctx->profiling_records_capacity *
                sizeof(struct profiling_record));
    }
    cl_event *event = malloc(sizeof(cl_event));
    ctx->profiling_records[ctx->profiling_records_used].event = event;
    ctx->profiling_records[ctx->profiling_records_used].runs = runs;
    ctx->profiling_records[ctx->profiling_records_used].runtime = runtime;
    ctx->profiling_records_used++;
    return event;
}

// Allocate memory from driver. The problem is that OpenCL may perform
// lazy allocation, so we cannot know whether an allocation succeeded
// until the first time we try to use it.  Hence we immediately
// perform a write to see if the allocation succeeded.  This is slow,
// but the assumption is that this operation will be rare (most things
// will go through the free list).
static int opencl_alloc_actual(struct opencl_context *ctx, size_t size, cl_mem *mem_out) {
  int error;
  *mem_out = clCreateBuffer(ctx->ctx, CL_MEM_READ_WRITE, size, NULL, &error);

  if (error != CL_SUCCESS) {
    return error;
  }

  int x = 2;
  error = clEnqueueWriteBuffer(ctx->queue, *mem_out, 1, 0, sizeof(x), &x, 0, NULL, NULL);

  // No need to wait for completion here. clWaitForEvents() cannot
  // return mem object allocation failures. This implies that the
  // buffer is faulted onto the device on enqueue. (Observation by
  // Andreas Kloeckner.)

  return error;
}

static int opencl_alloc(struct opencl_context *ctx, size_t min_size, const char *tag, cl_mem *mem_out) {
  (void)tag;
  if (min_size < sizeof(int)) {
    min_size = sizeof(int);
  }

  size_t size;

  if (free_list_find(&ctx->free_list, min_size, &size, mem_out) == 0) {
    // Successfully found a free block.  Is it big enough?
    //
    // FIXME: we might also want to check whether the block is *too
    // big*, to avoid internal fragmentation.  However, this can
    // sharply impact performance on programs where arrays change size
    // frequently.  Fortunately, such allocations are usually fairly
    // short-lived, as they are necessarily within a loop, so the risk
    // of internal fragmentation resulting in an OOM situation is
    // limited.  However, it would be preferable if we could go back
    // and *shrink* oversize allocations when we encounter an OOM
    // condition.  That is technically feasible, since we do not
    // expose OpenCL pointer values directly to the application, but
    // instead rely on a level of indirection.
    if (size >= min_size) {
      if (ctx->cfg.debugging) {
        fprintf(stderr, "No need to allocate: Found a block in the free list.\n");
      }

      return CL_SUCCESS;
    } else {
      if (ctx->cfg.debugging) {
        fprintf(stderr, "Found a free block, but it was too small.\n");
      }

      // Not just right - free it.
      int error = clReleaseMemObject(*mem_out);
      if (error != CL_SUCCESS) {
        return error;
      }
    }
  }

  // We have to allocate a new block from the driver.  If the
  // allocation does not succeed, then we might be in an out-of-memory
  // situation.  We now start freeing things from the free list until
  // we think we have freed enough that the allocation will succeed.
  // Since we don't know how far the allocation is from fitting, we
  // have to check after every deallocation.  This might be pretty
  // expensive.  Let's hope that this case is hit rarely.

  if (ctx->cfg.debugging) {
    fprintf(stderr, "Actually allocating the desired block.\n");
  }

  int error = opencl_alloc_actual(ctx, min_size, mem_out);

  while (error == CL_MEM_OBJECT_ALLOCATION_FAILURE) {
    if (ctx->cfg.debugging) {
      fprintf(stderr, "Out of OpenCL memory: releasing entry from the free list...\n");
    }
    cl_mem mem;
    if (free_list_first(&ctx->free_list, &mem) == 0) {
      error = clReleaseMemObject(mem);
      if (error != CL_SUCCESS) {
        return error;
      }
    } else {
      break;
    }
    error = opencl_alloc_actual(ctx, min_size, mem_out);
  }

  return error;
}

static int opencl_free(struct opencl_context *ctx, cl_mem mem, const char *tag) {
  size_t size;
  cl_mem existing_mem;

  // If there is already a block with this tag, then remove it.
  if (free_list_find(&ctx->free_list, -1, &size, &existing_mem) == 0) {
    int error = clReleaseMemObject(existing_mem);
    if (error != CL_SUCCESS) {
      return error;
    }
  }

  int error = clGetMemObjectInfo(mem, CL_MEM_SIZE, sizeof(size_t), &size, NULL);

  if (error == CL_SUCCESS) {
    free_list_insert(&ctx->free_list, size, mem, tag);
  }

  return error;
}

static int opencl_free_all(struct opencl_context *ctx) {
  cl_mem mem;
  free_list_pack(&ctx->free_list);
  while (free_list_first(&ctx->free_list, &mem) == 0) {
    int error = clReleaseMemObject(mem);
    if (error != CL_SUCCESS) {
      return error;
    }
  }

  return CL_SUCCESS;
}

// Free everything that belongs to 'ctx', but do not free 'ctx'
// itself.
static void teardown_opencl(struct opencl_context *ctx) {
  (void)opencl_tally_profiling_records(ctx);
  free(ctx->profiling_records);
  (void)opencl_free_all(ctx);
  (void)clReleaseCommandQueue(ctx->queue);
  (void)clReleaseContext(ctx->ctx);
}

// End of opencl.h.

static const char *opencl_program[] =
                  {"\n// Clang-based OpenCL implementations need this for 'static' to work.\n#ifdef cl_clang_storage_class_specifiers\n#pragma OPENCL EXTENSION cl_clang_storage_class_specifiers : enable\n#endif\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n#define FUTHARK_F64_ENABLED\n\n// Some OpenCL programs dislike empty progams, or programs with no kernels.\n// Declare a dummy kernel to ensure they remain our friends.\n__kernel void dummy_kernel(__global unsigned char *dummy, int n)\n{\n    const int thread_gid = get_global_id(0);\n    if (thread_gid >= n) return;\n}\n\n#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n\ntypedef char int8_t;\ntypedef short int16_t;\ntypedef int int32_t;\ntypedef long int64_t;\n\ntypedef uchar uint8_t;\ntypedef ushort uint16_t;\ntypedef uint uint32_t;\ntypedef ulong uint64_t;\n\n// NVIDIAs OpenCL does not create device-wide memory fences (see #734), so we\n// use inline assembly if we detect we are on an NVIDIA GPU.\n#ifdef cl_nv_pragma_unroll\nstatic inline void mem_fence_global() {\n  asm(\"membar.gl;\");\n}\n#else\nstatic inline void mem_fence_global() {\n  mem_fence(CLK_LOCAL_MEM_FENCE | CLK_GLOBAL_MEM_FENCE);\n}\n#endif\nstatic inline void mem_fence_local() {\n  mem_fence(CLK_LOCAL_MEM_FENCE);\n}\n// Start of half.h.\n\n// Conversion functions are from http://half.sourceforge.net/, but\n// translated to C.\n//\n// Copyright (c) 2012-2021 Christian Rau\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission noti",
                   "ce shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#ifndef __OPENCL_VERSION__\n#define __constant\n#endif\n\n__constant static const uint16_t base_table[512] = {\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,\n  0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,\n  0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x",
                   "7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,\n  0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,\n  0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,\n  0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC",
                   "00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,\n  0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };\n\n__constant static const unsigned char shift_table[512] = {\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, ",
                   "24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };\n\n__constant static const uint32_t mantissa_table[2048] = {\n  0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,\n  0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,\n  0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,\n  0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,\n  0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0",
                   "000,\n  0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,\n  0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,\n  0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,\n  0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,\n  0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,\n  0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,\n  0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,\n  0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,\n  0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,\n  0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,\n  0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x377",
                   "40000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,\n  0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,\n  0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,\n  0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,\n  0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,\n  0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,\n  0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,\n  0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,\n  0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,\n  0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,\n  0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37C",
                   "C8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,\n  0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,\n  0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,\n  0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,\n  0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,\n  0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,\n  0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,\n  0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,\n  0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,\n  0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,\n  0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380",
                   "F8000, 0x380FC000,\n  0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,\n  0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,\n  0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,\n  0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,\n  0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,\n  0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,\n  0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,\n  0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,\n  0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,\n  0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,\n  0x38380000, 0x38384000, 0x38388000, 0x3",
                   "838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,\n  0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,\n  0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,\n  0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,\n  0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,\n  0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,\n  0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,\n  0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,\n  0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,\n  0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,\n  0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x3",
                   "8620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,\n  0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,\n  0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,\n  0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,\n  0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,\n  0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,\n  0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,\n  0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,\n  0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,\n  0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,\n  0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3",
                   "805A000, 0x3805C000, 0x3805E000,\n  0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,\n  0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,\n  0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,\n  0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,\n  0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,\n  0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,\n  0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,\n  0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,\n  0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,\n  0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,\n  0x381A0000, 0x381A2000, 0",
                   "x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,\n  0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,\n  0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,\n  0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,\n  0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,\n  0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,\n  0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,\n  0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,\n  0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,\n  0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,\n  0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0",
                   "x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,\n  0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,\n  0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,\n  0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,\n  0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,\n  0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,\n  0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,\n  0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,\n  0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,\n  0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,\n  0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0",
                   "x38438000, 0x3843A000, 0x3843C000, 0x3843E000,\n  0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,\n  0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,\n  0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,\n  0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,\n  0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,\n  0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,\n  0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,\n  0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,\n  0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,\n  0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,\n  0x38580000,",
                   " 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,\n  0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,\n  0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,\n  0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,\n  0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,\n  0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,\n  0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,\n  0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,\n  0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,\n  0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,\n  0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000,",
                   " 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,\n  0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,\n  0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,\n  0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,\n  0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,\n  0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,\n  0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,\n  0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,\n  0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,\n  0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };\n__constant static const uint32_t exponent_table[64] = {\n  0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0",
                   "x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,\n  0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,\n  0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,\n  0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };\n__constant static const unsigned short offset_table[64] = {\n  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,\n  0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };\n\nstatic uint16_t float2halfbits(float value) {\n  union { float x; uint32_t y; } u;\n  u.x = value;\n  uint32_t bits = u.y;\n\n  uint16_t hbits = base_table[bits>>23] + (uint16_t)((bits&0x7FFFFF)>>shift_table[bits>>23]);;\n\n  return hbits;\n}\n\nstatic float halfbits2float(uint16_t value) {\n  uint32_t bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];\n\n  union { uint32_t x; float y; } u;\n  u.x = bits;\n  return u.y;\n}\n\n// End of half.h.\n// Start of scalar.h.\n\n// Implementation of the primitive scalar operations.  Very\n// repetitive.  This code is inserted directly into both CUDA and\n// OpenCL programs, as well as the CPU code, so it has some #ifdefs to\n// work everywhere.  Some operations are defined as macros because\n// this allows us to use them as constant expressions in things like\n// array sizes and static i",
                   "nitialisers.\n\n// Some of the #ifdefs are because OpenCL uses type-generic functions\n// for some operations (e.g. sqrt), while C and CUDA sensibly use\n// distinct functions for different precisions (e.g. sqrtf() and\n// sqrt()).  This is quite annoying.  Due to C's unfortunate casting\n// rules, it is also really easy to accidentally implement\n// floating-point functions in the wrong precision, so be careful.\n\n// Double-precision definitions are only included if the preprocessor\n// macro FUTHARK_F64_ENABLED is set.\n\nstatic inline uint8_t add8(uint8_t x, uint8_t y) {\n  return x + y;\n}\n\nstatic inline uint16_t add16(uint16_t x, uint16_t y) {\n  return x + y;\n}\n\nstatic inline uint32_t add32(uint32_t x, uint32_t y) {\n  return x + y;\n}\n\nstatic inline uint64_t add64(uint64_t x, uint64_t y) {\n  return x + y;\n}\n\nstatic inline uint8_t sub8(uint8_t x, uint8_t y) {\n  return x - y;\n}\n\nstatic inline uint16_t sub16(uint16_t x, uint16_t y) {\n  return x - y;\n}\n\nstatic inline uint32_t sub32(uint32_t x, uint32_t y) {\n  return x - y;\n}\n\nstatic inline uint64_t sub64(uint64_t x, uint64_t y) {\n  return x - y;\n}\n\nstatic inline uint8_t mul8(uint8_t x, uint8_t y) {\n  return x * y;\n}\n\nstatic inline uint16_t mul16(uint16_t x, uint16_t y) {\n  return x * y;\n}\n\nstatic inline uint32_t mul32(uint32_t x, uint32_t y) {\n  return x * y;\n}\n\nstatic inline uint64_t mul64(uint64_t x, uint64_t y) {\n  return x * y;\n}\n\nstatic inline uint8_t udiv8(uint8_t x, uint8_t y) {\n  return x / y;\n}\n\nstatic inline uint16_t udiv16(uint16_t x, uint16_t y) {\n  return x / y;\n}\n\nstatic inline uint32_t udiv32(uint32_t x, uint32_t y) {\n  return x / y;\n}\n\nstatic inline uint64_t udiv64(uint64_t x, uint64_t y) {\n  return x / y;\n}\n\nstatic inline uint8_t udiv_up8(uint8_t x, uint8_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint16_t udiv_up16(uint16_t x, uint16_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint32_t udiv_up32(uint32_t x, uint32_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint64_t udiv_up64(uint64_t x, uint",
                   "64_t y) {\n  return (x + y - 1) / y;\n}\n\nstatic inline uint8_t umod8(uint8_t x, uint8_t y) {\n  return x % y;\n}\n\nstatic inline uint16_t umod16(uint16_t x, uint16_t y) {\n  return x % y;\n}\n\nstatic inline uint32_t umod32(uint32_t x, uint32_t y) {\n  return x % y;\n}\n\nstatic inline uint64_t umod64(uint64_t x, uint64_t y) {\n  return x % y;\n}\n\nstatic inline uint8_t udiv_safe8(uint8_t x, uint8_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint16_t udiv_safe16(uint16_t x, uint16_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint32_t udiv_safe32(uint32_t x, uint32_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint64_t udiv_safe64(uint64_t x, uint64_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline uint8_t udiv_up_safe8(uint8_t x, uint8_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint16_t udiv_up_safe16(uint16_t x, uint16_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint32_t udiv_up_safe32(uint32_t x, uint32_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint64_t udiv_up_safe64(uint64_t x, uint64_t y) {\n  return y == 0 ? 0 : (x + y - 1) / y;\n}\n\nstatic inline uint8_t umod_safe8(uint8_t x, uint8_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline uint16_t umod_safe16(uint16_t x, uint16_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline uint32_t umod_safe32(uint32_t x, uint32_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline uint64_t umod_safe64(uint64_t x, uint64_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int8_t sdiv8(int8_t x, int8_t y) {\n  int8_t q = x / y;\n  int8_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int16_t sdiv16(int16_t x, int16_t y) {\n  int16_t q = x / y;\n  int16_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int32_t sdiv32(int32_t x, int32_t y) {\n  int32_t q = x / y;\n  int32_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int64_t sdiv64(int64_t x, int64_t y) {\n  int64_t q ",
                   "= x / y;\n  int64_t r = x % y;\n\n  return q - ((r != 0 && r < 0 != y < 0) ? 1 : 0);\n}\n\nstatic inline int8_t sdiv_up8(int8_t x, int8_t y) {\n  return sdiv8(x + y - 1, y);\n}\n\nstatic inline int16_t sdiv_up16(int16_t x, int16_t y) {\n  return sdiv16(x + y - 1, y);\n}\n\nstatic inline int32_t sdiv_up32(int32_t x, int32_t y) {\n  return sdiv32(x + y - 1, y);\n}\n\nstatic inline int64_t sdiv_up64(int64_t x, int64_t y) {\n  return sdiv64(x + y - 1, y);\n}\n\nstatic inline int8_t smod8(int8_t x, int8_t y) {\n  int8_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int16_t smod16(int16_t x, int16_t y) {\n  int16_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int32_t smod32(int32_t x, int32_t y) {\n  int32_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int64_t smod64(int64_t x, int64_t y) {\n  int64_t r = x % y;\n\n  return r + (r == 0 || (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 : y);\n}\n\nstatic inline int8_t sdiv_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : sdiv8(x, y);\n}\n\nstatic inline int16_t sdiv_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : sdiv16(x, y);\n}\n\nstatic inline int32_t sdiv_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : sdiv32(x, y);\n}\n\nstatic inline int64_t sdiv_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : sdiv64(x, y);\n}\n\nstatic inline int8_t sdiv_up_safe8(int8_t x, int8_t y) {\n  return sdiv_safe8(x + y - 1, y);\n}\n\nstatic inline int16_t sdiv_up_safe16(int16_t x, int16_t y) {\n  return sdiv_safe16(x + y - 1, y);\n}\n\nstatic inline int32_t sdiv_up_safe32(int32_t x, int32_t y) {\n  return sdiv_safe32(x + y - 1, y);\n}\n\nstatic inline int64_t sdiv_up_safe64(int64_t x, int64_t y) {\n  return sdiv_safe64(x + y - 1, y);\n}\n\nstatic inline int8_t smod_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : smod8(x, y);\n}\n\nstatic inline int16_t smod_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : smod16(x, y);\n}\n\nst",
                   "atic inline int32_t smod_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : smod32(x, y);\n}\n\nstatic inline int64_t smod_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : smod64(x, y);\n}\n\nstatic inline int8_t squot8(int8_t x, int8_t y) {\n  return x / y;\n}\n\nstatic inline int16_t squot16(int16_t x, int16_t y) {\n  return x / y;\n}\n\nstatic inline int32_t squot32(int32_t x, int32_t y) {\n  return x / y;\n}\n\nstatic inline int64_t squot64(int64_t x, int64_t y) {\n  return x / y;\n}\n\nstatic inline int8_t srem8(int8_t x, int8_t y) {\n  return x % y;\n}\n\nstatic inline int16_t srem16(int16_t x, int16_t y) {\n  return x % y;\n}\n\nstatic inline int32_t srem32(int32_t x, int32_t y) {\n  return x % y;\n}\n\nstatic inline int64_t srem64(int64_t x, int64_t y) {\n  return x % y;\n}\n\nstatic inline int8_t squot_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int16_t squot_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int32_t squot_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int64_t squot_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : x / y;\n}\n\nstatic inline int8_t srem_safe8(int8_t x, int8_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int16_t srem_safe16(int16_t x, int16_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int32_t srem_safe32(int32_t x, int32_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int64_t srem_safe64(int64_t x, int64_t y) {\n  return y == 0 ? 0 : x % y;\n}\n\nstatic inline int8_t smin8(int8_t x, int8_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int16_t smin16(int16_t x, int16_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int32_t smin32(int32_t x, int32_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int64_t smin64(int64_t x, int64_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint8_t umin8(uint8_t x, uint8_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint16_t umin16(uint16_t x, uint16_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint32_t umin32(uint32_t x, ",
                   "uint32_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline uint64_t umin64(uint64_t x, uint64_t y) {\n  return x < y ? x : y;\n}\n\nstatic inline int8_t smax8(int8_t x, int8_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline int16_t smax16(int16_t x, int16_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline int32_t smax32(int32_t x, int32_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline int64_t smax64(int64_t x, int64_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint8_t umax8(uint8_t x, uint8_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint16_t umax16(uint16_t x, uint16_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint32_t umax32(uint32_t x, uint32_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint64_t umax64(uint64_t x, uint64_t y) {\n  return x < y ? y : x;\n}\n\nstatic inline uint8_t shl8(uint8_t x, uint8_t y) {\n  return (uint8_t)(x << y);\n}\n\nstatic inline uint16_t shl16(uint16_t x, uint16_t y) {\n  return (uint16_t)(x << y);\n}\n\nstatic inline uint32_t shl32(uint32_t x, uint32_t y) {\n  return x << y;\n}\n\nstatic inline uint64_t shl64(uint64_t x, uint64_t y) {\n  return x << y;\n}\n\nstatic inline uint8_t lshr8(uint8_t x, uint8_t y) {\n  return x >> y;\n}\n\nstatic inline uint16_t lshr16(uint16_t x, uint16_t y) {\n  return x >> y;\n}\n\nstatic inline uint32_t lshr32(uint32_t x, uint32_t y) {\n  return x >> y;\n}\n\nstatic inline uint64_t lshr64(uint64_t x, uint64_t y) {\n  return x >> y;\n}\n\nstatic inline int8_t ashr8(int8_t x, int8_t y) {\n  return x >> y;\n}\n\nstatic inline int16_t ashr16(int16_t x, int16_t y) {\n  return x >> y;\n}\n\nstatic inline int32_t ashr32(int32_t x, int32_t y) {\n  return x >> y;\n}\n\nstatic inline int64_t ashr64(int64_t x, int64_t y) {\n  return x >> y;\n}\n\nstatic inline uint8_t and8(uint8_t x, uint8_t y) {\n  return x & y;\n}\n\nstatic inline uint16_t and16(uint16_t x, uint16_t y) {\n  return x & y;\n}\n\nstatic inline uint32_t and32(uint32_t x, uint32_t y) {\n  return x & y;\n}\n\nstatic inline uint64_t and64(uint64_t x, uint64_t y) {\n  return x & y;\n}\n\nstatic inline uint8_t or8(uint8_t",
                   " x, uint8_t y) {\n  return x | y;\n}\n\nstatic inline uint16_t or16(uint16_t x, uint16_t y) {\n  return x | y;\n}\n\nstatic inline uint32_t or32(uint32_t x, uint32_t y) {\n  return x | y;\n}\n\nstatic inline uint64_t or64(uint64_t x, uint64_t y) {\n  return x | y;\n}\n\nstatic inline uint8_t xor8(uint8_t x, uint8_t y) {\n  return x ^ y;\n}\n\nstatic inline uint16_t xor16(uint16_t x, uint16_t y) {\n  return x ^ y;\n}\n\nstatic inline uint32_t xor32(uint32_t x, uint32_t y) {\n  return x ^ y;\n}\n\nstatic inline uint64_t xor64(uint64_t x, uint64_t y) {\n  return x ^ y;\n}\n\nstatic inline bool ult8(uint8_t x, uint8_t y) {\n  return x < y;\n}\n\nstatic inline bool ult16(uint16_t x, uint16_t y) {\n  return x < y;\n}\n\nstatic inline bool ult32(uint32_t x, uint32_t y) {\n  return x < y;\n}\n\nstatic inline bool ult64(uint64_t x, uint64_t y) {\n  return x < y;\n}\n\nstatic inline bool ule8(uint8_t x, uint8_t y) {\n  return x <= y;\n}\n\nstatic inline bool ule16(uint16_t x, uint16_t y) {\n  return x <= y;\n}\n\nstatic inline bool ule32(uint32_t x, uint32_t y) {\n  return x <= y;\n}\n\nstatic inline bool ule64(uint64_t x, uint64_t y) {\n  return x <= y;\n}\n\nstatic inline bool slt8(int8_t x, int8_t y) {\n  return x < y;\n}\n\nstatic inline bool slt16(int16_t x, int16_t y) {\n  return x < y;\n}\n\nstatic inline bool slt32(int32_t x, int32_t y) {\n  return x < y;\n}\n\nstatic inline bool slt64(int64_t x, int64_t y) {\n  return x < y;\n}\n\nstatic inline bool sle8(int8_t x, int8_t y) {\n  return x <= y;\n}\n\nstatic inline bool sle16(int16_t x, int16_t y) {\n  return x <= y;\n}\n\nstatic inline bool sle32(int32_t x, int32_t y) {\n  return x <= y;\n}\n\nstatic inline bool sle64(int64_t x, int64_t y) {\n  return x <= y;\n}\n\nstatic inline uint8_t pow8(uint8_t x, uint8_t y) {\n  uint8_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n  return res;\n}\n\nstatic inline uint16_t pow16(uint16_t x, uint16_t y) {\n  uint16_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n ",
                   " return res;\n}\n\nstatic inline uint32_t pow32(uint32_t x, uint32_t y) {\n  uint32_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n  return res;\n}\n\nstatic inline uint64_t pow64(uint64_t x, uint64_t y) {\n  uint64_t res = 1, rem = y;\n\n  while (rem != 0) {\n    if (rem & 1)\n      res *= x;\n    rem >>= 1;\n    x *= x;\n  }\n  return res;\n}\n\nstatic inline bool itob_i8_bool(int8_t x) {\n  return x;\n}\n\nstatic inline bool itob_i16_bool(int16_t x) {\n  return x;\n}\n\nstatic inline bool itob_i32_bool(int32_t x) {\n  return x;\n}\n\nstatic inline bool itob_i64_bool(int64_t x) {\n  return x;\n}\n\nstatic inline int8_t btoi_bool_i8(bool x) {\n  return x;\n}\n\nstatic inline int16_t btoi_bool_i16(bool x) {\n  return x;\n}\n\nstatic inline int32_t btoi_bool_i32(bool x) {\n  return x;\n}\n\nstatic inline int64_t btoi_bool_i64(bool x) {\n  return x;\n}\n\n#define sext_i8_i8(x) ((int8_t) (int8_t) (x))\n#define sext_i8_i16(x) ((int16_t) (int8_t) (x))\n#define sext_i8_i32(x) ((int32_t) (int8_t) (x))\n#define sext_i8_i64(x) ((int64_t) (int8_t) (x))\n#define sext_i16_i8(x) ((int8_t) (int16_t) (x))\n#define sext_i16_i16(x) ((int16_t) (int16_t) (x))\n#define sext_i16_i32(x) ((int32_t) (int16_t) (x))\n#define sext_i16_i64(x) ((int64_t) (int16_t) (x))\n#define sext_i32_i8(x) ((int8_t) (int32_t) (x))\n#define sext_i32_i16(x) ((int16_t) (int32_t) (x))\n#define sext_i32_i32(x) ((int32_t) (int32_t) (x))\n#define sext_i32_i64(x) ((int64_t) (int32_t) (x))\n#define sext_i64_i8(x) ((int8_t) (int64_t) (x))\n#define sext_i64_i16(x) ((int16_t) (int64_t) (x))\n#define sext_i64_i32(x) ((int32_t) (int64_t) (x))\n#define sext_i64_i64(x) ((int64_t) (int64_t) (x))\n#define zext_i8_i8(x) ((int8_t) (uint8_t) (x))\n#define zext_i8_i16(x) ((int16_t) (uint8_t) (x))\n#define zext_i8_i32(x) ((int32_t) (uint8_t) (x))\n#define zext_i8_i64(x) ((int64_t) (uint8_t) (x))\n#define zext_i16_i8(x) ((int8_t) (uint16_t) (x))\n#define zext_i16_i16(x) ((int16_t) (uint16_t) (x))\n#define zext_i16_i32(x) ((int32_t) (uint16_t) (x",
                   "))\n#define zext_i16_i64(x) ((int64_t) (uint16_t) (x))\n#define zext_i32_i8(x) ((int8_t) (uint32_t) (x))\n#define zext_i32_i16(x) ((int16_t) (uint32_t) (x))\n#define zext_i32_i32(x) ((int32_t) (uint32_t) (x))\n#define zext_i32_i64(x) ((int64_t) (uint32_t) (x))\n#define zext_i64_i8(x) ((int8_t) (uint64_t) (x))\n#define zext_i64_i16(x) ((int16_t) (uint64_t) (x))\n#define zext_i64_i32(x) ((int32_t) (uint64_t) (x))\n#define zext_i64_i64(x) ((int64_t) (uint64_t) (x))\n\nstatic int8_t abs8(int8_t x) {\n  return (int8_t)abs(x);\n}\n\nstatic int16_t abs16(int16_t x) {\n  return (int16_t)abs(x);\n}\n\nstatic int32_t abs32(int32_t x) {\n  return abs(x);\n}\n\nstatic int64_t abs64(int64_t x) {\n#if defined(__OPENCL_VERSION__)\n  return abs(x);\n#else\n  return llabs(x);\n#endif\n}\n\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_popc8(int8_t x) {\n  return popcount(x);\n}\n\nstatic int32_t futrts_popc16(int16_t x) {\n  return popcount(x);\n}\n\nstatic int32_t futrts_popc32(int32_t x) {\n  return popcount(x);\n}\n\nstatic int32_t futrts_popc64(int64_t x) {\n  return popcount(x);\n}\n#elif defined(__CUDA_ARCH__)\n\nstatic int32_t futrts_popc8(int8_t x) {\n  return __popc(zext_i8_i32(x));\n}\n\nstatic int32_t futrts_popc16(int16_t x) {\n  return __popc(zext_i16_i32(x));\n}\n\nstatic int32_t futrts_popc32(int32_t x) {\n  return __popc(x);\n}\n\nstatic int32_t futrts_popc64(int64_t x) {\n  return __popcll(x);\n}\n\n#else // Not OpenCL or CUDA, but plain C.\n\nstatic int32_t futrts_popc8(uint8_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n\nstatic int32_t futrts_popc16(uint16_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n\nstatic int32_t futrts_popc32(uint32_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n\nstatic int32_t futrts_popc64(uint64_t x) {\n  int c = 0;\n  for (; x; ++c) { x &= x - 1; }\n  return c;\n}\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {\n  return mul_hi(a, b);\n}\n\nstatic uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {",
                   "\n  return mul_hi(a, b);\n}\n\nstatic uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {\n  return mul_hi(a, b);\n}\n\nstatic uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {\n  return mul_hi(a, b);\n}\n\n#elif defined(__CUDA_ARCH__)\n\nstatic uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {\n  uint16_t aa = a;\n  uint16_t bb = b;\n\n  return aa * bb >> 8;\n}\n\nstatic uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {\n  uint32_t aa = a;\n  uint32_t bb = b;\n\n  return aa * bb >> 16;\n}\n\nstatic uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {\n  return mulhi(a, b);\n}\n\nstatic uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {\n  return mul64hi(a, b);\n}\n\n#else // Not OpenCL or CUDA, but plain C.\n\nstatic uint8_t futrts_mul_hi8(uint8_t a, uint8_t b) {\n  uint16_t aa = a;\n  uint16_t bb = b;\n\n  return aa * bb >> 8;\n}\n\nstatic uint16_t futrts_mul_hi16(uint16_t a, uint16_t b) {\n  uint32_t aa = a;\n  uint32_t bb = b;\n\n  return aa * bb >> 16;\n}\n\nstatic uint32_t futrts_mul_hi32(uint32_t a, uint32_t b) {\n  uint64_t aa = a;\n  uint64_t bb = b;\n\n  return aa * bb >> 32;\n}\n\nstatic uint64_t futrts_mul_hi64(uint64_t a, uint64_t b) {\n  __uint128_t aa = a;\n  __uint128_t bb = b;\n\n  return aa * bb >> 64;\n}\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {\n  return mad_hi(a, b, c);\n}\n\nstatic uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {\n  return mad_hi(a, b, c);\n}\n\nstatic uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {\n  return mad_hi(a, b, c);\n}\n\nstatic uint64_t futrts_mad_hi64(uint64_t a, uint64_t b, uint64_t c) {\n  return mad_hi(a, b, c);\n}\n\n#else // Not OpenCL\n\nstatic uint8_t futrts_mad_hi8(uint8_t a, uint8_t b, uint8_t c) {\n  return futrts_mul_hi8(a, b) + c;\n}\n\nstatic uint16_t futrts_mad_hi16(uint16_t a, uint16_t b, uint16_t c) {\n  return futrts_mul_hi16(a, b) + c;\n}\n\nstatic uint32_t futrts_mad_hi32(uint32_t a, uint32_t b, uint32_t c) {\n  return futrts_mul_hi32(a, b) + c;\n}\n\nstatic uint64_t futrts_mad_hi64(uint64_t a, uint64_t",
                   " b, uint64_t c) {\n  return futrts_mul_hi64(a, b) + c;\n}\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_clzz8(int8_t x) {\n  return clz(x);\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return clz(x);\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return clz(x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return clz(x);\n}\n\n#elif defined(__CUDA_ARCH__)\n\nstatic int32_t futrts_clzz8(int8_t x) {\n  return __clz(zext_i8_i32(x)) - 24;\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return __clz(zext_i16_i32(x)) - 16;\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return __clz(x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return __clzll(x);\n}\n\n#else // Not OpenCL or CUDA, but plain C.\n\nstatic int32_t futrts_clzz8(int8_t x) {\n  return x == 0 ? 8 : __builtin_clz((uint32_t)zext_i8_i32(x)) - 24;\n}\n\nstatic int32_t futrts_clzz16(int16_t x) {\n  return x == 0 ? 16 : __builtin_clz((uint32_t)zext_i16_i32(x)) - 16;\n}\n\nstatic int32_t futrts_clzz32(int32_t x) {\n  return x == 0 ? 32 : __builtin_clz((uint32_t)x);\n}\n\nstatic int32_t futrts_clzz64(int64_t x) {\n  return x == 0 ? 64 : __builtin_clzll((uint64_t)x);\n}\n#endif\n\n#if defined(__OPENCL_VERSION__)\nstatic int32_t futrts_ctzz8(int8_t x) {\n  int i = 0;\n  for (; i < 8 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  int i = 0;\n  for (; i < 16 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  int i = 0;\n  for (; i < 32 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\nstatic int32_t futrts_ctzz64(int64_t x) {\n  int i = 0;\n  for (; i < 64 && (x & 1) == 0; i++, x >>= 1)\n    ;\n  return i;\n}\n\n#elif defined(__CUDA_ARCH__)\n\nstatic int32_t futrts_ctzz8(int8_t x) {\n  int y = __ffs(x);\n  return y == 0 ? 8 : y - 1;\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  int y = __ffs(x);\n  return y == 0 ? 16 : y - 1;\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  int y = __ffs(x);\n  return y == 0 ? 32 : y - 1;\n}\n\nstatic int32_t futrts_ctzz64(int",
                   "64_t x) {\n  int y = __ffsll(x);\n  return y == 0 ? 64 : y - 1;\n}\n\n#else // Not OpenCL or CUDA, but plain C.\n\nstatic int32_t futrts_ctzz8(int8_t x) {\n  return x == 0 ? 8 : __builtin_ctz((uint32_t)x);\n}\n\nstatic int32_t futrts_ctzz16(int16_t x) {\n  return x == 0 ? 16 : __builtin_ctz((uint32_t)x);\n}\n\nstatic int32_t futrts_ctzz32(int32_t x) {\n  return x == 0 ? 32 : __builtin_ctz((uint32_t)x);\n}\n\nstatic int32_t futrts_ctzz64(int64_t x) {\n  return x == 0 ? 64 : __builtin_ctzll((uint64_t)x);\n}\n#endif\n\nstatic inline float fdiv32(float x, float y) {\n  return x / y;\n}\n\nstatic inline float fadd32(float x, float y) {\n  return x + y;\n}\n\nstatic inline float fsub32(float x, float y) {\n  return x - y;\n}\n\nstatic inline float fmul32(float x, float y) {\n  return x * y;\n}\n\nstatic inline bool cmplt32(float x, float y) {\n  return x < y;\n}\n\nstatic inline bool cmple32(float x, float y) {\n  return x <= y;\n}\n\nstatic inline float sitofp_i8_f32(int8_t x) {\n  return (float) x;\n}\n\nstatic inline float sitofp_i16_f32(int16_t x) {\n  return (float) x;\n}\n\nstatic inline float sitofp_i32_f32(int32_t x) {\n  return (float) x;\n}\n\nstatic inline float sitofp_i64_f32(int64_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i8_f32(uint8_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i16_f32(uint16_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i32_f32(uint32_t x) {\n  return (float) x;\n}\n\nstatic inline float uitofp_i64_f32(uint64_t x) {\n  return (float) x;\n}\n\nstatic inline int8_t fptosi_f32_i8(float x) {\n  return (int8_t) x;\n}\n\nstatic inline int16_t fptosi_f32_i16(float x) {\n  return (int16_t) x;\n}\n\nstatic inline int32_t fptosi_f32_i32(float x) {\n  return (int32_t) x;\n}\n\nstatic inline int64_t fptosi_f32_i64(float x) {\n  return (int64_t) x;\n}\n\nstatic inline uint8_t fptoui_f32_i8(float x) {\n  return (uint8_t) x;\n}\n\nstatic inline uint16_t fptoui_f32_i16(float x) {\n  return (uint16_t) x;\n}\n\nstatic inline uint32_t fptoui_f32_i32(float x) {\n  return (uint32_t) x;\n}\n\nstatic inline uint64_t fpt",
                   "oui_f32_i64(float x) {\n  return (uint64_t) x;\n}\n\n#ifdef __OPENCL_VERSION__\nstatic inline float fabs32(float x) {\n  return fabs(x);\n}\n\nstatic inline float fmax32(float x, float y) {\n  return fmax(x, y);\n}\n\nstatic inline float fmin32(float x, float y) {\n  return fmin(x, y);\n}\n\nstatic inline float fpow32(float x, float y) {\n  return pow(x, y);\n}\n\n#else // Not OpenCL, but CUDA or plain C.\n\nstatic inline float fabs32(float x) {\n  return fabsf(x);\n}\n\nstatic inline float fmax32(float x, float y) {\n  return fmaxf(x, y);\n}\n\nstatic inline float fmin32(float x, float y) {\n  return fminf(x, y);\n}\n\nstatic inline float fpow32(float x, float y) {\n  return powf(x, y);\n}\n#endif\n\nstatic inline bool futrts_isnan32(float x) {\n  return isnan(x);\n}\n\nstatic inline bool futrts_isinf32(float x) {\n  return isinf(x);\n}\n\n#ifdef __OPENCL_VERSION__\nstatic inline float futrts_log32(float x) {\n  return log(x);\n}\n\nstatic inline float futrts_log2_32(float x) {\n  return log2(x);\n}\n\nstatic inline float futrts_log10_32(float x) {\n  return log10(x);\n}\n\nstatic inline float futrts_sqrt32(float x) {\n  return sqrt(x);\n}\n\nstatic inline float futrts_exp32(float x) {\n  return exp(x);\n}\n\nstatic inline float futrts_cos32(float x) {\n  return cos(x);\n}\n\nstatic inline float futrts_sin32(float x) {\n  return sin(x);\n}\n\nstatic inline float futrts_tan32(float x) {\n  return tan(x);\n}\n\nstatic inline float futrts_acos32(float x) {\n  return acos(x);\n}\n\nstatic inline float futrts_asin32(float x) {\n  return asin(x);\n}\n\nstatic inline float futrts_atan32(float x) {\n  return atan(x);\n}\n\nstatic inline float futrts_cosh32(float x) {\n  return cosh(x);\n}\n\nstatic inline float futrts_sinh32(float x) {\n  return sinh(x);\n}\n\nstatic inline float futrts_tanh32(float x) {\n  return tanh(x);\n}\n\nstatic inline float futrts_acosh32(float x) {\n  return acosh(x);\n}\n\nstatic inline float futrts_asinh32(float x) {\n  return asinh(x);\n}\n\nstatic inline float futrts_atanh32(float x) {\n  return atanh(x);\n}\n\nstatic inline float futrts_atan2_32(float x, fl",
                   "oat y) {\n  return atan2(x, y);\n}\n\nstatic inline float futrts_hypot32(float x, float y) {\n  return hypot(x, y);\n}\n\nstatic inline float futrts_gamma32(float x) {\n  return tgamma(x);\n}\n\nstatic inline float futrts_lgamma32(float x) {\n  return lgamma(x);\n}\n\nstatic inline float fmod32(float x, float y) {\n  return fmod(x, y);\n}\n\nstatic inline float futrts_round32(float x) {\n  return rint(x);\n}\n\nstatic inline float futrts_floor32(float x) {\n  return floor(x);\n}\n\nstatic inline float futrts_ceil32(float x) {\n  return ceil(x);\n}\n\nstatic inline float futrts_lerp32(float v0, float v1, float t) {\n  return mix(v0, v1, t);\n}\n\nstatic inline float futrts_mad32(float a, float b, float c) {\n  return mad(a, b, c);\n}\n\nstatic inline float futrts_fma32(float a, float b, float c) {\n  return fma(a, b, c);\n}\n\n#else // Not OpenCL, but CUDA or plain C.\n\nstatic inline float futrts_log32(float x) {\n  return logf(x);\n}\n\nstatic inline float futrts_log2_32(float x) {\n  return log2f(x);\n}\n\nstatic inline float futrts_log10_32(float x) {\n  return log10f(x);\n}\n\nstatic inline float futrts_sqrt32(float x) {\n  return sqrtf(x);\n}\n\nstatic inline float futrts_exp32(float x) {\n  return expf(x);\n}\n\nstatic inline float futrts_cos32(float x) {\n  return cosf(x);\n}\n\nstatic inline float futrts_sin32(float x) {\n  return sinf(x);\n}\n\nstatic inline float futrts_tan32(float x) {\n  return tanf(x);\n}\n\nstatic inline float futrts_acos32(float x) {\n  return acosf(x);\n}\n\nstatic inline float futrts_asin32(float x) {\n  return asinf(x);\n}\n\nstatic inline float futrts_atan32(float x) {\n  return atanf(x);\n}\n\nstatic inline float futrts_cosh32(float x) {\n  return coshf(x);\n}\n\nstatic inline float futrts_sinh32(float x) {\n  return sinhf(x);\n}\n\nstatic inline float futrts_tanh32(float x) {\n  return tanhf(x);\n}\n\nstatic inline float futrts_acosh32(float x) {\n  return acoshf(x);\n}\n\nstatic inline float futrts_asinh32(float x) {\n  return asinhf(x);\n}\n\nstatic inline float futrts_atanh32(float x) {\n  return atanhf(x);\n}\n\nstatic inline float futr",
                   "ts_atan2_32(float x, float y) {\n  return atan2f(x, y);\n}\n\nstatic inline float futrts_hypot32(float x, float y) {\n  return hypotf(x, y);\n}\n\nstatic inline float futrts_gamma32(float x) {\n  return tgammaf(x);\n}\n\nstatic inline float futrts_lgamma32(float x) {\n  return lgammaf(x);\n}\n\nstatic inline float fmod32(float x, float y) {\n  return fmodf(x, y);\n}\n\nstatic inline float futrts_round32(float x) {\n  return rintf(x);\n}\n\nstatic inline float futrts_floor32(float x) {\n  return floorf(x);\n}\n\nstatic inline float futrts_ceil32(float x) {\n  return ceilf(x);\n}\n\nstatic inline float futrts_lerp32(float v0, float v1, float t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline float futrts_mad32(float a, float b, float c) {\n  return a * b + c;\n}\n\nstatic inline float futrts_fma32(float a, float b, float c) {\n  return fmaf(a, b, c);\n}\n#endif\n\nstatic inline int32_t futrts_to_bits32(float x) {\n  union {\n    float f;\n    int32_t t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline float futrts_from_bits32(int32_t x) {\n  union {\n    int32_t f;\n    float t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline float fsignum32(float x) {\n  return futrts_isnan32(x) ? x : (x > 0) - (x < 0);\n}\n\n#ifdef FUTHARK_F64_ENABLED\n\nstatic inline double fdiv64(double x, double y) {\n  return x / y;\n}\n\nstatic inline double fadd64(double x, double y) {\n  return x + y;\n}\n\nstatic inline double fsub64(double x, double y) {\n  return x - y;\n}\n\nstatic inline double fmul64(double x, double y) {\n  return x * y;\n}\n\nstatic inline bool cmplt64(double x, double y) {\n  return x < y;\n}\n\nstatic inline bool cmple64(double x, double y) {\n  return x <= y;\n}\n\nstatic inline double sitofp_i8_f64(int8_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i16_f64(int16_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i32_f64(int32_t x) {\n  return (double) x;\n}\n\nstatic inline double sitofp_i64_f64(int64_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i8_f64(uint8_t x) {\n  return (double) x;\n}\n\nstatic inline dou",
                   "ble uitofp_i16_f64(uint16_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i32_f64(uint32_t x) {\n  return (double) x;\n}\n\nstatic inline double uitofp_i64_f64(uint64_t x) {\n  return (double) x;\n}\n\nstatic inline int8_t fptosi_f64_i8(double x) {\n  return (int8_t) x;\n}\n\nstatic inline int16_t fptosi_f64_i16(double x) {\n  return (int16_t) x;\n}\n\nstatic inline int32_t fptosi_f64_i32(double x) {\n  return (int32_t) x;\n}\n\nstatic inline int64_t fptosi_f64_i64(double x) {\n  return (int64_t) x;\n}\n\nstatic inline uint8_t fptoui_f64_i8(double x) {\n  return (uint8_t) x;\n}\n\nstatic inline uint16_t fptoui_f64_i16(double x) {\n  return (uint16_t) x;\n}\n\nstatic inline uint32_t fptoui_f64_i32(double x) {\n  return (uint32_t) x;\n}\n\nstatic inline uint64_t fptoui_f64_i64(double x) {\n  return (uint64_t) x;\n}\n\nstatic inline double fabs64(double x) {\n  return fabs(x);\n}\n\nstatic inline double fmax64(double x, double y) {\n  return fmax(x, y);\n}\n\nstatic inline double fmin64(double x, double y) {\n  return fmin(x, y);\n}\n\nstatic inline double fpow64(double x, double y) {\n  return pow(x, y);\n}\n\nstatic inline double futrts_log64(double x) {\n  return log(x);\n}\n\nstatic inline double futrts_log2_64(double x) {\n  return log2(x);\n}\n\nstatic inline double futrts_log10_64(double x) {\n  return log10(x);\n}\n\nstatic inline double futrts_sqrt64(double x) {\n  return sqrt(x);\n}\n\nstatic inline double futrts_exp64(double x) {\n  return exp(x);\n}\n\nstatic inline double futrts_cos64(double x) {\n  return cos(x);\n}\n\nstatic inline double futrts_sin64(double x) {\n  return sin(x);\n}\n\nstatic inline double futrts_tan64(double x) {\n  return tan(x);\n}\n\nstatic inline double futrts_acos64(double x) {\n  return acos(x);\n}\n\nstatic inline double futrts_asin64(double x) {\n  return asin(x);\n}\n\nstatic inline double futrts_atan64(double x) {\n  return atan(x);\n}\n\nstatic inline double futrts_cosh64(double x) {\n  return cosh(x);\n}\n\nstatic inline double futrts_sinh64(double x) {\n  return sinh(x);\n}\n\nstatic inline double futrts_tanh64(double",
                   " x) {\n  return tanh(x);\n}\n\nstatic inline double futrts_acosh64(double x) {\n  return acosh(x);\n}\n\nstatic inline double futrts_asinh64(double x) {\n  return asinh(x);\n}\n\nstatic inline double futrts_atanh64(double x) {\n  return atanh(x);\n}\n\nstatic inline double futrts_atan2_64(double x, double y) {\n  return atan2(x, y);\n}\n\nstatic inline double futrts_hypot64(double x, double y) {\n  return hypot(x, y);\n}\n\nstatic inline double futrts_gamma64(double x) {\n  return tgamma(x);\n}\n\nstatic inline double futrts_lgamma64(double x) {\n  return lgamma(x);\n}\n\nstatic inline double futrts_fma64(double a, double b, double c) {\n  return fma(a, b, c);\n}\n\nstatic inline double futrts_round64(double x) {\n  return rint(x);\n}\n\nstatic inline double futrts_ceil64(double x) {\n  return ceil(x);\n}\n\nstatic inline double futrts_floor64(double x) {\n  return floor(x);\n}\n\nstatic inline bool futrts_isnan64(double x) {\n  return isnan(x);\n}\n\nstatic inline bool futrts_isinf64(double x) {\n  return isinf(x);\n}\n\nstatic inline int64_t futrts_to_bits64(double x) {\n  union {\n    double f;\n    int64_t t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline double futrts_from_bits64(int64_t x) {\n  union {\n    int64_t f;\n    double t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline double fmod64(double x, double y) {\n  return fmod(x, y);\n}\n\nstatic inline double fsignum64(double x) {\n  return futrts_isnan64(x) ? x : (x > 0) - (x < 0);\n}\n\nstatic inline double futrts_lerp64(double v0, double v1, double t) {\n#ifdef __OPENCL_VERSION__\n  return mix(v0, v1, t);\n#else\n  return v0 + (v1 - v0) * t;\n#endif\n}\n\nstatic inline double futrts_mad64(double a, double b, double c) {\n#ifdef __OPENCL_VERSION__\n  return mad(a, b, c);\n#else\n  return a * b + c;\n#endif\n}\n\nstatic inline float fpconv_f32_f32(float x) {\n  return (float) x;\n}\n\nstatic inline double fpconv_f32_f64(float x) {\n  return (double) x;\n}\n\nstatic inline float fpconv_f64_f32(double x) {\n  return (float) x;\n}\n\nstatic inline double fpconv_f64_f64(double x) {\n  return (double) ",
                   "x;\n}\n\n#endif\n\n// End of scalar.h.\n// Start of scalar_f16.h.\n\n// Half-precision is emulated if needed (e.g. in straight C) with the\n// native type used if possible.  The emulation works by typedef'ing\n// 'float' to 'f16', and then implementing all operations on single\n// precision.  To cut down on duplication, we use the same code for\n// those Futhark functions that require just operators or casts.  The\n// in-memory representation for arrays will still be 16 bits even\n// under emulation, so the compiler will have to be careful when\n// generating reads or writes.\n\n#if !defined(cl_khr_fp16) && !(defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 600)\n#define EMULATE_F16\n#endif\n\n#if !defined(EMULATE_F16) && defined(__OPENCL_VERSION__)\n#pragma OPENCL EXTENSION cl_khr_fp16 : enable\n#endif\n\n#ifdef EMULATE_F16\n\n// Note that the half-precision storage format is still 16 bits - the\n// compiler will have to be real careful!\ntypedef float f16;\n\n#else\n\n#ifdef __CUDA_ARCH__\n#include <cuda_fp16.h>\n#endif\n\ntypedef half f16;\n\n#endif\n\n// Some of these functions convert to single precision because half\n// precision versions are not available.\n\nstatic inline f16 fadd16(f16 x, f16 y) {\n  return x + y;\n}\n\nstatic inline f16 fsub16(f16 x, f16 y) {\n  return x - y;\n}\n\nstatic inline f16 fmul16(f16 x, f16 y) {\n  return x * y;\n}\n\nstatic inline bool cmplt16(f16 x, f16 y) {\n  return x < y;\n}\n\nstatic inline bool cmple16(f16 x, f16 y) {\n  return x <= y;\n}\n\nstatic inline f16 sitofp_i8_f16(int8_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 sitofp_i16_f16(int16_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 sitofp_i32_f16(int32_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 sitofp_i64_f16(int64_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i8_f16(uint8_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i16_f16(uint16_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i32_f16(uint32_t x) {\n  return (f16) x;\n}\n\nstatic inline f16 uitofp_i64_f16(uint64_t x) {\n  return (f16) x;\n}\n\nstatic inline int8_t fpt",
                   "osi_f16_i8(f16 x) {\n  return (int8_t) (float) x;\n}\n\nstatic inline int16_t fptosi_f16_i16(f16 x) {\n  return (int16_t) x;\n}\n\nstatic inline int32_t fptosi_f16_i32(f16 x) {\n  return (int32_t) x;\n}\n\nstatic inline int64_t fptosi_f16_i64(f16 x) {\n  return (int64_t) x;\n}\n\nstatic inline uint8_t fptoui_f16_i8(f16 x) {\n  return (uint8_t) (float) x;\n}\n\nstatic inline uint16_t fptoui_f16_i16(f16 x) {\n  return (uint16_t) x;\n}\n\nstatic inline uint32_t fptoui_f16_i32(f16 x) {\n  return (uint32_t) x;\n}\n\nstatic inline uint64_t fptoui_f16_i64(f16 x) {\n  return (uint64_t) x;\n}\n\n#ifndef EMULATE_F16\n\n#ifdef __OPENCL_VERSION__\nstatic inline f16 fabs16(f16 x) {\n  return fabs(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return fmax(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return fmin(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return pow(x, y);\n}\n\n#else // Assuming CUDA.\n\nstatic inline f16 fabs16(f16 x) {\n  return fabsf(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return fmaxf(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return fminf(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return powf(x, y);\n}\n#endif\n\nstatic inline bool futrts_isnan16(f16 x) {\n  return isnan((float)x);\n}\n\nstatic inline bool futrts_isinf16(f16 x) {\n  return isinf((float)x);\n}\n\n#ifdef __OPENCL_VERSION__\nstatic inline f16 futrts_log16(f16 x) {\n  return log(x);\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return log2(x);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return log10(x);\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  return sqrt(x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return exp(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return cos(x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return sin(x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return tan(x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return acos(x);\n}\n\nstatic inline f16 futrts_asin16(f16 x) {\n  return asin(x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return atan(x);\n}\n\nstatic inli",
                   "ne f16 futrts_cosh16(f16 x) {\n  return cosh(x);\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return sinh(x);\n}\n\nstatic inline f16 futrts_tanh16(f16 x) {\n  return tanh(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  return acosh(x);\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  return asinh(x);\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  return atanh(x);\n}\n\nstatic inline f16 futrts_atan2_16(f16 x, f16 y) {\n  return atan2(x, y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return hypot(x, y);\n}\n\nstatic inline f16 futrts_gamma16(f16 x) {\n  return tgamma(x);\n}\n\nstatic inline f16 futrts_lgamma16(f16 x) {\n  return lgamma(x);\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return fmod(x, y);\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return rint(x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return floor(x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return ceil(x);\n}\n\nstatic inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {\n  return mix(v0, v1, t);\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return mad(a, b, c);\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return fma(a, b, c);\n}\n\n#else // Assume CUDA.\n\nstatic inline f16 futrts_log16(f16 x) {\n  return hlog(x);\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return hlog2(x);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return hlog10(x);\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  return hsqrt(x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return hexp(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return hcos(x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return hsin(x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return tanf(x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return acosf(x);\n}\n\nstatic inline f16 futrts_asin16(f16 x) {\n  return asinf(x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return atanf(x);\n}\n\nstatic inline f16 futrts_cosh16(f16 x) {\n  return coshf(x);\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return sinhf(x);\n}\n\nstatic inline f16 ",
                   "futrts_tanh16(f16 x) {\n  return tanhf(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  return acoshf(x);\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  return asinhf(x);\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  return atanhf(x);\n}\n\nstatic inline f16 futrts_atan2_16(f16 x, f16 y) {\n  return atan2f(x, y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return hypotf(x, y);\n}\n\nstatic inline f16 futrts_gamma16(f16 x) {\n  return tgammaf(x);\n}\n\nstatic inline f16 futrts_lgamma16(f16 x) {\n  return lgammaf(x);\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return fmodf(x, y);\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return rintf(x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return hfloor(x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return hceil(x);\n}\n\nstatic inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {\n  return v0 + (v1 - v0) * t;\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return a * b + c;\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return fmaf(a, b, c);\n}\n\n#endif\n\n// The CUDA __half type cannot be put in unions for some reason, so we\n// use bespoke conversion functions instead.\n#ifdef __CUDA_ARCH__\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  return __half_as_ushort(x);\n}\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  return __ushort_as_half(x);\n}\n#else\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  union {\n    f16 f;\n    int16_t t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  union {\n    int16_t f;\n    f16 t;\n  } p;\n\n  p.f = x;\n  return p.t;\n}\n#endif\n\n#else // No native f16 - emulate.\n\nstatic inline f16 fabs16(f16 x) {\n  return fabs32(x);\n}\n\nstatic inline f16 fmax16(f16 x, f16 y) {\n  return fmax32(x, y);\n}\n\nstatic inline f16 fmin16(f16 x, f16 y) {\n  return fmin32(x, y);\n}\n\nstatic inline f16 fpow16(f16 x, f16 y) {\n  return fpow32(x, y);\n}\n\nstatic inline bool futrts_isnan16(f16 x) {\n  return futrts_isnan32(x);\n}\n\nstatic inline bool futrts_isinf16(f16 x) {",
                   "\n  return futrts_isinf32(x);\n}\n\nstatic inline f16 futrts_log16(f16 x) {\n  return futrts_log32(x);\n}\n\nstatic inline f16 futrts_log2_16(f16 x) {\n  return futrts_log2_32(x);\n}\n\nstatic inline f16 futrts_log10_16(f16 x) {\n  return futrts_log10_32(x);\n}\n\nstatic inline f16 futrts_sqrt16(f16 x) {\n  return futrts_sqrt32(x);\n}\n\nstatic inline f16 futrts_exp16(f16 x) {\n  return futrts_exp32(x);\n}\n\nstatic inline f16 futrts_cos16(f16 x) {\n  return futrts_cos32(x);\n}\n\nstatic inline f16 futrts_sin16(f16 x) {\n  return futrts_sin32(x);\n}\n\nstatic inline f16 futrts_tan16(f16 x) {\n  return futrts_tan32(x);\n}\n\nstatic inline f16 futrts_acos16(f16 x) {\n  return futrts_acos32(x);\n}\n\nstatic inline f16 futrts_asin16(f16 x) {\n  return futrts_asin32(x);\n}\n\nstatic inline f16 futrts_atan16(f16 x) {\n  return futrts_atan32(x);\n}\n\nstatic inline f16 futrts_cosh16(f16 x) {\n  return futrts_cosh32(x);\n}\n\nstatic inline f16 futrts_sinh16(f16 x) {\n  return futrts_sinh32(x);\n}\n\nstatic inline f16 futrts_tanh16(f16 x) {\n  return futrts_tanh32(x);\n}\n\nstatic inline f16 futrts_acosh16(f16 x) {\n  return futrts_acosh32(x);\n}\n\nstatic inline f16 futrts_asinh16(f16 x) {\n  return futrts_asinh32(x);\n}\n\nstatic inline f16 futrts_atanh16(f16 x) {\n  return futrts_atanh32(x);\n}\n\nstatic inline f16 futrts_atan2_16(f16 x, f16 y) {\n  return futrts_atan2_32(x, y);\n}\n\nstatic inline f16 futrts_hypot16(f16 x, f16 y) {\n  return futrts_hypot32(x, y);\n}\n\nstatic inline f16 futrts_gamma16(f16 x) {\n  return futrts_gamma32(x);\n}\n\nstatic inline f16 futrts_lgamma16(f16 x) {\n  return futrts_lgamma32(x);\n}\n\nstatic inline f16 fmod16(f16 x, f16 y) {\n  return fmod32(x, y);\n}\n\nstatic inline f16 futrts_round16(f16 x) {\n  return futrts_round32(x);\n}\n\nstatic inline f16 futrts_floor16(f16 x) {\n  return futrts_floor32(x);\n}\n\nstatic inline f16 futrts_ceil16(f16 x) {\n  return futrts_ceil32(x);\n}\n\nstatic inline f16 futrts_lerp16(f16 v0, f16 v1, f16 t) {\n  return futrts_lerp32(v0, v1, t);\n}\n\nstatic inline f16 futrts_mad16(f16 a, f16 b, f16 c) {\n  return f",
                   "utrts_mad32(a, b, c);\n}\n\nstatic inline f16 futrts_fma16(f16 a, f16 b, f16 c) {\n  return futrts_fma32(a, b, c);\n}\n\n// Even when we are using an OpenCL that does not support cl_khr_fp16,\n// it must still support vload_half for actually creating a\n// half-precision number, which can then be efficiently converted to a\n// float.  Similarly for vstore_half.\n#ifdef __OPENCL_VERSION__\n\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  int16_t y;\n  // Violating strict aliasing here.\n  vstore_half((float)x, 0, (half*)&y);\n  return y;\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  return (f16)vload_half(0, (half*)&x);\n}\n\n#else\n\nstatic inline int16_t futrts_to_bits16(f16 x) {\n  return (int16_t)float2halfbits(x);\n}\n\nstatic inline f16 futrts_from_bits16(int16_t x) {\n  return halfbits2float((uint16_t)x);\n}\n\nstatic inline f16 fsignum16(f16 x) {\n  return futrts_isnan16(x) ? x : (x > 0) - (x < 0);\n}\n\n#endif\n\n#endif\n\nstatic inline float fpconv_f16_f16(f16 x) {\n  return x;\n}\n\nstatic inline float fpconv_f16_f32(f16 x) {\n  return x;\n}\n\nstatic inline f16 fpconv_f32_f16(float x) {\n  return x;\n}\n\n#ifdef FUTHARK_F64_ENABLED\n\nstatic inline double fpconv_f16_f64(f16 x) {\n  return (double) x;\n}\n\nstatic inline f16 fpconv_f64_f16(double x) {\n  return (f16) x;\n}\n\n#endif\n\n\n// End of scalar_f16.h.\n// Start of atomics.h\n\ninline int32_t atomic_xchg_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xchg_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_cmpxchg_i32_global(volatile __global int32_t *p,\n                                         int32_t cmp, int32_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((int32_t*)p, cmp, val);\n#else\n  return atomic_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int32_t atomic_cmpxchg_i32_local(volatile __local int32_t *p",
                   ",\n                                        int32_t cmp, int32_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((int32_t*)p, cmp, val);\n#else\n  return atomic_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int32_t atomic_add_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((int32_t*)p, x);\n#else\n  return atomic_add(p, x);\n#endif\n}\n\ninline int32_t atomic_add_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((int32_t*)p, x);\n#else\n  return atomic_add(p, x);\n#endif\n}\n\ninline float atomic_fadd_f32_global(volatile __global float *p, float x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((float*)p, x);\n#else\n  union { int32_t i; float f; } old;\n  union { int32_t i; float f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i32_global((volatile __global int32_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline float atomic_fadd_f32_local(volatile __local float *p, float x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((float*)p, x);\n#else\n  union { int32_t i; float f; } old;\n  union { int32_t i; float f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i32_local((volatile __local int32_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline int32_t atomic_smax_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline int32_t atomic_smax_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline int32_t atomic_smin_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline int32_t atomic_smin_i32_local(volatile __local int32_t *p, int32",
                   "_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline uint32_t atomic_umax_i32_global(volatile __global uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline uint32_t atomic_umax_i32_local(volatile __local uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint32_t*)p, x);\n#else\n  return atomic_max(p, x);\n#endif\n}\n\ninline uint32_t atomic_umin_i32_global(volatile __global uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline uint32_t atomic_umin_i32_local(volatile __local uint32_t *p, uint32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint32_t*)p, x);\n#else\n  return atomic_min(p, x);\n#endif\n}\n\ninline int32_t atomic_and_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int32_t*)p, x);\n#else\n  return atomic_and(p, x);\n#endif\n}\n\ninline int32_t atomic_and_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int32_t*)p, x);\n#else\n  return atomic_and(p, x);\n#endif\n}\n\ninline int32_t atomic_or_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int32_t*)p, x);\n#else\n  return atomic_or(p, x);\n#endif\n}\n\ninline int32_t atomic_or_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int32_t*)p, x);\n#else\n  return atomic_or(p, x);\n#endif\n}\n\ninline int32_t atomic_xor_i32_global(volatile __global int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\ninline int32_t atomic_xor_i32_local(volatile __local int32_t *p, int32_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int32_t*)p, x);\n#else\n  return atomic_xor(p, x);\n#endif\n}\n\n// Start of 64 bit atomics\n\ninline int64_t atomic_xchg_i64_global(volatile __global int64_t *p, int",
                   "64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((uint64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\ninline int64_t atomic_xchg_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicExch((uint64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\ninline int64_t atomic_cmpxchg_i64_global(volatile __global int64_t *p,\n                                         int64_t cmp, int64_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((uint64_t*)p, cmp, val);\n#else\n  return atom_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int64_t atomic_cmpxchg_i64_local(volatile __local int64_t *p,\n                                        int64_t cmp, int64_t val) {\n#ifdef FUTHARK_CUDA\n  return atomicCAS((uint64_t*)p, cmp, val);\n#else\n  return atom_cmpxchg(p, cmp, val);\n#endif\n}\n\ninline int64_t atomic_add_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((uint64_t*)p, x);\n#else\n  return atom_add(p, x);\n#endif\n}\n\ninline int64_t atomic_add_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAdd((uint64_t*)p, x);\n#else\n  return atom_add(p, x);\n#endif\n}\n\n#ifdef FUTHARK_F64_ENABLED\n\ninline double atomic_fadd_f64_global(volatile __global double *p, double x) {\n#if defined(FUTHARK_CUDA) && __CUDA_ARCH__ >= 600\n  return atomicAdd((double*)p, x);\n#else\n  union { int64_t i; double f; } old;\n  union { int64_t i; double f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i64_global((volatile __global int64_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\ninline double atomic_fadd_f64_local(volatile __local double *p, double x) {\n#if defined(FUTHARK_CUDA) && __CUDA_ARCH__ >= 600\n  return atomicAdd((double*)p, x);\n#else\n  union { int64_t i; double f; } old;\n  union { int64_t i; double f; } assumed;\n  old.f = *p;\n  do {\n    assumed.f = old.f;\n    old.f = old.f + x;\n    old.i = atomic_cmpxchg_i64_local((volatile",
                   " __local int64_t*)p, assumed.i, old.i);\n  } while (assumed.i != old.i);\n  return old.f;\n#endif\n}\n\n#endif\n\ninline int64_t atomic_smax_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline int64_t atomic_smax_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((int64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline int64_t atomic_smin_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline int64_t atomic_smin_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((int64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline uint64_t atomic_umax_i64_global(volatile __global uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline uint64_t atomic_umax_i64_local(volatile __local uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMax((uint64_t*)p, x);\n#else\n  return atom_max(p, x);\n#endif\n}\n\ninline uint64_t atomic_umin_i64_global(volatile __global uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline uint64_t atomic_umin_i64_local(volatile __local uint64_t *p, uint64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicMin((uint64_t*)p, x);\n#else\n  return atom_min(p, x);\n#endif\n}\n\ninline int64_t atomic_and_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int64_t*)p, x);\n#else\n  return atom_and(p, x);\n#endif\n}\n\ninline int64_t atomic_and_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicAnd((int64_t*)p, x);\n#else\n  return atom_and(p, x);\n#endif\n}\n\ninline int64_t atomic_or_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return at",
                   "omicOr((int64_t*)p, x);\n#else\n  return atom_or(p, x);\n#endif\n}\n\ninline int64_t atomic_or_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicOr((int64_t*)p, x);\n#else\n  return atom_or(p, x);\n#endif\n}\n\ninline int64_t atomic_xor_i64_global(volatile __global int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\ninline int64_t atomic_xor_i64_local(volatile __local int64_t *p, int64_t x) {\n#ifdef FUTHARK_CUDA\n  return atomicXor((int64_t*)p, x);\n#else\n  return atom_xor(p, x);\n#endif\n}\n\n// End of atomics.h\n\n\n\n__kernel void builtinzhreplicate_f64zireplicate_20599(int32_t num_elems_20596,\n                                                      double val_20597, __global\n                                                      unsigned char *mem_20595)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    int32_t replicate_gtid_20599;\n    int32_t replicate_ltid_20600;\n    int32_t replicate_gid_20601;\n    \n    replicate_gtid_20599 = get_global_id(0);\n    replicate_ltid_20600 = get_local_id(0);\n    replicate_gid_20601 = get_group_id(0);\n    \n    int64_t slice_20605 = num_elems_20596;\n    int64_t rep_i_20604 = sext_i32_i64(replicate_gtid_20599);\n    int64_t remnant_20606 = sext_i32_i64(replicate_gtid_20599) - rep_i_20604;\n    \n    if (slt64(replicate_gtid_20599, num_elems_20596)) {\n        ((__global double *) mem_20595)[rep_i_20604] = val_20597;\n    }\n    \n  error_0:\n    return;\n}\n__kernel void dotzisegred_nonseg_19187(__global int *global_failure,\n                                       __local volatile\n                                       int64_t *red_arr_mem_20608_backing_aligned_0,\n                                       __local volatile\n                                       int64_t *sync_arr_mem_20606_backing_aligned_1,\n                                       int64_t i_18461,\n                                       int64_t num_groups_19",
                   "182,\n                                       int64_t num_threads_20600, __global\n                                       unsigned char *a_mem_20275, __global\n                                       unsigned char *b_mem_20276, __global\n                                       unsigned char *mem_20279, __global\n                                       unsigned char *dotzicounter_mem_20596,\n                                       __global\n                                       unsigned char *segred_tmp_mem_20598)\n{\n    #define segred_group_sizze_19180 (dotzisegred_group_sizze_19179)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_arr_mem_20608_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20608_backing_aligned_0;\n    __local volatile unsigned char *restrict sync_arr_mem_20606_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) sync_arr_mem_20606_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20601;\n    int32_t local_tid_20602;\n    int64_t group_sizze_20605;\n    int32_t wave_sizze_20604;\n    int32_t group_tid_20603;\n    \n    global_tid_20601 = get_global_id(0);\n    local_tid_20602 = get_local_id(0);\n    group_sizze_20605 = get_local_size(0);\n    wave_sizze_20604 = LOCKSTEP_WIDTH;\n    group_tid_20603 = get_group_id(0);\n    \n    int32_t phys_tid_19187 = global_tid_20601;\n    __local unsigned char *sync_arr_mem_20606;\n    \n    sync_arr_mem_20606 = (__local unsigned char *) sync_arr_mem_20606_backing_0;\n    \n    __local unsigned char *red_arr_mem_20608;\n    \n    red_arr_mem_20608 = (__local unsigned char *) red_arr_mem_20608_backing_1;\n    \n    int64_t dummy_19185 = (int64_t) 0;\n    int64_t gtid_19186 = (int64_t) 0;\n    float x_acc_20610;\n    int64_t chunk_sizze_20611 = smin64(sdiv_up64(i_1",
                   "8461,\n                                                 sext_i32_i64(sext_i64_i32(segred_group_sizze_19180 *\n                                                 num_groups_19182))),\n                                       sdiv_up64(i_18461 - phys_tid_19187,\n                                                 num_threads_20600));\n    float x_18465;\n    float x_18466;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_20610 = 0.0F;\n    }\n    for (int64_t i_20615 = 0; i_20615 < chunk_sizze_20611; i_20615++) {\n        gtid_19186 = phys_tid_19187 + num_threads_20600 * i_20615;\n        // apply map function\n        {\n            float x_18468 = ((__global float *) a_mem_20275)[gtid_19186];\n            float x_18469 = ((__global float *) b_mem_20276)[gtid_19186];\n            float defunc_1_f_res_18470 = x_18468 * x_18469;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_18465 = x_acc_20610;\n            }\n            // load new values\n            {\n                x_18466 = defunc_1_f_res_18470;\n            }\n            // apply reduction operator\n            {\n                float defunc_1_op_res_18467 = x_18465 + x_18466;\n                \n                // store in accumulator\n                {\n                    x_acc_20610 = defunc_1_op_res_18467;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_18465 = x_acc_20610;\n        ((__local float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n            x_18465;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_20616;\n    int32_t skip_waves_20617 = 1;\n    float x_20612;\n    float x_20613;\n    \n    offset_20616 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_20602, sext_i64_i32(segred_group_sizze_19180))) {\n            x_20612 = ((__local\n                        float *) red_arr_mem_20608)[",
                   "sext_i32_i64(local_tid_20602 +\n                                                    offset_20616)];\n        }\n    }\n    offset_20616 = 1;\n    while (slt32(offset_20616, wave_sizze_20604)) {\n        if (slt32(local_tid_20602 + offset_20616,\n                  sext_i64_i32(segred_group_sizze_19180)) && ((local_tid_20602 -\n                                                               squot32(local_tid_20602,\n                                                                       wave_sizze_20604) *\n                                                               wave_sizze_20604) &\n                                                              (2 *\n                                                               offset_20616 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_20613 = ((volatile __local\n                            float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                        offset_20616)];\n            }\n            // apply reduction operation\n            {\n                float defunc_1_op_res_20614 = x_20612 + x_20613;\n                \n                x_20612 = defunc_1_op_res_20614;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                    x_20612;\n            }\n        }\n        offset_20616 *= 2;\n    }\n    while (slt32(skip_waves_20617,\n                 squot32(sext_i64_i32(segred_group_sizze_19180) +\n                         wave_sizze_20604 - 1, wave_sizze_20604))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_20616 = skip_waves_20617 * wave_sizze_20604;\n        if (slt32(local_tid_20602 + offset_20616,\n                  sext_i64_i32(segred_group_sizze_19180)) && ((local_tid_20602 -\n                                                               squot32(local_t",
                   "id_20602,\n                                                                       wave_sizze_20604) *\n                                                               wave_sizze_20604) ==\n                                                              0 &&\n                                                              (squot32(local_tid_20602,\n                                                                       wave_sizze_20604) &\n                                                               (2 *\n                                                                skip_waves_20617 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_20613 = ((__local\n                            float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                        offset_20616)];\n            }\n            // apply reduction operation\n            {\n                float defunc_1_op_res_20614 = x_20612 + x_20613;\n                \n                x_20612 = defunc_1_op_res_20614;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                    x_20612;\n            }\n        }\n        skip_waves_20617 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_20602) == (int64_t) 0) {\n            x_acc_20610 = x_20612;\n        }\n    }\n    \n    int32_t old_counter_20618;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_20602 == 0) {\n            ((__global\n              float *) segred_tmp_mem_20598)[sext_i32_i64(group_tid_20603)] =\n                x_acc_20610;\n            mem_fence_global();\n            old_counter_20618 = atomic_add_i32_global(&((volatile __global\n                                              ",
                   "           int *) dotzicounter_mem_20596)[(int64_t) 0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_20606)[(int64_t) 0] =\n                old_counter_20618 == num_groups_19182 - (int64_t) 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_20619 = ((__local\n                                 bool *) sync_arr_mem_20606)[(int64_t) 0];\n    \n    if (is_last_group_20619) {\n        if (local_tid_20602 == 0) {\n            old_counter_20618 = atomic_add_i32_global(&((volatile __global\n                                                         int *) dotzicounter_mem_20596)[(int64_t) 0],\n                                                      (int) ((int64_t) 0 -\n                                                             num_groups_19182));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_20620 = sdiv_up64(num_groups_19182,\n                                                      segred_group_sizze_19180);\n            \n            x_18465 = 0.0F;\n            for (int64_t i_20621 = 0; i_20621 < read_per_thread_20620;\n                 i_20621++) {\n                int64_t group_res_id_20622 = sext_i32_i64(local_tid_20602) *\n                        read_per_thread_20620 + i_20621;\n                int64_t index_of_group_res_20623 = group_res_id_20622;\n                \n                if (slt64(group_res_id_20622, num_groups_19182)) {\n                    x_18466 = ((__global\n                                float *) segred_tmp_mem_20598)[index_of_group_res_20623];\n                    \n                    float defunc_1_op_res_18467 = x_18465 + x_18466;\n                    \n                    x_18465 = defunc_1_op_res_18467;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n            x_18465;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-g",
                   "roup results\n        {\n            int32_t offset_20624;\n            int32_t skip_waves_20625 = 1;\n            float x_20612;\n            float x_20613;\n            \n            offset_20624 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_20602,\n                          sext_i64_i32(segred_group_sizze_19180))) {\n                    x_20612 = ((__local\n                                float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                            offset_20624)];\n                }\n            }\n            offset_20624 = 1;\n            while (slt32(offset_20624, wave_sizze_20604)) {\n                if (slt32(local_tid_20602 + offset_20624,\n                          sext_i64_i32(segred_group_sizze_19180)) &&\n                    ((local_tid_20602 - squot32(local_tid_20602,\n                                                wave_sizze_20604) *\n                      wave_sizze_20604) & (2 * offset_20624 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_20613 = ((volatile __local\n                                    float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                                offset_20624)];\n                    }\n                    // apply reduction operation\n                    {\n                        float defunc_1_op_res_20614 = x_20612 + x_20613;\n                        \n                        x_20612 = defunc_1_op_res_20614;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                            x_20612;\n                    }\n                }\n                offset_20624 *= 2;\n            }\n            while (slt32(skip_waves_20625,\n                     ",
                   "    squot32(sext_i64_i32(segred_group_sizze_19180) +\n                                 wave_sizze_20604 - 1, wave_sizze_20604))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_20624 = skip_waves_20625 * wave_sizze_20604;\n                if (slt32(local_tid_20602 + offset_20624,\n                          sext_i64_i32(segred_group_sizze_19180)) &&\n                    ((local_tid_20602 - squot32(local_tid_20602,\n                                                wave_sizze_20604) *\n                      wave_sizze_20604) == 0 && (squot32(local_tid_20602,\n                                                         wave_sizze_20604) &\n                                                 (2 * skip_waves_20625 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_20613 = ((__local\n                                    float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                                offset_20624)];\n                    }\n                    // apply reduction operation\n                    {\n                        float defunc_1_op_res_20614 = x_20612 + x_20613;\n                        \n                        x_20612 = defunc_1_op_res_20614;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                            x_20612;\n                    }\n                }\n                skip_waves_20625 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_20602 == 0) {\n                    ((__global float *) mem_20279)[(int64_t) 0] = x_20612;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19180\n}\n__kernel void gpu_map_transpose_f32(__local volatile\n       ",
                   "                             int64_t *block_9_backing_aligned_0,\n                                    int32_t destoffset_1, int32_t srcoffset_3,\n                                    int32_t num_arrays_4, int32_t x_elems_5,\n                                    int32_t y_elems_6, int32_t mulx_7,\n                                    int32_t muly_8, __global\n                                    unsigned char *destmem_0, __global\n                                    unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t x_index_31 = get_global_id_0_37;\n    int32_t y_index_32 = get_group_id_1_41 * 32 + get_local_id_1_39;\n    \n    if (slt32(x_index_31, x_elems_5)) {\n        for (int32_t j_43 = 0; j_43 < 4; j_43++) {\n            int32_t index_in_35 = (y_index_32 + j_43 * 8) * x_elems_5 +\n                    x_index_31;\n            \n            if (slt32(y_index_32 + j_43 * 8, y_elems_6)) {\n       ",
                   "         ((__local float *) block_9)[sext_i32_i64((get_local_id_1_39 +\n                                                          j_43 * 8) * 33 +\n                                            get_local_id_0_38)] = ((__global\n                                                                    float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                                       index_in_35)];\n            }\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_41 * 32 + get_local_id_0_38;\n    y_index_32 = get_group_id_0_40 * 32 + get_local_id_1_39;\n    if (slt32(x_index_31, y_elems_6)) {\n        for (int32_t j_43 = 0; j_43 < 4; j_43++) {\n            int32_t index_out_36 = (y_index_32 + j_43 * 8) * y_elems_6 +\n                    x_index_31;\n            \n            if (slt32(y_index_32 + j_43 * 8, x_elems_5)) {\n                ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                               index_out_36)] = ((__local\n                                                                  float *) block_9)[sext_i32_i64(get_local_id_0_38 *\n                                                                                    33 +\n                                                                                    get_local_id_1_39 +\n                                                                                    j_43 *\n                                                                                    8)];\n            }\n        }\n    }\n    \n  error_0:\n    return;\n}\n__kernel void gpu_map_transpose_f32_low_height(__local volatile\n                                               int64_t *block_9_backing_aligned_0,\n                                               int32_t destoffset_1,\n                                               int32_t srcoffset_3,\n                                               int32_t num_arrays_4,\n                                               i",
                   "nt32_t x_elems_5,\n                                               int32_t y_elems_6,\n                                               int32_t mulx_7, int32_t muly_8,\n                                               __global\n                                               unsigned char *destmem_0,\n                                               __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t x_index_31 = get_group_id_0_40 * 16 * mulx_7 + get_local_id_0_38 +\n            srem32(get_local_id_1_39, mulx_7) * 16;\n    int32_t y_index_32 = get_group_id_1_41 * 16 + squot32(get_local_id_1_39,\n                                                          mulx_7);\n    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt32(x_index_31, x_elems_5) && slt32(y_index_32, y_elems_6)) {\n        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 +\n                ",
                   "                    get_local_id_0_38)] = ((__global\n                                                            float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                               index_in_35)];\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_41 * 16 + squot32(get_local_id_0_38, mulx_7);\n    y_index_32 = get_group_id_0_40 * 16 * mulx_7 + get_local_id_1_39 +\n        srem32(get_local_id_0_38, mulx_7) * 16;\n    \n    int32_t index_out_36 = y_index_32 * y_elems_6 + x_index_31;\n    \n    if (slt32(x_index_31, y_elems_6) && slt32(y_index_32, x_elems_5)) {\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                       index_out_36)] = ((__local\n                                                          float *) block_9)[sext_i32_i64(get_local_id_0_38 *\n                                                                            17 +\n                                                                            get_local_id_1_39)];\n    }\n    \n  error_0:\n    return;\n}\n__kernel void gpu_map_transpose_f32_low_width(__local volatile\n                                              int64_t *block_9_backing_aligned_0,\n                                              int32_t destoffset_1,\n                                              int32_t srcoffset_3,\n                                              int32_t num_arrays_4,\n                                              int32_t x_elems_5,\n                                              int32_t y_elems_6, int32_t mulx_7,\n                                              int32_t muly_8, __global\n                                              unsigned char *destmem_0, __global\n                                              unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 =\n                           ",
                   "        (__local volatile\n                                    unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = get_group_id_2_42 * x_elems_5 * y_elems_6;\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t x_index_31 = get_group_id_0_40 * 16 + squot32(get_local_id_0_38,\n                                                          muly_8);\n    int32_t y_index_32 = get_group_id_1_41 * 16 * muly_8 + get_local_id_1_39 +\n            srem32(get_local_id_0_38, muly_8) * 16;\n    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    \n    if (slt32(x_index_31, x_elems_5) && slt32(y_index_32, y_elems_6)) {\n        ((__local float *) block_9)[sext_i32_i64(get_local_id_1_39 * 17 +\n                                    get_local_id_0_38)] = ((__global\n                                                            float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                               index_in_35)];\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    x_index_31 = get_group_id_1_41 * 16 * muly_8 + get_local_id_0_38 +\n        srem32(get_local_id_1_39, muly_8) * 16;\n    y_index_32 = get_group_id_0_40 * 16 + squot32(get_local_id_1_39, muly_8);\n    \n    int32_t index_out_36 = y_index_32 * y_elems_6 + x_inde",
                   "x_31;\n    \n    if (slt32(x_index_31, y_elems_6) && slt32(y_index_32, x_elems_5)) {\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                       index_out_36)] = ((__local\n                                                          float *) block_9)[sext_i32_i64(get_local_id_0_38 *\n                                                                            17 +\n                                                                            get_local_id_1_39)];\n    }\n    \n  error_0:\n    return;\n}\n__kernel void gpu_map_transpose_f32_small(__local volatile\n                                          int64_t *block_9_backing_aligned_0,\n                                          int32_t destoffset_1,\n                                          int32_t srcoffset_3,\n                                          int32_t num_arrays_4,\n                                          int32_t x_elems_5, int32_t y_elems_6,\n                                          int32_t mulx_7, int32_t muly_8,\n                                          __global unsigned char *destmem_0,\n                                          __global unsigned char *srcmem_2)\n{\n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict block_9_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) block_9_backing_aligned_0;\n    __local unsigned char *block_9;\n    \n    block_9 = (__local unsigned char *) block_9_backing_0;\n    \n    int32_t get_global_id_0_37;\n    \n    get_global_id_0_37 = get_global_id(0);\n    \n    int32_t get_local_id_0_38;\n    \n    get_local_id_0_38 = get_local_id(0);\n    \n    int32_t get_local_id_1_39;\n    \n    get_local_id_1_39 = get_local_id(1);\n    \n    int32_t get_group_id_0_40;\n    \n    get_group_id_0_40 = get_group_id(0);\n    \n    int32_t get_group_id_1_41;\n    \n    get_group_id_1_41 = get_group_id(1);\n    \n    int32_t get",
                   "_group_id_2_42;\n    \n    get_group_id_2_42 = get_group_id(2);\n    \n    int32_t our_array_offset_30 = squot32(get_global_id_0_37, y_elems_6 *\n                                          x_elems_5) * (y_elems_6 * x_elems_5);\n    int32_t x_index_31 = squot32(srem32(get_global_id_0_37, y_elems_6 *\n                                        x_elems_5), y_elems_6);\n    int32_t y_index_32 = srem32(get_global_id_0_37, y_elems_6);\n    int32_t odata_offset_33 = squot32(destoffset_1, 4) + our_array_offset_30;\n    int32_t idata_offset_34 = squot32(srcoffset_3, 4) + our_array_offset_30;\n    int32_t index_in_35 = y_index_32 * x_elems_5 + x_index_31;\n    int32_t index_out_36 = x_index_31 * y_elems_6 + y_index_32;\n    \n    if (slt32(get_global_id_0_37, x_elems_5 * y_elems_6 * num_arrays_4)) {\n        ((__global float *) destmem_0)[sext_i32_i64(odata_offset_33 +\n                                       index_out_36)] = ((__global\n                                                          float *) srcmem_2)[sext_i32_i64(idata_offset_34 +\n                                                                             index_in_35)];\n    }\n    \n  error_0:\n    return;\n}\n__kernel void mainzisegmap_19201(__global int *global_failure,\n                                 int64_t noise_2d_arg_18506,\n                                 double noise_2d_arg_18509, __global\n                                 unsigned char *mem_20292, __global\n                                 unsigned char *mem_20297)\n{\n    #define segmap_group_sizze_19288 (mainzisegmap_group_sizze_19204)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20617;\n    int32_t local_tid_20618;\n    int64_t group_sizze_20621;\n    int32_t wave_sizze_20620;\n    int32_t group_tid_20619;\n    \n    global_tid_20617 = get_global_id(0);\n    local_tid_20618 = get_local_id(0);\n    group_sizze_20621 = get_local_size(0);\n    wave_sizze_20620 = L",
                   "OCKSTEP_WIDTH;\n    group_tid_20619 = get_group_id(0);\n    \n    int32_t phys_tid_19201 = global_tid_20617;\n    int64_t global_tid_20622 = sext_i32_i64(group_tid_20619) *\n            segmap_group_sizze_19288 + sext_i32_i64(local_tid_20618);\n    int64_t slice_20623 = noise_2d_arg_18506;\n    int64_t slice_20624 = noise_2d_arg_18506 * slice_20623;\n    int64_t gtid_19199 = squot64(global_tid_20622, slice_20623);\n    int64_t remnant_20625 = global_tid_20622 - gtid_19199 * slice_20623;\n    int64_t gtid_19200 = remnant_20625;\n    int64_t remnant_20626 = remnant_20625 - gtid_19200;\n    \n    if (slt64(gtid_19199, noise_2d_arg_18506) && slt64(gtid_19200,\n                                                       noise_2d_arg_18506)) {\n        int32_t unsign_arg_19291 = ((__global int32_t *) mem_20292)[gtid_19199];\n        int32_t i64_res_19293 = sext_i64_i32(gtid_19200);\n        int32_t x_19294 = lshr32(i64_res_19293, 16);\n        int32_t x_19295 = i64_res_19293 ^ x_19294;\n        int32_t x_19296 = mul32(73244475, x_19295);\n        int32_t x_19297 = lshr32(x_19296, 16);\n        int32_t x_19298 = x_19296 ^ x_19297;\n        int32_t x_19299 = mul32(73244475, x_19298);\n        int32_t x_19300 = lshr32(x_19299, 16);\n        int32_t x_19301 = x_19299 ^ x_19300;\n        int32_t unsign_arg_19302 = unsign_arg_19291 ^ x_19301;\n        int32_t unsign_arg_19303 = mul32(48271, unsign_arg_19302);\n        int32_t unsign_arg_19304 = umod32(unsign_arg_19303, 2147483647);\n        double u64_res_19305 = uitofp_i32_f64(unsign_arg_19304);\n        double zs_res_19306 = u64_res_19305 / 2.147483647e9;\n        double zt_res_19307 = noise_2d_arg_18509 * zs_res_19306;\n        \n        ((__global double *) mem_20297)[gtid_19199 * noise_2d_arg_18506 +\n                                        gtid_19200] = zt_res_19307;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19288\n}\n__kernel void mainzisegmap_19247(__global int *global_failure,\n                                 int64_t noise_2d_arg_18506,",
                   "\n                                 int32_t unsign_arg_18511, __global\n                                 unsigned char *mem_20292)\n{\n    #define segmap_group_sizze_19266 (mainzisegmap_group_sizze_19249)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20609;\n    int32_t local_tid_20610;\n    int64_t group_sizze_20613;\n    int32_t wave_sizze_20612;\n    int32_t group_tid_20611;\n    \n    global_tid_20609 = get_global_id(0);\n    local_tid_20610 = get_local_id(0);\n    group_sizze_20613 = get_local_size(0);\n    wave_sizze_20612 = LOCKSTEP_WIDTH;\n    group_tid_20611 = get_group_id(0);\n    \n    int32_t phys_tid_19247 = global_tid_20609;\n    int64_t global_tid_20614 = sext_i32_i64(group_tid_20611) *\n            segmap_group_sizze_19266 + sext_i32_i64(local_tid_20610);\n    int64_t slice_20615 = noise_2d_arg_18506;\n    int64_t gtid_19246 = global_tid_20614;\n    int64_t remnant_20616 = global_tid_20614 - gtid_19246;\n    \n    if (slt64(gtid_19246, noise_2d_arg_18506)) {\n        int32_t i64_res_19270 = sext_i64_i32(gtid_19246);\n        int32_t x_19271 = lshr32(i64_res_19270, 16);\n        int32_t x_19272 = i64_res_19270 ^ x_19271;\n        int32_t x_19273 = mul32(73244475, x_19272);\n        int32_t x_19274 = lshr32(x_19273, 16);\n        int32_t x_19275 = x_19273 ^ x_19274;\n        int32_t x_19276 = mul32(73244475, x_19275);\n        int32_t x_19277 = lshr32(x_19276, 16);\n        int32_t x_19278 = x_19276 ^ x_19277;\n        int32_t unsign_arg_19279 = unsign_arg_18511 ^ x_19278;\n        int32_t unsign_arg_19280 = mul32(48271, unsign_arg_19279);\n        int32_t unsign_arg_19281 = umod32(unsign_arg_19280, 2147483647);\n        \n        ((__global int32_t *) mem_20292)[gtid_19246] = unsign_arg_19281;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19266\n}\n__kernel void mainzisegmap_19333(__global int *global_failure,\n                                 int6",
                   "4_t defunc_0_f_res_18501,\n                                 double i64_res_18502,\n                                 int64_t noise_2d_arg_18506, __global\n                                 unsigned char *mem_20297, __global\n                                 unsigned char *mem_20303)\n{\n    #define segmap_group_sizze_19389 (mainzisegmap_group_sizze_19337)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20627;\n    int32_t local_tid_20628;\n    int64_t group_sizze_20631;\n    int32_t wave_sizze_20630;\n    int32_t group_tid_20629;\n    \n    global_tid_20627 = get_global_id(0);\n    local_tid_20628 = get_local_id(0);\n    group_sizze_20631 = get_local_size(0);\n    wave_sizze_20630 = LOCKSTEP_WIDTH;\n    group_tid_20629 = get_group_id(0);\n    \n    int32_t phys_tid_19333 = global_tid_20627;\n    int64_t global_tid_20632 = sext_i32_i64(group_tid_20629) *\n            segmap_group_sizze_19389 + sext_i32_i64(local_tid_20628);\n    int64_t slice_20633 = defunc_0_f_res_18501;\n    int64_t slice_20634 = noise_2d_arg_18506 * slice_20633;\n    int64_t slice_20635 = noise_2d_arg_18506 * slice_20634;\n    int64_t gtid_19330 = squot64(global_tid_20632, slice_20634);\n    int64_t remnant_20636 = global_tid_20632 - gtid_19330 * slice_20634;\n    int64_t gtid_19331 = squot64(remnant_20636, slice_20633);\n    int64_t remnant_20637 = remnant_20636 - gtid_19331 * slice_20633;\n    int64_t gtid_19332 = remnant_20637;\n    int64_t remnant_20638 = remnant_20637 - gtid_19332;\n    \n    if ((slt64(gtid_19330, noise_2d_arg_18506) && slt64(gtid_19331,\n                                                        noise_2d_arg_18506)) &&\n        slt64(gtid_19332, defunc_0_f_res_18501)) {\n        double x_19392 = ((__global double *) mem_20297)[gtid_19330 *\n                                                         noise_2d_arg_18506 +\n                                                         gtid_19331];\n   ",
                   "     int64_t rot_i_19681 = smod64(gtid_19330, noise_2d_arg_18506);\n        int64_t i_p_o_19682 = add64((int64_t) 1, gtid_19331);\n        int64_t rot_i_19683 = smod64(i_p_o_19682, noise_2d_arg_18506);\n        double x_19393 = ((__global double *) mem_20297)[rot_i_19681 *\n                                                         noise_2d_arg_18506 +\n                                                         rot_i_19683];\n        double i64_res_19395 = sitofp_i64_f64(gtid_19332);\n        double defunc_1_f_res_19396 = i64_res_19395 / i64_res_18502;\n        double defunc_0_f_res_19397;\n        \n        defunc_0_f_res_19397 = futrts_lerp64(x_19392, x_19393,\n                                             defunc_1_f_res_19396);\n        ((__global double *) mem_20303)[gtid_19330 * (defunc_0_f_res_18501 *\n                                                      noise_2d_arg_18506) +\n                                        gtid_19331 * defunc_0_f_res_18501 +\n                                        gtid_19332] = defunc_0_f_res_19397;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19389\n}\n__kernel void mainzisegmap_19425(__global int *global_failure,\n                                 int64_t lenX_18471,\n                                 int64_t defunc_0_f_res_18501,\n                                 double i64_res_18502,\n                                 int64_t noise_2d_arg_18506,\n                                 int64_t flat_dim_18552, __global\n                                 unsigned char *mem_20303, __global\n                                 unsigned char *mem_20309)\n{\n    #define segmap_group_sizze_19481 (mainzisegmap_group_sizze_19429)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20639;\n    int32_t local_tid_20640;\n    int64_t group_sizze_20643;\n    int32_t wave_sizze_20642;\n    int32_t group_tid_20641;\n    \n    global_tid_20639 = get_global",
                   "_id(0);\n    local_tid_20640 = get_local_id(0);\n    group_sizze_20643 = get_local_size(0);\n    wave_sizze_20642 = LOCKSTEP_WIDTH;\n    group_tid_20641 = get_group_id(0);\n    \n    int32_t phys_tid_19425 = global_tid_20639;\n    int64_t global_tid_20644 = sext_i32_i64(group_tid_20641) *\n            segmap_group_sizze_19481 + sext_i32_i64(local_tid_20640);\n    int64_t slice_20645 = defunc_0_f_res_18501;\n    int64_t slice_20646 = noise_2d_arg_18506 * slice_20645;\n    int64_t slice_20647 = lenX_18471 * slice_20646;\n    int64_t gtid_19422 = squot64(global_tid_20644, slice_20646);\n    int64_t remnant_20648 = global_tid_20644 - gtid_19422 * slice_20646;\n    int64_t gtid_19423 = squot64(remnant_20648, slice_20645);\n    int64_t remnant_20649 = remnant_20648 - gtid_19423 * slice_20645;\n    int64_t gtid_19424 = remnant_20649;\n    int64_t remnant_20650 = remnant_20649 - gtid_19424;\n    \n    if ((slt64(gtid_19422, lenX_18471) && slt64(gtid_19423,\n                                                noise_2d_arg_18506)) &&\n        slt64(gtid_19424, defunc_0_f_res_18501)) {\n        int64_t binop_x_19729 = lenX_18471 * gtid_19423;\n        int64_t binop_x_19730 = gtid_19422 + binop_x_19729;\n        int64_t new_index_19732 = squot64(binop_x_19730, flat_dim_18552);\n        int64_t binop_y_19740 = flat_dim_18552 * new_index_19732;\n        int64_t binop_x_19741 = binop_x_19730 - binop_y_19740;\n        int64_t new_index_19742 = squot64(binop_x_19741, defunc_0_f_res_18501);\n        int64_t binop_y_19762 = defunc_0_f_res_18501 * new_index_19742;\n        int64_t new_index_19763 = binop_x_19741 - binop_y_19762;\n        double x_19484 = ((__global double *) mem_20303)[new_index_19732 *\n                                                         (defunc_0_f_res_18501 *\n                                                          noise_2d_arg_18506) +\n                                                         new_index_19742 *\n                                                         defunc_0_f_res_18501 +\n     ",
                   "                                                    new_index_19763];\n        int64_t rot_i_19687 = smod64(gtid_19422, lenX_18471);\n        int64_t i_p_o_19688 = add64((int64_t) 1, gtid_19423);\n        int64_t rot_i_19689 = smod64(i_p_o_19688, noise_2d_arg_18506);\n        int64_t binop_x_19764 = lenX_18471 * rot_i_19689;\n        int64_t binop_x_19765 = rot_i_19687 + binop_x_19764;\n        int64_t new_index_19767 = squot64(binop_x_19765, flat_dim_18552);\n        int64_t binop_y_19775 = flat_dim_18552 * new_index_19767;\n        int64_t binop_x_19776 = binop_x_19765 - binop_y_19775;\n        int64_t new_index_19777 = squot64(binop_x_19776, defunc_0_f_res_18501);\n        int64_t binop_y_19797 = defunc_0_f_res_18501 * new_index_19777;\n        int64_t new_index_19798 = binop_x_19776 - binop_y_19797;\n        double x_19485 = ((__global double *) mem_20303)[new_index_19767 *\n                                                         (defunc_0_f_res_18501 *\n                                                          noise_2d_arg_18506) +\n                                                         new_index_19777 *\n                                                         defunc_0_f_res_18501 +\n                                                         new_index_19798];\n        double i64_res_19487 = sitofp_i64_f64(gtid_19424);\n        double defunc_1_f_res_19488 = i64_res_19487 / i64_res_18502;\n        double defunc_0_f_res_19489;\n        \n        defunc_0_f_res_19489 = futrts_lerp64(x_19484, x_19485,\n                                             defunc_1_f_res_19488);\n        ((__global double *) mem_20309)[gtid_19422 * (defunc_0_f_res_18501 *\n                                                      noise_2d_arg_18506) +\n                                        gtid_19423 * defunc_0_f_res_18501 +\n                                        gtid_19424] = defunc_0_f_res_19489;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19481\n}\n__kernel void mainzisegmap_19503(__global int *g",
                   "lobal_failure,\n                                 int64_t lenX_18471,\n                                 int64_t defunc_0_f_res_18501,\n                                 int64_t noise_2d_arg_18506,\n                                 int64_t flat_dim_18552, __global\n                                 unsigned char *mem_param_20286, __global\n                                 unsigned char *mem_20309, __global\n                                 unsigned char *mem_20314)\n{\n    #define segmap_group_sizze_19526 (mainzisegmap_group_sizze_19506)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20651;\n    int32_t local_tid_20652;\n    int64_t group_sizze_20655;\n    int32_t wave_sizze_20654;\n    int32_t group_tid_20653;\n    \n    global_tid_20651 = get_global_id(0);\n    local_tid_20652 = get_local_id(0);\n    group_sizze_20655 = get_local_size(0);\n    wave_sizze_20654 = LOCKSTEP_WIDTH;\n    group_tid_20653 = get_group_id(0);\n    \n    int32_t phys_tid_19503 = global_tid_20651;\n    int64_t global_tid_20656 = sext_i32_i64(group_tid_20653) *\n            segmap_group_sizze_19526 + sext_i32_i64(local_tid_20652);\n    int64_t slice_20657 = lenX_18471;\n    int64_t slice_20658 = lenX_18471 * slice_20657;\n    int64_t gtid_19501 = squot64(global_tid_20656, slice_20657);\n    int64_t remnant_20659 = global_tid_20656 - gtid_19501 * slice_20657;\n    int64_t gtid_19502 = remnant_20659;\n    int64_t remnant_20660 = remnant_20659 - gtid_19502;\n    \n    if (slt64(gtid_19501, lenX_18471) && slt64(gtid_19502, lenX_18471)) {\n        double x_19529 = ((__global double *) mem_param_20286)[gtid_19501 *\n                                                               lenX_18471 +\n                                                               gtid_19502];\n        int64_t binop_x_19690 = lenX_18471 * gtid_19501;\n        int64_t binop_x_19691 = gtid_19502 + binop_x_19690;\n        int64_t new_index_1969",
                   "3 = squot64(binop_x_19691, flat_dim_18552);\n        int64_t binop_y_19701 = flat_dim_18552 * new_index_19693;\n        int64_t binop_x_19702 = binop_x_19691 - binop_y_19701;\n        int64_t new_index_19703 = squot64(binop_x_19702, defunc_0_f_res_18501);\n        int64_t binop_y_19723 = defunc_0_f_res_18501 * new_index_19703;\n        int64_t new_index_19724 = binop_x_19702 - binop_y_19723;\n        double x_19530 = ((__global double *) mem_20309)[new_index_19693 *\n                                                         (defunc_0_f_res_18501 *\n                                                          noise_2d_arg_18506) +\n                                                         new_index_19703 *\n                                                         defunc_0_f_res_18501 +\n                                                         new_index_19724];\n        double defunc_1_f_res_19531 = x_19529 + x_19530;\n        \n        ((__global double *) mem_20314)[gtid_19501 * lenX_18471 + gtid_19502] =\n            defunc_1_f_res_19531;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19526\n}\n__kernel void mainzisegmap_19559(__global int *global_failure,\n                                 int64_t lenX_18471, __global\n                                 unsigned char *mem_20328, __global\n                                 unsigned char *mem_20333)\n{\n    #define segmap_group_sizze_19633 (mainzisegmap_group_sizze_19563)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20671;\n    int32_t local_tid_20672;\n    int64_t group_sizze_20675;\n    int32_t wave_sizze_20674;\n    int32_t group_tid_20673;\n    \n    global_tid_20671 = get_global_id(0);\n    local_tid_20672 = get_local_id(0);\n    group_sizze_20675 = get_local_size(0);\n    wave_sizze_20674 = LOCKSTEP_WIDTH;\n    group_tid_20673 = get_group_id(0);\n    \n    int32_t phys_tid_19559 = global_tid_20671;\n    int64_",
                   "t global_tid_20676 = sext_i32_i64(group_tid_20673) *\n            segmap_group_sizze_19633 + sext_i32_i64(local_tid_20672);\n    int64_t slice_20677 = (int64_t) 3;\n    int64_t slice_20678 = lenX_18471 * slice_20677;\n    int64_t slice_20679 = lenX_18471 * slice_20678;\n    int64_t gtid_19556 = squot64(global_tid_20676, slice_20678);\n    int64_t remnant_20680 = global_tid_20676 - gtid_19556 * slice_20678;\n    int64_t gtid_19557 = squot64(remnant_20680, slice_20677);\n    int64_t remnant_20681 = remnant_20680 - gtid_19557 * slice_20677;\n    int64_t gtid_19558 = remnant_20681;\n    int64_t remnant_20682 = remnant_20681 - gtid_19558;\n    \n    if ((slt64(gtid_19556, lenX_18471) && slt64(gtid_19557, lenX_18471)) &&\n        slt64(gtid_19558, (int64_t) 3)) {\n        int8_t defunc_0_f_res_19636 = ((__global\n                                        int8_t *) mem_20328)[gtid_19556 *\n                                                             lenX_18471 +\n                                                             gtid_19557];\n        \n        ((__global int8_t *) mem_20333)[gtid_19556 * ((int64_t) 3 *\n                                                      lenX_18471) + gtid_19557 *\n                                        (int64_t) 3 + gtid_19558] =\n            defunc_0_f_res_19636;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19633\n}\n__kernel void mainzisegmap_19578(__global int *global_failure,\n                                 int64_t lenX_18471, __global\n                                 unsigned char *ext_mem_20317, __global\n                                 unsigned char *mem_20328)\n{\n    #define segmap_group_sizze_19618 (mainzisegmap_group_sizze_19581)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20661;\n    int32_t local_tid_20662;\n    int64_t group_sizze_20665;\n    int32_t wave_sizze_20664;\n    int32_t group_tid_20663;\n    \n    globa",
                   "l_tid_20661 = get_global_id(0);\n    local_tid_20662 = get_local_id(0);\n    group_sizze_20665 = get_local_size(0);\n    wave_sizze_20664 = LOCKSTEP_WIDTH;\n    group_tid_20663 = get_group_id(0);\n    \n    int32_t phys_tid_19578 = global_tid_20661;\n    int64_t global_tid_20666 = sext_i32_i64(group_tid_20663) *\n            segmap_group_sizze_19618 + sext_i32_i64(local_tid_20662);\n    int64_t slice_20667 = lenX_18471;\n    int64_t slice_20668 = lenX_18471 * slice_20667;\n    int64_t gtid_19576 = squot64(global_tid_20666, slice_20667);\n    int64_t remnant_20669 = global_tid_20666 - gtid_19576 * slice_20667;\n    int64_t gtid_19577 = remnant_20669;\n    int64_t remnant_20670 = remnant_20669 - gtid_19577;\n    \n    if (slt64(gtid_19576, lenX_18471) && slt64(gtid_19577, lenX_18471)) {\n        double x_19621 = ((__global double *) ext_mem_20317)[gtid_19576 *\n                                                             lenX_18471 +\n                                                             gtid_19577];\n        double defunc_0_f_res_19622 = 256.0 * x_19621;\n        int8_t unsign_arg_19623 = fptoui_f64_i8(defunc_0_f_res_19622);\n        int8_t defunc_0_f_res_19624 = sub8(unsign_arg_19623, (int8_t) 1);\n        \n        ((__global int8_t *) mem_20328)[gtid_19576 * lenX_18471 + gtid_19577] =\n            defunc_0_f_res_19624;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19618\n}\n__kernel void matrixAbszisegmap_18682(__global int *global_failure,\n                                      int64_t nz2080U_18346,\n                                      int64_t nz2082U_18347, __global\n                                      unsigned char *as_mem_20275, __global\n                                      unsigned char *mem_20280)\n{\n    #define segmap_group_sizze_18703 (matrixAbszisegmap_group_sizze_18685)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    in",
                   "t32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18682 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18703 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = nz2080U_18346;\n    int64_t slice_20602 = nz2082U_18347 * slice_20601;\n    int64_t gtid_18680 = squot64(global_tid_20600, slice_20601);\n    int64_t remnant_20603 = global_tid_20600 - gtid_18680 * slice_20601;\n    int64_t gtid_18681 = remnant_20603;\n    int64_t remnant_20604 = remnant_20603 - gtid_18681;\n    \n    if (slt64(gtid_18680, nz2082U_18347) && slt64(gtid_18681, nz2080U_18346)) {\n        float x_18706 = ((__global float *) as_mem_20275)[gtid_18680 *\n                                                          nz2080U_18346 +\n                                                          gtid_18681];\n        float defunc_0_f_res_18707 = (float) fabs(x_18706);\n        \n        ((__global float *) mem_20280)[gtid_18680 * nz2080U_18346 +\n                                       gtid_18681] = defunc_0_f_res_18707;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18703\n}\n__kernel void matrixAddzisegmap_18793(__global int *global_failure,\n                                      int64_t i_18371, int64_t j_18372, __global\n                                      unsigned char *A_mem_20275, __global\n                                      unsigned char *B_mem_20276, __global\n                                      unsigned char *mem_20281)\n{\n    #define segmap_group_sizze_18816 (matrixAddzisegmap_group_sizze_18796)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        ret",
                   "urn;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18793 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18816 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = j_18372;\n    int64_t slice_20602 = i_18371 * slice_20601;\n    int64_t gtid_18791 = squot64(global_tid_20600, slice_20601);\n    int64_t remnant_20603 = global_tid_20600 - gtid_18791 * slice_20601;\n    int64_t gtid_18792 = remnant_20603;\n    int64_t remnant_20604 = remnant_20603 - gtid_18792;\n    \n    if (slt64(gtid_18791, i_18371) && slt64(gtid_18792, j_18372)) {\n        float x_18819 = ((__global float *) A_mem_20275)[gtid_18791 * j_18372 +\n                                                         gtid_18792];\n        float x_18820 = ((__global float *) B_mem_20276)[gtid_18791 * j_18372 +\n                                                         gtid_18792];\n        float defunc_1_f_res_18821 = x_18819 + x_18820;\n        \n        ((__global float *) mem_20281)[gtid_18791 * j_18372 + gtid_18792] =\n            defunc_1_f_res_18821;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18816\n}\n__kernel void matrixMatrixMulzisegmap_19054(__global int *global_failure,\n                                            int64_t i_18444, int64_t j_18445,\n                                            int64_t k_18446,\n                                            int64_t num_groups_19073,\n                                            int64_t num_threads_20579, __global\n                                            unsigned char *B_mem_20276, __global\n                                            unsigned char *mem_20279",
                   ", __global\n                                            unsigned char *mem_20298, __global\n                                            unsigned char *color_20548)\n{\n    #define segmap_group_sizze_19072 (matrixMatrixMulzisegmap_group_sizze_19056)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20597;\n    int32_t local_tid_20598;\n    int64_t group_sizze_20601;\n    int32_t wave_sizze_20600;\n    int32_t group_tid_20599;\n    \n    global_tid_20597 = get_global_id(0);\n    local_tid_20598 = get_local_id(0);\n    group_sizze_20601 = get_local_size(0);\n    wave_sizze_20600 = LOCKSTEP_WIDTH;\n    group_tid_20599 = get_group_id(0);\n    \n    int32_t phys_tid_19054 = global_tid_20597;\n    int32_t phys_group_id_20602;\n    \n    phys_group_id_20602 = get_group_id(0);\n    for (int32_t i_20603 = 0; i_20603 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(i_18444, segmap_group_sizze_19072)) -\n                   phys_group_id_20602, sext_i64_i32(num_groups_19073));\n         i_20603++) {\n        int32_t virt_group_id_20604 = phys_group_id_20602 + i_20603 *\n                sext_i64_i32(num_groups_19073);\n        int64_t global_tid_20605 = sext_i32_i64(virt_group_id_20604) *\n                segmap_group_sizze_19072 + sext_i32_i64(local_tid_20598);\n        int64_t slice_20606 = i_18444;\n        int64_t gtid_19053 = global_tid_20605;\n        int64_t remnant_20607 = global_tid_20605 - gtid_19053;\n        \n        if (slt64(gtid_19053, i_18444)) {\n            for (int64_t i_20269 = 0; i_20269 < k_18446; i_20269++) {\n                float defunc_0_f_res_19079;\n                float redout_20271 = 0.0F;\n                \n                for (int64_t i_20272 = 0; i_20272 < j_18445; i_20272++) {\n                    float x_19083 = ((__global float *) mem_20279)[i_20272 *\n                                                                   i_18444 +\n                                    ",
                   "                               gtid_19053];\n                    float x_19084 = ((__global float *) B_mem_20276)[i_20272 *\n                                                                     k_18446 +\n                                                                     i_20269];\n                    float defunc_1_f_res_19085 = x_19083 * x_19084;\n                    float defunc_1_op_res_19082 = defunc_1_f_res_19085 +\n                          redout_20271;\n                    float redout_tmp_20609 = defunc_1_op_res_19082;\n                    \n                    redout_20271 = redout_tmp_20609;\n                }\n                defunc_0_f_res_19079 = redout_20271;\n                ((__global float *) color_20548)[phys_tid_19054 + i_20269 *\n                                                 num_threads_20579] =\n                    defunc_0_f_res_19079;\n            }\n            for (int64_t i_20610 = 0; i_20610 < k_18446; i_20610++) {\n                ((__global float *) mem_20298)[gtid_19053 + i_20610 * i_18444] =\n                    ((__global float *) color_20548)[phys_tid_19054 + i_20610 *\n                                                     num_threads_20579];\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19072\n}\n__kernel void matrixMatrixMulzisegmap_intragroup_19830(__global\n                                                       int *global_failure,\n                                                       __local volatile\n                                                       int64_t *color_20562_backing_aligned_0,\n                                                       __local volatile\n                                                       int64_t *color_20561_backing_aligned_1,\n                                                       int64_t i_18444,\n                                                       int64_t j_18445,\n                                            ",
                   "           int64_t k_18446,\n                                                       int64_t gridDim_x_19824,\n                                                       int64_t gridDim_y_19825,\n                                                       int64_t full_tiles_19855,\n                                                       int64_t kk_20058,\n                                                       __global\n                                                       unsigned char *A_mem_20275,\n                                                       __global\n                                                       unsigned char *B_mem_20276,\n                                                       __global\n                                                       unsigned char *mem_20493)\n{\n    #define Ty_19811 (matrixMatrixMulziTy_19808)\n    #define Ry_19812 (matrixMatrixMulziRy_19810)\n    #define Tx_19813 (matrixMatrixMulziTx_19807)\n    #define Rx_19814 (matrixMatrixMulziRx_19809)\n    #define Tk_19815 (matrixMatrixMulziTk_19806)\n    #define tk_div_tx_19816 (sdiv_up64(matrixMatrixMulziTk_19806, matrixMatrixMulziTx_19807))\n    #define tk_div_ty_19817 (sdiv_up64(matrixMatrixMulziTk_19806, matrixMatrixMulziTy_19808))\n    #define TxRx_19818 (matrixMatrixMulziTx_19807 * matrixMatrixMulziRx_19809)\n    #define TyRy_19819 (matrixMatrixMulziTy_19808 * matrixMatrixMulziRy_19810)\n    #define a_loc_szz_19821 (matrixMatrixMulziTk_19806 * (matrixMatrixMulziTy_19808 * matrixMatrixMulziRy_19810))\n    #define b_loc_szz_19823 (matrixMatrixMulziRx_19809 * (matrixMatrixMulziTx_19807 * matrixMatrixMulziTk_19806))\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict color_20562_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) color_20562_backing_aligned_0;\n    __local volatile unsigned char *restrict color_20561_backing_0 =\n                            ",
                   "       (__local volatile\n                                    unsigned char *) color_20561_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20611;\n    int32_t local_tid_20612;\n    int64_t group_sizze_20615;\n    int32_t wave_sizze_20614;\n    int32_t group_tid_20613;\n    \n    global_tid_20611 = get_global_id(0);\n    local_tid_20612 = get_local_id(0);\n    group_sizze_20615 = get_local_size(0);\n    wave_sizze_20614 = LOCKSTEP_WIDTH;\n    group_tid_20613 = get_group_id(0);\n    \n    int32_t gid_flat_19830 = group_tid_20613;\n    int64_t slice_20618 = Tx_19813;\n    int64_t slice_20619 = Ty_19811 * slice_20618;\n    int64_t ltid_pre_20616 = squot64(sext_i32_i64(local_tid_20612),\n                                     slice_20618);\n    int64_t remnant_20620 = sext_i32_i64(local_tid_20612) - ltid_pre_20616 *\n            slice_20618;\n    int64_t ltid_pre_20617 = remnant_20620;\n    int64_t remnant_20621 = remnant_20620 - ltid_pre_20617;\n    int64_t slice_20622 = gridDim_x_19824;\n    int64_t slice_20623 = gridDim_y_19825 * slice_20622;\n    int64_t gid_y_19829 = squot64(sext_i32_i64(group_tid_20613), slice_20622);\n    int64_t remnant_20624 = sext_i32_i64(group_tid_20613) - gid_y_19829 *\n            slice_20622;\n    int64_t gid_x_19828 = remnant_20624;\n    int64_t remnant_20625 = remnant_20624 - gid_x_19828;\n    float color_20556[Ry_19812 * Rx_19814];\n    float color_20557[Ry_19812 * Rx_19814];\n    float color_20558[Ry_19812 * Rx_19814];\n    float color_20559[Rx_19814];\n    float color_20560[Ry_19812];\n    __local unsigned char *color_20561;\n    \n    color_20561 = (__local unsigned char *) color_20561_backing_0;\n    \n    __local unsigned char *color_20562;\n    \n    color_20562 = (__local unsigned char *) color_20562_backing_1;\n    \n    int64_t iii_19831 = TyRy_19819 * gid_y_19829;\n    int64_t jjj_19832 = TxRx_19818 * gid_x_19828;\n    int64_t ltid_y_19835 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n    int64_t ltid_x_19833 = sext_i32_i64",
                   "(sext_i64_i32(ltid_pre_20617));\n    int32_t ltid_flat_19834 = local_tid_20612;\n    float color_20549[Ry_19812 * Rx_19814];\n    \n    for (int64_t i_19846 = 0; i_19846 < Ry_19812; i_19846++) {\n        for (int64_t i_19849 = 0; i_19849 < Rx_19814; i_19849++) {\n            color_20549[i_19846 * Rx_19814 + i_19849] = 0.0F;\n        }\n    }\n    for (int64_t i_20628 = 0; i_20628 < Ry_19812; i_20628++) {\n        for (int64_t i_20629 = 0; i_20629 < Rx_19814; i_20629++) {\n            color_20558[i_20628 * Rx_19814 + i_20629] = color_20549[i_20628 *\n                                                                    Rx_19814 +\n                                                                    i_20629];\n        }\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    float ext_mem_20408[Ry_19812 * Rx_19814];\n    float mem_param_20319[Ry_19812 * Rx_19814];\n    \n    for (int32_t i_2 = 0; i_2 < Ry_19812 * Rx_19814; i_2++)\n        mem_param_20319[i_2] = color_20558[i_2];\n    for (int64_t i_19856 = 0; i_19856 < full_tiles_19855; i_19856++) {\n        int64_t kk_19860 = Tk_19815 * i_19856;\n        \n        for (int64_t i_19861 = 0; i_19861 < Ry_19812; i_19861++) {\n            int64_t binop_y_19884 = Ty_19811 * i_19861;\n            \n            for (int64_t i_19863 = 0; i_19863 < tk_div_tx_19816; i_19863++) {\n                int64_t binop_y_19882 = Tx_19813 * i_19863;\n                int64_t ltid_x_19865 =\n                        sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n                int64_t ltid_y_19866 =\n                        sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n                int32_t ltid_flat_19867 = local_tid_20612;\n                int64_t k_19883 = ltid_y_19866 + binop_y_19882;\n                int64_t i_19885 = ltid_x_19865 + binop_y_19884;\n                int64_t gtid_19886 = iii_19831 + i_19885;\n                int64_t A_col_idx_19887 = kk_19860 + k_19883;\n                bool cond_19888 = slt64(gtid_19886, i_18444);\n                float A_elem_19889;\n                ",
                   "\n                if (cond_19888) {\n                    float A_elem_19891 = ((__global\n                                           float *) A_mem_20275)[gtid_19886 *\n                                                                 j_18445 +\n                                                                 A_col_idx_19887];\n                    \n                    A_elem_19889 = A_elem_19891;\n                } else {\n                    A_elem_19889 = 0.0F;\n                }\n                \n                bool cond_19893 = slt64(k_19883, Tk_19815);\n                int64_t a_loc_ind_19894;\n                \n                if (cond_19893) {\n                    int64_t binop_y_19895 = Tk_19815 * i_19885;\n                    int64_t loc_fi_19896 = k_19883 + binop_y_19895;\n                    \n                    a_loc_ind_19894 = loc_fi_19896;\n                } else {\n                    a_loc_ind_19894 = (int64_t) -1;\n                }\n                if (sle64((int64_t) 0, a_loc_ind_19894) &&\n                    slt64(a_loc_ind_19894, a_loc_szz_19821)) {\n                    ((__local float *) color_20562)[a_loc_ind_19894] =\n                        A_elem_19889;\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        for (int64_t i_19901 = 0; i_19901 < tk_div_ty_19817; i_19901++) {\n            int64_t binop_y_19922 = Ty_19811 * i_19901;\n            \n            for (int64_t i_19903 = 0; i_19903 < Rx_19814; i_19903++) {\n                int64_t binop_y_19924 = Tx_19813 * i_19903;\n                int64_t ltid_x_19905 =\n                        sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n                int64_t ltid_y_19906 =\n                        sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n                int32_t ltid_flat_19907 = local_tid_20612;\n                int64_t k_19923 = ltid_x_19905 + binop_y_19922;\n                int64_t j_19925 = ltid_y_19906 + binop_y_19924;\n                int64_t gtid_19926 = jjj_19832 + j_19925;\n  ",
                   "              int64_t B_row_idx_19927 = kk_19860 + k_19923;\n                bool cond_19928 = slt64(gtid_19926, k_18446);\n                float B_elem_19929;\n                \n                if (cond_19928) {\n                    float B_elem_19931 = ((__global\n                                           float *) B_mem_20276)[B_row_idx_19927 *\n                                                                 k_18446 +\n                                                                 gtid_19926];\n                    \n                    B_elem_19929 = B_elem_19931;\n                } else {\n                    B_elem_19929 = 0.0F;\n                }\n                \n                bool cond_19933 = slt64(k_19923, Tk_19815);\n                int64_t b_loc_ind_19934;\n                \n                if (cond_19933) {\n                    int64_t binop_y_19935 = TxRx_19818 * k_19923;\n                    int64_t loc_fi_19936 = j_19925 + binop_y_19935;\n                    \n                    b_loc_ind_19934 = loc_fi_19936;\n                } else {\n                    b_loc_ind_19934 = (int64_t) -1;\n                }\n                if (sle64((int64_t) 0, b_loc_ind_19934) &&\n                    slt64(b_loc_ind_19934, b_loc_szz_19823)) {\n                    ((__local float *) color_20561)[b_loc_ind_19934] =\n                        B_elem_19929;\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        for (int64_t i_20638 = 0; i_20638 < Ry_19812; i_20638++) {\n            for (int64_t i_20639 = 0; i_20639 < Rx_19814; i_20639++) {\n                color_20556[i_20638 * Rx_19814 + i_20639] =\n                    mem_param_20319[i_20638 * Rx_19814 + i_20639];\n            }\n        }\n        \n        float ext_mem_20405[Ry_19812 * Rx_19814];\n        float ext_mem_unused_20534[Ry_19812 * Rx_19814];\n        float mem_param_20376[Ry_19812 * Rx_19814];\n        float mem_param_out_20535[Ry_19812 * Rx_19814];\n        \n        for (int32_t i_3 = 0; i_3 < R",
                   "y_19812 * Rx_19814; i_3++)\n            mem_param_20376[i_3] = color_20556[i_3];\n        for (int32_t i_4 = 0; i_4 < Ry_19812 * Rx_19814; i_4++)\n            mem_param_out_20535[i_4] = color_20557[i_4];\n        for (int64_t i_19941 = 0; i_19941 < Tk_19815; i_19941++) {\n            int64_t binop_y_19980 = TxRx_19818 * i_19941;\n            int64_t ltid_y_19945 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n            int64_t ltid_x_19943 = sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n            int32_t ltid_flat_19944 = local_tid_20612;\n            float color_20550[Rx_19814];\n            float color_20551[Ry_19812];\n            int64_t binop_x_19971 = Ry_19812 * ltid_y_19945;\n            \n            for (int64_t i_19969 = 0; i_19969 < Ry_19812; i_19969++) {\n                int64_t binop_x_19972 = i_19969 + binop_x_19971;\n                int64_t binop_y_19973 = Tk_19815 * binop_x_19972;\n                int64_t a_loc_ind_19974 = i_19941 + binop_y_19973;\n                \n                for (int64_t i_20644 = 0; i_20644 < (int64_t) 1; i_20644++) {\n                    color_20551[i_19969 + i_20644] = ((__local\n                                                       float *) color_20562)[a_loc_ind_19974 +\n                                                                             i_20644];\n                }\n            }\n            \n            int64_t binop_y_19982 = Rx_19814 * ltid_x_19943;\n            \n            for (int64_t i_19978 = 0; i_19978 < Rx_19814; i_19978++) {\n                int64_t binop_x_19981 = i_19978 + binop_y_19980;\n                int64_t b_loc_ind_19983 = binop_x_19981 + binop_y_19982;\n                \n                for (int64_t i_20646 = 0; i_20646 < (int64_t) 1; i_20646++) {\n                    color_20550[i_19978 + i_20646] = ((__local\n                                                       float *) color_20561)[b_loc_ind_19983 +\n                                                                             i_20646];\n                }\n          ",
                   "  }\n            for (int64_t i_20647 = 0; i_20647 < Ry_19812; i_20647++) {\n                color_20560[i_20647] = color_20551[i_20647];\n            }\n            for (int64_t i_20648 = 0; i_20648 < Rx_19814; i_20648++) {\n                color_20559[i_20648] = color_20550[i_20648];\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            \n            int64_t ltid_y_19990 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n            int64_t ltid_x_19988 = sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n            int32_t ltid_flat_19989 = local_tid_20612;\n            int64_t binop_y_20031 = Ry_19812 * ltid_y_19990;\n            int64_t binop_y_20035 = Rx_19814 * ltid_x_19988;\n            \n            for (int64_t i_20025 = 0; i_20025 < Ry_19812; i_20025++) {\n                int64_t binop_x_20030 = iii_19831 + i_20025;\n                int64_t cmpop_x_20032 = binop_x_20030 + binop_y_20031;\n                bool binop_x_20033 = slt64(cmpop_x_20032, i_18444);\n                \n                for (int64_t i_20028 = 0; i_20028 < Rx_19814; i_20028++) {\n                    int64_t binop_x_20034 = jjj_19832 + i_20028;\n                    int64_t cmpop_x_20036 = binop_x_20034 + binop_y_20035;\n                    bool binop_y_20037 = slt64(cmpop_x_20036, k_18446);\n                    bool cond_20038 = binop_x_20033 && binop_y_20037;\n                    \n                    if (cond_20038) {\n                        float a_20040 = color_20560[i_20025];\n                        float b_20041 = color_20559[i_20028];\n                        float c_20042 = mem_param_20376[i_20025 * Rx_19814 +\n                                                        i_20028];\n                        float defunc_1_f_res_20045 = a_20040 * b_20041;\n                        float defunc_1_op_res_20049 = c_20042 +\n                              defunc_1_f_res_20045;\n                        \n                        mem_param_20376[i_20025 * Rx_19814 + i_20028] =\n                            defunc_1_op_res_2",
                   "0049;\n                    }\n                }\n            }\n            for (int64_t i_20651 = 0; i_20651 < Ry_19812; i_20651++) {\n                for (int64_t i_20652 = 0; i_20652 < Rx_19814; i_20652++) {\n                    mem_param_out_20535[i_20651 * Rx_19814 + i_20652] =\n                        mem_param_20376[i_20651 * Rx_19814 + i_20652];\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            \n            float mem_param_tmp_20640[Ry_19812 * Rx_19814];\n            \n            for (int32_t i_5 = 0; i_5 < Ry_19812 * Rx_19814; i_5++)\n                mem_param_tmp_20640[i_5] = mem_param_out_20535[i_5];\n            \n            float mem_param_out_tmp_20641[Ry_19812 * Rx_19814];\n            \n            for (int32_t i_6 = 0; i_6 < Ry_19812 * Rx_19814; i_6++)\n                mem_param_out_tmp_20641[i_6] = mem_param_20376[i_6];\n            for (int32_t i_7 = 0; i_7 < Ry_19812 * Rx_19814; i_7++)\n                mem_param_20376[i_7] = mem_param_tmp_20640[i_7];\n            for (int32_t i_8 = 0; i_8 < Ry_19812 * Rx_19814; i_8++)\n                mem_param_out_20535[i_8] = mem_param_out_tmp_20641[i_8];\n        }\n        for (int32_t i_9 = 0; i_9 < Ry_19812 * Rx_19814; i_9++)\n            ext_mem_20405[i_9] = mem_param_20376[i_9];\n        for (int32_t i_10 = 0; i_10 < Ry_19812 * Rx_19814; i_10++)\n            ext_mem_unused_20534[i_10] = mem_param_out_20535[i_10];\n        \n        float mem_param_tmp_20630[Ry_19812 * Rx_19814];\n        \n        for (int32_t i_11 = 0; i_11 < Ry_19812 * Rx_19814; i_11++)\n            mem_param_tmp_20630[i_11] = ext_mem_20405[i_11];\n        for (int32_t i_12 = 0; i_12 < Ry_19812 * Rx_19814; i_12++)\n            mem_param_20319[i_12] = mem_param_tmp_20630[i_12];\n    }\n    for (int32_t i_13 = 0; i_13 < Ry_19812 * Rx_19814; i_13++)\n        ext_mem_20408[i_13] = mem_param_20319[i_13];\n    for (int64_t i_20059 = 0; i_20059 < Ry_19812; i_20059++) {\n        int64_t binop_y_20084 = Ty_19811 * i_20059;\n        \n        for",
                   " (int64_t i_20061 = 0; i_20061 < tk_div_tx_19816; i_20061++) {\n            int64_t binop_y_20082 = Tx_19813 * i_20061;\n            int64_t ltid_x_20063 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n            int64_t ltid_y_20064 = sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n            int32_t ltid_flat_20065 = local_tid_20612;\n            int64_t k_20083 = ltid_y_20064 + binop_y_20082;\n            int64_t i_20085 = ltid_x_20063 + binop_y_20084;\n            int64_t gtid_20086 = iii_19831 + i_20085;\n            int64_t A_col_idx_20087 = kk_20058 + k_20083;\n            bool binop_x_20088 = slt64(gtid_20086, i_18444);\n            bool binop_y_20089 = slt64(A_col_idx_20087, j_18445);\n            bool cond_20090 = binop_x_20088 && binop_y_20089;\n            float A_elem_20091;\n            \n            if (cond_20090) {\n                float A_elem_20093 = ((__global\n                                       float *) A_mem_20275)[gtid_20086 *\n                                                             j_18445 +\n                                                             A_col_idx_20087];\n                \n                A_elem_20091 = A_elem_20093;\n            } else {\n                A_elem_20091 = 0.0F;\n            }\n            \n            bool cond_20095 = slt64(k_20083, Tk_19815);\n            int64_t a_loc_ind_20096;\n            \n            if (cond_20095) {\n                int64_t binop_y_20097 = Tk_19815 * i_20085;\n                int64_t loc_fi_20098 = k_20083 + binop_y_20097;\n                \n                a_loc_ind_20096 = loc_fi_20098;\n            } else {\n                a_loc_ind_20096 = (int64_t) -1;\n            }\n            if (sle64((int64_t) 0, a_loc_ind_20096) && slt64(a_loc_ind_20096,\n                                                             a_loc_szz_19821)) {\n                ((__local float *) color_20562)[a_loc_ind_20096] = A_elem_20091;\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n        }\n    }\n    for (int64_t i_20103 = 0; i_2",
                   "0103 < tk_div_ty_19817; i_20103++) {\n        int64_t binop_y_20126 = Ty_19811 * i_20103;\n        \n        for (int64_t i_20105 = 0; i_20105 < Rx_19814; i_20105++) {\n            int64_t binop_y_20128 = Tx_19813 * i_20105;\n            int64_t ltid_x_20107 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n            int64_t ltid_y_20108 = sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n            int32_t ltid_flat_20109 = local_tid_20612;\n            int64_t k_20127 = ltid_x_20107 + binop_y_20126;\n            int64_t j_20129 = ltid_y_20108 + binop_y_20128;\n            int64_t gtid_20130 = jjj_19832 + j_20129;\n            int64_t B_row_idx_20131 = kk_20058 + k_20127;\n            bool binop_x_20132 = slt64(gtid_20130, k_18446);\n            bool binop_y_20133 = slt64(B_row_idx_20131, j_18445);\n            bool cond_20134 = binop_x_20132 && binop_y_20133;\n            float B_elem_20135;\n            \n            if (cond_20134) {\n                float B_elem_20137 = ((__global\n                                       float *) B_mem_20276)[B_row_idx_20131 *\n                                                             k_18446 +\n                                                             gtid_20130];\n                \n                B_elem_20135 = B_elem_20137;\n            } else {\n                B_elem_20135 = 0.0F;\n            }\n            \n            bool cond_20139 = slt64(k_20127, Tk_19815);\n            int64_t b_loc_ind_20140;\n            \n            if (cond_20139) {\n                int64_t binop_y_20141 = TxRx_19818 * k_20127;\n                int64_t loc_fi_20142 = j_20129 + binop_y_20141;\n                \n                b_loc_ind_20140 = loc_fi_20142;\n            } else {\n                b_loc_ind_20140 = (int64_t) -1;\n            }\n            if (sle64((int64_t) 0, b_loc_ind_20140) && slt64(b_loc_ind_20140,\n                                                             b_loc_szz_19823)) {\n                ((__local float *) color_20561)[b_loc_ind_20140] = B_elem_20135;\n ",
                   "           }\n            barrier(CLK_LOCAL_MEM_FENCE);\n        }\n    }\n    for (int64_t i_20657 = 0; i_20657 < Ry_19812; i_20657++) {\n        for (int64_t i_20658 = 0; i_20658 < Rx_19814; i_20658++) {\n            color_20556[i_20657 * Rx_19814 + i_20658] = ext_mem_20408[i_20657 *\n                                                                      Rx_19814 +\n                                                                      i_20658];\n        }\n    }\n    \n    float ext_mem_20489[Ry_19812 * Rx_19814];\n    float ext_mem_unused_20542[Ry_19812 * Rx_19814];\n    float mem_param_20459[Ry_19812 * Rx_19814];\n    float mem_param_out_20543[Ry_19812 * Rx_19814];\n    \n    for (int32_t i_14 = 0; i_14 < Ry_19812 * Rx_19814; i_14++)\n        mem_param_20459[i_14] = color_20556[i_14];\n    for (int32_t i_15 = 0; i_15 < Ry_19812 * Rx_19814; i_15++)\n        mem_param_out_20543[i_15] = color_20557[i_15];\n    for (int64_t i_20147 = 0; i_20147 < Tk_19815; i_20147++) {\n        int64_t cmpop_x_20149 = kk_20058 + i_20147;\n        bool cond_20150 = slt64(cmpop_x_20149, j_18445);\n        \n        if (cond_20150) {\n            int64_t binop_y_20188 = TxRx_19818 * i_20147;\n            int64_t bytes_20461 = (int64_t) 4 * Ry_19812;\n            int64_t bytes_20463 = (int64_t) 4 * Rx_19814;\n            int64_t ltid_y_20153 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n            int64_t ltid_x_20151 = sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n            int32_t ltid_flat_20152 = local_tid_20612;\n            float color_20552[Rx_19814];\n            float color_20553[Ry_19812];\n            int64_t binop_x_20179 = Ry_19812 * ltid_y_20153;\n            \n            for (int64_t i_20177 = 0; i_20177 < Ry_19812; i_20177++) {\n                int64_t binop_x_20180 = i_20177 + binop_x_20179;\n                int64_t binop_y_20181 = Tk_19815 * binop_x_20180;\n                int64_t a_loc_ind_20182 = i_20147 + binop_y_20181;\n                \n                for (int64_t i_20663 = 0; i_20663 < (int64_t) 1; ",
                   "i_20663++) {\n                    color_20553[i_20177 + i_20663] = ((__local\n                                                       float *) color_20562)[a_loc_ind_20182 +\n                                                                             i_20663];\n                }\n            }\n            \n            int64_t binop_y_20190 = Rx_19814 * ltid_x_20151;\n            \n            for (int64_t i_20186 = 0; i_20186 < Rx_19814; i_20186++) {\n                int64_t binop_x_20189 = i_20186 + binop_y_20188;\n                int64_t b_loc_ind_20191 = binop_x_20189 + binop_y_20190;\n                \n                for (int64_t i_20665 = 0; i_20665 < (int64_t) 1; i_20665++) {\n                    color_20552[i_20186 + i_20665] = ((__local\n                                                       float *) color_20561)[b_loc_ind_20191 +\n                                                                             i_20665];\n                }\n            }\n            for (int64_t i_20666 = 0; i_20666 < Ry_19812; i_20666++) {\n                color_20560[i_20666] = color_20553[i_20666];\n            }\n            for (int64_t i_20667 = 0; i_20667 < Rx_19814; i_20667++) {\n                color_20559[i_20667] = color_20552[i_20667];\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            \n            int64_t ltid_y_20198 = sext_i32_i64(sext_i64_i32(ltid_pre_20616));\n            int64_t ltid_x_20196 = sext_i32_i64(sext_i64_i32(ltid_pre_20617));\n            int32_t ltid_flat_20197 = local_tid_20612;\n            int64_t binop_y_20239 = Ry_19812 * ltid_y_20198;\n            int64_t binop_y_20243 = Rx_19814 * ltid_x_20196;\n            \n            for (int64_t i_20233 = 0; i_20233 < Ry_19812; i_20233++) {\n                int64_t binop_x_20238 = iii_19831 + i_20233;\n                int64_t cmpop_x_20240 = binop_x_20238 + binop_y_20239;\n                bool binop_x_20241 = slt64(cmpop_x_20240, i_18444);\n                \n                for (int64_t i_20236 = 0; i_20236 < Rx_1981",
                   "4; i_20236++) {\n                    int64_t binop_x_20242 = jjj_19832 + i_20236;\n                    int64_t cmpop_x_20244 = binop_x_20242 + binop_y_20243;\n                    bool binop_y_20245 = slt64(cmpop_x_20244, k_18446);\n                    bool cond_20246 = binop_x_20241 && binop_y_20245;\n                    \n                    if (cond_20246) {\n                        float a_20248 = color_20560[i_20233];\n                        float b_20249 = color_20559[i_20236];\n                        float c_20250 = mem_param_20459[i_20233 * Rx_19814 +\n                                                        i_20236];\n                        float defunc_1_f_res_20253 = a_20248 * b_20249;\n                        float defunc_1_op_res_20257 = c_20250 +\n                              defunc_1_f_res_20253;\n                        \n                        mem_param_20459[i_20233 * Rx_19814 + i_20236] =\n                            defunc_1_op_res_20257;\n                    }\n                }\n            }\n            for (int64_t i_20670 = 0; i_20670 < Ry_19812; i_20670++) {\n                for (int64_t i_20671 = 0; i_20671 < Rx_19814; i_20671++) {\n                    color_20558[i_20670 * Rx_19814 + i_20671] =\n                        mem_param_20459[i_20670 * Rx_19814 + i_20671];\n                }\n            }\n            barrier(CLK_LOCAL_MEM_FENCE);\n            for (int64_t i_20672 = 0; i_20672 < Ry_19812; i_20672++) {\n                for (int64_t i_20673 = 0; i_20673 < Rx_19814; i_20673++) {\n                    mem_param_out_20543[i_20672 * Rx_19814 + i_20673] =\n                        color_20558[i_20672 * Rx_19814 + i_20673];\n                }\n            }\n        } else {\n            for (int64_t i_20674 = 0; i_20674 < Ry_19812; i_20674++) {\n                for (int64_t i_20675 = 0; i_20675 < Rx_19814; i_20675++) {\n                    mem_param_out_20543[i_20674 * Rx_19814 + i_20675] =\n                        mem_param_20459[i_20674 * Rx_19814 + i_20675];\n        ",
                   "        }\n            }\n        }\n        \n        float mem_param_tmp_20659[Ry_19812 * Rx_19814];\n        \n        for (int32_t i_16 = 0; i_16 < Ry_19812 * Rx_19814; i_16++)\n            mem_param_tmp_20659[i_16] = mem_param_out_20543[i_16];\n        \n        float mem_param_out_tmp_20660[Ry_19812 * Rx_19814];\n        \n        for (int32_t i_17 = 0; i_17 < Ry_19812 * Rx_19814; i_17++)\n            mem_param_out_tmp_20660[i_17] = mem_param_20459[i_17];\n        for (int32_t i_18 = 0; i_18 < Ry_19812 * Rx_19814; i_18++)\n            mem_param_20459[i_18] = mem_param_tmp_20659[i_18];\n        for (int32_t i_19 = 0; i_19 < Ry_19812 * Rx_19814; i_19++)\n            mem_param_out_20543[i_19] = mem_param_out_tmp_20660[i_19];\n    }\n    for (int32_t i_20 = 0; i_20 < Ry_19812 * Rx_19814; i_20++)\n        ext_mem_20489[i_20] = mem_param_20459[i_20];\n    for (int32_t i_21 = 0; i_21 < Ry_19812 * Rx_19814; i_21++)\n        ext_mem_unused_20542[i_21] = mem_param_out_20543[i_21];\n    \n    int64_t slice_20678 = Tx_19813;\n    int64_t slice_20679 = Ty_19811 * slice_20678;\n    int64_t reg_tile_i_20676 = squot64(sext_i32_i64(local_tid_20612),\n                                       slice_20678);\n    int64_t remnant_20680 = sext_i32_i64(local_tid_20612) - reg_tile_i_20676 *\n            slice_20678;\n    int64_t reg_tile_i_20677 = remnant_20680;\n    int64_t remnant_20681 = remnant_20680 - reg_tile_i_20677;\n    int64_t tile_dim_start_20682 = Ry_19812 * (Ty_19811 * gid_y_19829 +\n                                               reg_tile_i_20676);\n    int64_t tile_dim_start_20683 = Rx_19814 * (Tx_19813 * gid_x_19828 +\n                                               reg_tile_i_20677);\n    \n    for (int64_t nest_i_20684 = 0; nest_i_20684 < Ry_19812; nest_i_20684++) {\n        for (int64_t nest_i_20685 = 0; nest_i_20685 < Rx_19814;\n             nest_i_20685++) {\n            if (slt64(tile_dim_start_20682 + nest_i_20684, i_18444) &&\n                slt64(tile_dim_start_20683 + nest_i_20685, k_18446)) {\n       ",
                   "         ((__global float *) mem_20493)[(tile_dim_start_20682 +\n                                                nest_i_20684) * k_18446 +\n                                               (tile_dim_start_20683 +\n                                                nest_i_20685)] =\n                    ext_mem_20489[nest_i_20684 * Rx_19814 + nest_i_20685];\n            }\n        }\n    }\n    \n  error_9:\n    return;\n    #undef Ty_19811\n    #undef Ry_19812\n    #undef Tx_19813\n    #undef Rx_19814\n    #undef Tk_19815\n    #undef tk_div_tx_19816\n    #undef tk_div_ty_19817\n    #undef TxRx_19818\n    #undef TyRy_19819\n    #undef a_loc_szz_19821\n    #undef b_loc_szz_19823\n}\n__kernel void matrixMatrixMulzisegred_large_19118(__global int *global_failure,\n                                                  __local volatile\n                                                  int64_t *sync_arr_mem_20727_backing_aligned_0,\n                                                  __local volatile\n                                                  int64_t *red_arr_mem_20725_backing_aligned_1,\n                                                  int64_t i_18444,\n                                                  int64_t j_18445,\n                                                  int64_t k_18446,\n                                                  int64_t num_groups_19165,\n                                                  int64_t groups_per_segment_20711,\n                                                  int64_t elements_per_thread_20712,\n                                                  int64_t virt_num_groups_20713,\n                                                  int64_t threads_per_segment_20715,\n                                                  __global\n                                                  unsigned char *A_mem_20275,\n                                                  __global\n                                                  unsigned char *mem_20496,\n                                                ",
                   "  __global\n                                                  unsigned char *mem_20501,\n                                                  __global\n                                                  unsigned char *segred_tmp_mem_20716,\n                                                  __global\n                                                  unsigned char *matrixMatrixMulzicounter_mem_20718)\n{\n    #define segred_group_sizze_19164 (matrixMatrixMulzisegred_group_sizze_19112)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict sync_arr_mem_20727_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) sync_arr_mem_20727_backing_aligned_0;\n    __local volatile unsigned char *restrict red_arr_mem_20725_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20725_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20720;\n    int32_t local_tid_20721;\n    int64_t group_sizze_20724;\n    int32_t wave_sizze_20723;\n    int32_t group_tid_20722;\n    \n    global_tid_20720 = get_global_id(0);\n    local_tid_20721 = get_local_id(0);\n    group_sizze_20724 = get_local_size(0);\n    wave_sizze_20723 = LOCKSTEP_WIDTH;\n    group_tid_20722 = get_group_id(0);\n    \n    int32_t phys_tid_19118 = global_tid_20720;\n    __local unsigned char *red_arr_mem_20725;\n    \n    red_arr_mem_20725 = (__local unsigned char *) red_arr_mem_20725_backing_0;\n    \n    __local unsigned char *sync_arr_mem_20727;\n    \n    sync_arr_mem_20727 = (__local unsigned char *) sync_arr_mem_20727_backing_1;\n    \n    int32_t phys_group_id_20729;\n    \n    phys_group_id_20729 = get_group_id(0);\n    for (int32_t i_20730 = 0; i_20730 <\n         sdiv_up32(sext_i64_i32(virt_num_groups_20713) - phys_group_id_20729,\n                   sext_i64_i32(num_groups_19165)); i_20",
                   "730++) {\n        int32_t virt_group_id_20731 = phys_group_id_20729 + i_20730 *\n                sext_i64_i32(num_groups_19165);\n        int32_t flat_segment_id_20732 = squot32(virt_group_id_20731,\n                                                sext_i64_i32(groups_per_segment_20711));\n        int64_t global_tid_20733 = srem64(sext_i32_i64(virt_group_id_20731) *\n                                          segred_group_sizze_19164 +\n                                          sext_i32_i64(local_tid_20721),\n                                          segred_group_sizze_19164 *\n                                          groups_per_segment_20711);\n        int64_t slice_20734 = k_18446;\n        int64_t slice_20735 = i_18444 * slice_20734;\n        int64_t gtid_19107 = squot64(sext_i32_i64(flat_segment_id_20732),\n                                     slice_20734);\n        int64_t remnant_20736 = sext_i32_i64(flat_segment_id_20732) -\n                gtid_19107 * slice_20734;\n        int64_t gtid_19108 = remnant_20736;\n        int64_t remnant_20737 = remnant_20736 - gtid_19108;\n        int64_t gtid_19117;\n        float x_acc_20738;\n        int64_t chunk_sizze_20739 = smin64(elements_per_thread_20712,\n                                           sdiv_up64(j_18445 - global_tid_20733,\n                                                     threads_per_segment_20715));\n        float x_19168;\n        float x_19169;\n        \n        // neutral-initialise the accumulators\n        {\n            x_acc_20738 = 0.0F;\n        }\n        for (int64_t i_20743 = 0; i_20743 < chunk_sizze_20739; i_20743++) {\n            gtid_19117 = global_tid_20733 + threads_per_segment_20715 * i_20743;\n            // apply map function\n            {\n                float x_19173 = ((__global float *) A_mem_20275)[gtid_19107 *\n                                                                 j_18445 +\n                                                                 gtid_19117];\n                float x_19174 = ((__global flo",
                   "at *) mem_20496)[gtid_19108 *\n                                                               j_18445 +\n                                                               gtid_19117];\n                float defunc_1_f_res_19175 = x_19173 * x_19174;\n                \n                // save map-out results\n                { }\n                // load accumulator\n                {\n                    x_19168 = x_acc_20738;\n                }\n                // load new values\n                {\n                    x_19169 = defunc_1_f_res_19175;\n                }\n                // apply reduction operator\n                {\n                    float defunc_1_op_res_19170 = x_19168 + x_19169;\n                    \n                    // store in accumulator\n                    {\n                        x_acc_20738 = defunc_1_op_res_19170;\n                    }\n                }\n            }\n        }\n        // to reduce current chunk, first store our result in memory\n        {\n            x_19168 = x_acc_20738;\n            ((__local\n              float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721)] =\n                x_19168;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int32_t offset_20744;\n        int32_t skip_waves_20745 = 1;\n        float x_20740;\n        float x_20741;\n        \n        offset_20744 = 0;\n        // participating threads read initial accumulator\n        {\n            if (slt32(local_tid_20721,\n                      sext_i64_i32(segred_group_sizze_19164))) {\n                x_20740 = ((__local\n                            float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721 +\n                                                        offset_20744)];\n            }\n        }\n        offset_20744 = 1;\n        while (slt32(offset_20744, wave_sizze_20723)) {\n            if (slt32(local_tid_20721 + offset_20744,\n                      sext_i64_i32(segred_group_sizze_19164)) &&\n                ((local_tid_20721 - squot32(local_tid_20721, wave",
                   "_sizze_20723) *\n                  wave_sizze_20723) & (2 * offset_20744 - 1)) == 0) {\n                // read array element\n                {\n                    x_20741 = ((volatile __local\n                                float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721 +\n                                                            offset_20744)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_1_op_res_20742 = x_20740 + x_20741;\n                    \n                    x_20740 = defunc_1_op_res_20742;\n                }\n                // write result of operation\n                {\n                    ((volatile __local\n                      float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721)] =\n                        x_20740;\n                }\n            }\n            offset_20744 *= 2;\n        }\n        while (slt32(skip_waves_20745,\n                     squot32(sext_i64_i32(segred_group_sizze_19164) +\n                             wave_sizze_20723 - 1, wave_sizze_20723))) {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            offset_20744 = skip_waves_20745 * wave_sizze_20723;\n            if (slt32(local_tid_20721 + offset_20744,\n                      sext_i64_i32(segred_group_sizze_19164)) &&\n                ((local_tid_20721 - squot32(local_tid_20721, wave_sizze_20723) *\n                  wave_sizze_20723) == 0 && (squot32(local_tid_20721,\n                                                     wave_sizze_20723) & (2 *\n                                                                          skip_waves_20745 -\n                                                                          1)) ==\n                 0)) {\n                // read array element\n                {\n                    x_20741 = ((__local\n                                float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721 +\n                                                            offset_20744)];\n             ",
                   "   }\n                // apply reduction operation\n                {\n                    float defunc_1_op_res_20742 = x_20740 + x_20741;\n                    \n                    x_20740 = defunc_1_op_res_20742;\n                }\n                // write result of operation\n                {\n                    ((__local\n                      float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721)] =\n                        x_20740;\n                }\n            }\n            skip_waves_20745 *= 2;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // first thread saves the result in accumulator\n        {\n            if (sext_i32_i64(local_tid_20721) == (int64_t) 0) {\n                x_acc_20738 = x_20740;\n            }\n        }\n        if (groups_per_segment_20711 == (int64_t) 1) {\n            // first thread in group saves final result to memory\n            {\n                if (local_tid_20721 == 0) {\n                    ((__global float *) mem_20501)[gtid_19107 * k_18446 +\n                                                   gtid_19108] = x_acc_20738;\n                }\n            }\n        } else {\n            int32_t old_counter_20746;\n            \n            // first thread in group saves group result to global memory\n            {\n                if (local_tid_20721 == 0) {\n                    ((__global\n                      float *) segred_tmp_mem_20716)[sext_i32_i64(virt_group_id_20731)] =\n                        x_acc_20738;\n                    mem_fence_global();\n                    old_counter_20746 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) matrixMatrixMulzicounter_mem_20718)[sext_i32_i64(srem32(flat_segment_id_20732,\n                                                                                                                10240))],\n                                              (int) 1);\n                    ((__local bool *) sync_arr_mem_20727)[(int64_t) 0] =\n",
                   "                        old_counter_20746 == groups_per_segment_20711 -\n                        (int64_t) 1;\n                }\n            }\n            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n            \n            bool is_last_group_20747 = ((__local\n                                         bool *) sync_arr_mem_20727)[(int64_t) 0];\n            \n            if (is_last_group_20747) {\n                if (local_tid_20721 == 0) {\n                    old_counter_20746 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) matrixMatrixMulzicounter_mem_20718)[sext_i32_i64(srem32(flat_segment_id_20732,\n                                                                                                                10240))],\n                                              (int) ((int64_t) 0 -\n                                                     groups_per_segment_20711));\n                }\n                // read in the per-group-results\n                {\n                    int64_t read_per_thread_20748 =\n                            sdiv_up64(groups_per_segment_20711,\n                                      segred_group_sizze_19164);\n                    \n                    x_19168 = 0.0F;\n                    for (int64_t i_20749 = 0; i_20749 < read_per_thread_20748;\n                         i_20749++) {\n                        int64_t group_res_id_20750 =\n                                sext_i32_i64(local_tid_20721) *\n                                read_per_thread_20748 + i_20749;\n                        int64_t index_of_group_res_20751 =\n                                sext_i32_i64(flat_segment_id_20732) *\n                                groups_per_segment_20711 + group_res_id_20750;\n                        \n                        if (slt64(group_res_id_20750,\n                                  groups_per_segment_20711)) {\n                            x_19169 = ((__global\n                    ",
                   "                    float *) segred_tmp_mem_20716)[index_of_group_res_20751];\n                            \n                            float defunc_1_op_res_19170 = x_19168 + x_19169;\n                            \n                            x_19168 = defunc_1_op_res_19170;\n                        }\n                    }\n                }\n                ((__local\n                  float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721)] =\n                    x_19168;\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // reduce the per-group results\n                {\n                    int32_t offset_20752;\n                    int32_t skip_waves_20753 = 1;\n                    float x_20740;\n                    float x_20741;\n                    \n                    offset_20752 = 0;\n                    // participating threads read initial accumulator\n                    {\n                        if (slt32(local_tid_20721,\n                                  sext_i64_i32(segred_group_sizze_19164))) {\n                            x_20740 = ((__local\n                                        float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721 +\n                                                                    offset_20752)];\n                        }\n                    }\n                    offset_20752 = 1;\n                    while (slt32(offset_20752, wave_sizze_20723)) {\n                        if (slt32(local_tid_20721 + offset_20752,\n                                  sext_i64_i32(segred_group_sizze_19164)) &&\n                            ((local_tid_20721 - squot32(local_tid_20721,\n                                                        wave_sizze_20723) *\n                              wave_sizze_20723) & (2 * offset_20752 - 1)) ==\n                            0) {\n                            // read array element\n                            {\n                                x_20741 = ((volatile __local\n                                            f",
                   "loat *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721 +\n                                                                        offset_20752)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_1_op_res_20742 = x_20740 + x_20741;\n                                \n                                x_20740 = defunc_1_op_res_20742;\n                            }\n                            // write result of operation\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721)] =\n                                    x_20740;\n                            }\n                        }\n                        offset_20752 *= 2;\n                    }\n                    while (slt32(skip_waves_20753,\n                                 squot32(sext_i64_i32(segred_group_sizze_19164) +\n                                         wave_sizze_20723 - 1,\n                                         wave_sizze_20723))) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        offset_20752 = skip_waves_20753 * wave_sizze_20723;\n                        if (slt32(local_tid_20721 + offset_20752,\n                                  sext_i64_i32(segred_group_sizze_19164)) &&\n                            ((local_tid_20721 - squot32(local_tid_20721,\n                                                        wave_sizze_20723) *\n                              wave_sizze_20723) == 0 &&\n                             (squot32(local_tid_20721, wave_sizze_20723) & (2 *\n                                                                            skip_waves_20753 -\n                                                                            1)) ==\n                             0)) {\n                            // read array element\n                            {\n                   ",
                   "             x_20741 = ((__local\n                                            float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721 +\n                                                                        offset_20752)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_1_op_res_20742 = x_20740 + x_20741;\n                                \n                                x_20740 = defunc_1_op_res_20742;\n                            }\n                            // write result of operation\n                            {\n                                ((__local\n                                  float *) red_arr_mem_20725)[sext_i32_i64(local_tid_20721)] =\n                                    x_20740;\n                            }\n                        }\n                        skip_waves_20753 *= 2;\n                    }\n                    // and back to memory with the final result\n                    {\n                        if (local_tid_20721 == 0) {\n                            ((__global float *) mem_20501)[gtid_19107 *\n                                                           k_18446 +\n                                                           gtid_19108] =\n                                x_20740;\n                        }\n                    }\n                }\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19164\n}\n__kernel void matrixMatrixMulzisegred_small_19118(__global int *global_failure,\n                                                  __local volatile\n                                                  int64_t *red_arr_mem_20693_backing_aligned_0,\n                                                  int64_t i_18444,\n                                                  int64_t j_18445,\n                                                  int64_t k_184",
                   "46,\n                                                  int64_t num_groups_19165,\n                                                  int64_t segment_sizze_nonzzero_20686,\n                                                  __global\n                                                  unsigned char *A_mem_20275,\n                                                  __global\n                                                  unsigned char *mem_20496,\n                                                  __global\n                                                  unsigned char *mem_20501)\n{\n    #define segred_group_sizze_19164 (matrixMatrixMulzisegred_group_sizze_19112)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_arr_mem_20693_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20693_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20688;\n    int32_t local_tid_20689;\n    int64_t group_sizze_20692;\n    int32_t wave_sizze_20691;\n    int32_t group_tid_20690;\n    \n    global_tid_20688 = get_global_id(0);\n    local_tid_20689 = get_local_id(0);\n    group_sizze_20692 = get_local_size(0);\n    wave_sizze_20691 = LOCKSTEP_WIDTH;\n    group_tid_20690 = get_group_id(0);\n    \n    int32_t phys_tid_19118 = global_tid_20688;\n    __local unsigned char *red_arr_mem_20693;\n    \n    red_arr_mem_20693 = (__local unsigned char *) red_arr_mem_20693_backing_0;\n    \n    int32_t phys_group_id_20695;\n    \n    phys_group_id_20695 = get_group_id(0);\n    for (int32_t i_20696 = 0; i_20696 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(i_18444 * k_18446,\n                                          squot64(segred_group_sizze_19164,\n                                                  segment_sizze_nonzzero_20686))) -\n                   phys_group_id_20695, sext_i64_i32(num_groups_19165));\n         i_20696",
                   "++) {\n        int32_t virt_group_id_20697 = phys_group_id_20695 + i_20696 *\n                sext_i64_i32(num_groups_19165);\n        int64_t slice_20698 = k_18446;\n        int64_t slice_20699 = i_18444 * slice_20698;\n        int64_t gtid_19107 = squot64(squot64(sext_i32_i64(local_tid_20689),\n                                             segment_sizze_nonzzero_20686) +\n                                     sext_i32_i64(virt_group_id_20697) *\n                                     squot64(segred_group_sizze_19164,\n                                             segment_sizze_nonzzero_20686),\n                                     slice_20698);\n        int64_t remnant_20700 = squot64(sext_i32_i64(local_tid_20689),\n                                        segment_sizze_nonzzero_20686) +\n                sext_i32_i64(virt_group_id_20697) *\n                squot64(segred_group_sizze_19164,\n                        segment_sizze_nonzzero_20686) - gtid_19107 *\n                slice_20698;\n        int64_t gtid_19108 = remnant_20700;\n        int64_t remnant_20701 = remnant_20700 - gtid_19108;\n        int64_t gtid_19117 = srem64(sext_i32_i64(local_tid_20689), j_18445);\n        \n        // apply map function if in bounds\n        {\n            if (slt64((int64_t) 0, j_18445) && ((slt64(gtid_19107, i_18444) &&\n                                                 slt64(gtid_19108, k_18446)) &&\n                                                slt64(sext_i32_i64(local_tid_20689),\n                                                      j_18445 *\n                                                      squot64(segred_group_sizze_19164,\n                                                              segment_sizze_nonzzero_20686)))) {\n                float x_19173 = ((__global float *) A_mem_20275)[gtid_19107 *\n                                                                 j_18445 +\n                                                                 gtid_19117];\n                float x_19174 = ((__global float *",
                   ") mem_20496)[gtid_19108 *\n                                                               j_18445 +\n                                                               gtid_19117];\n                float defunc_1_f_res_19175 = x_19173 * x_19174;\n                \n                // save map-out results\n                { }\n                // save results to be reduced\n                {\n                    ((__local\n                      float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)] =\n                        defunc_1_f_res_19175;\n                }\n            } else {\n                ((__local\n                  float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)] =\n                    0.0F;\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (slt64((int64_t) 0, j_18445)) {\n            // perform segmented scan to imitate reduction\n            {\n                float x_19168;\n                float x_19169;\n                float x_20702;\n                float x_20703;\n                bool ltid_in_bounds_20705 = slt64(sext_i32_i64(local_tid_20689),\n                                                  j_18445 *\n                                                  squot64(segred_group_sizze_19164,\n                                                          segment_sizze_nonzzero_20686));\n                int32_t skip_threads_20706;\n                \n                // read input for in-block scan\n                {\n                    if (ltid_in_bounds_20705) {\n                        x_19169 = ((volatile __local\n                                    float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)];\n                        if ((local_tid_20689 - squot32(local_tid_20689, 32) *\n                             32) == 0) {\n                            x_19168 = x_19169;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_207",
                   "06 = 1;\n                    while (slt32(skip_threads_20706, 32)) {\n                        if (sle32(skip_threads_20706, local_tid_20689 -\n                                  squot32(local_tid_20689, 32) * 32) &&\n                            ltid_in_bounds_20705) {\n                            // read operands\n                            {\n                                x_19168 = ((volatile __local\n                                            float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689) -\n                                                                        sext_i32_i64(skip_threads_20706)];\n                            }\n                            // perform operation\n                            {\n                                bool inactive_20707 =\n                                     slt64(srem64(sext_i32_i64(local_tid_20689),\n                                                  j_18445),\n                                           sext_i32_i64(local_tid_20689) -\n                                           sext_i32_i64(local_tid_20689 -\n                                           skip_threads_20706));\n                                \n                                if (inactive_20707) {\n                                    x_19168 = x_19169;\n                                }\n                                if (!inactive_20707) {\n                                    float defunc_1_op_res_19170 = x_19168 +\n                                          x_19169;\n                                    \n                                    x_19168 = defunc_1_op_res_19170;\n                                }\n                            }\n                        }\n                        if (sle32(wave_sizze_20691, skip_threads_20706)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (sle32(skip_threads_20706, local_tid_20689 -\n                                  squot32(local_tid_20689, 32) * 32) &&\n              ",
                   "              ltid_in_bounds_20705) {\n                            // write result\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)] =\n                                    x_19168;\n                                x_19169 = x_19168;\n                            }\n                        }\n                        if (sle32(wave_sizze_20691, skip_threads_20706)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_20706 *= 2;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // last thread of block 'i' writes its result to offset 'i'\n                {\n                    if ((local_tid_20689 - squot32(local_tid_20689, 32) * 32) ==\n                        31 && ltid_in_bounds_20705) {\n                        ((volatile __local\n                          float *) red_arr_mem_20693)[sext_i32_i64(squot32(local_tid_20689,\n                                                                           32))] =\n                            x_19168;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n                {\n                    int32_t skip_threads_20708;\n                    \n                    // read input for in-block scan\n                    {\n                        if (squot32(local_tid_20689, 32) == 0 &&\n                            ltid_in_bounds_20705) {\n                            x_20703 = ((volatile __local\n                                        float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)];\n                            if ((local_tid_20689 - squot32(local_tid_20689,\n                                                           32) * 32) == 0) {\n                                x_20702 ",
                   "= x_20703;\n                            }\n                        }\n                    }\n                    // in-block scan (hopefully no barriers needed)\n                    {\n                        skip_threads_20708 = 1;\n                        while (slt32(skip_threads_20708, 32)) {\n                            if (sle32(skip_threads_20708, local_tid_20689 -\n                                      squot32(local_tid_20689, 32) * 32) &&\n                                (squot32(local_tid_20689, 32) == 0 &&\n                                 ltid_in_bounds_20705)) {\n                                // read operands\n                                {\n                                    x_20702 = ((volatile __local\n                                                float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689) -\n                                                                            sext_i32_i64(skip_threads_20708)];\n                                }\n                                // perform operation\n                                {\n                                    bool inactive_20709 =\n                                         slt64(srem64(sext_i32_i64(local_tid_20689 *\n                                                      32 + 32 - 1), j_18445),\n                                               sext_i32_i64(local_tid_20689 *\n                                               32 + 32 - 1) -\n                                               sext_i32_i64((local_tid_20689 -\n                                                             skip_threads_20708) *\n                                               32 + 32 - 1));\n                                    \n                                    if (inactive_20709) {\n                                        x_20702 = x_20703;\n                                    }\n                                    if (!inactive_20709) {\n                                        float defunc_1_op_res_20704 = x_20702 +\n                         ",
                   "                     x_20703;\n                                        \n                                        x_20702 = defunc_1_op_res_20704;\n                                    }\n                                }\n                            }\n                            if (sle32(wave_sizze_20691, skip_threads_20708)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            if (sle32(skip_threads_20708, local_tid_20689 -\n                                      squot32(local_tid_20689, 32) * 32) &&\n                                (squot32(local_tid_20689, 32) == 0 &&\n                                 ltid_in_bounds_20705)) {\n                                // write result\n                                {\n                                    ((volatile __local\n                                      float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)] =\n                                        x_20702;\n                                    x_20703 = x_20702;\n                                }\n                            }\n                            if (sle32(wave_sizze_20691, skip_threads_20708)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            skip_threads_20708 *= 2;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // carry-in for every block except the first\n                {\n                    if (!(squot32(local_tid_20689, 32) == 0 ||\n                          !ltid_in_bounds_20705)) {\n                        // read operands\n                        {\n                            x_19169 = x_19168;\n                            x_19168 = ((__local\n                                        float *) red_arr_mem_20693)[sext_i32_i64(squot32(local_tid_20689,\n                                                                                         32)) -\n     ",
                   "                                                               (int64_t) 1];\n                        }\n                        // perform operation\n                        {\n                            bool inactive_20710 =\n                                 slt64(srem64(sext_i32_i64(local_tid_20689),\n                                              j_18445),\n                                       sext_i32_i64(local_tid_20689) -\n                                       sext_i32_i64(squot32(local_tid_20689,\n                                                            32) * 32 - 1));\n                            \n                            if (inactive_20710) {\n                                x_19168 = x_19169;\n                            }\n                            if (!inactive_20710) {\n                                float defunc_1_op_res_19170 = x_19168 + x_19169;\n                                \n                                x_19168 = defunc_1_op_res_19170;\n                            }\n                        }\n                        // write final result\n                        {\n                            ((__local\n                              float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)] =\n                                x_19168;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // restore correct values for first block\n                {\n                    if (squot32(local_tid_20689, 32) == 0) {\n                        ((__local\n                          float *) red_arr_mem_20693)[sext_i32_i64(local_tid_20689)] =\n                            x_19169;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // save final values of segments\n        {\n            if (slt64(sext_i32_i64(virt_group_id_20697) *\n                      squot64(segred_group_sizze_19164,\n           ",
                   "                   segment_sizze_nonzzero_20686) +\n                      sext_i32_i64(local_tid_20689), i_18444 * k_18446) &&\n                slt64(sext_i32_i64(local_tid_20689),\n                      squot64(segred_group_sizze_19164,\n                              segment_sizze_nonzzero_20686))) {\n                ((__global\n                  float *) mem_20501)[squot64(sext_i32_i64(virt_group_id_20697) *\n                                              squot64(segred_group_sizze_19164,\n                                                      segment_sizze_nonzzero_20686) +\n                                              sext_i32_i64(local_tid_20689),\n                                              k_18446) * k_18446 +\n                                      (sext_i32_i64(virt_group_id_20697) *\n                                       squot64(segred_group_sizze_19164,\n                                               segment_sizze_nonzzero_20686) +\n                                       sext_i32_i64(local_tid_20689) -\n                                       squot64(sext_i32_i64(virt_group_id_20697) *\n                                               squot64(segred_group_sizze_19164,\n                                                       segment_sizze_nonzzero_20686) +\n                                               sext_i32_i64(local_tid_20689),\n                                               k_18446) * k_18446)] = ((__local\n                                                                        float *) red_arr_mem_20693)[(sext_i32_i64(local_tid_20689) +\n                                                                                                     (int64_t) 1) *\n                                                                                                    segment_sizze_nonzzero_20686 -\n                                                                                                    (int64_t) 1];\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        barrier(CLK",
                   "_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19164\n}\n__kernel void matrixMulzisegmap_18873(__global int *global_failure,\n                                      int64_t i_18393, int64_t j_18394, __global\n                                      unsigned char *A_mem_20275, __global\n                                      unsigned char *B_mem_20276, __global\n                                      unsigned char *mem_20281)\n{\n    #define segmap_group_sizze_18896 (matrixMulzisegmap_group_sizze_18876)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18873 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18896 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = j_18394;\n    int64_t slice_20602 = i_18393 * slice_20601;\n    int64_t gtid_18871 = squot64(global_tid_20600, slice_20601);\n    int64_t remnant_20603 = global_tid_20600 - gtid_18871 * slice_20601;\n    int64_t gtid_18872 = remnant_20603;\n    int64_t remnant_20604 = remnant_20603 - gtid_18872;\n    \n    if (slt64(gtid_18871, i_18393) && slt64(gtid_18872, j_18394)) {\n        float x_18899 = ((__global float *) A_mem_20275)[gtid_18871 * j_18394 +\n                                                         gtid_18872];\n        float x_18900 = ((__global float *) B_mem_20276)[gtid_18871 * j_18394 +\n                                                         gtid_18872];\n        float defunc_1_f_res_18901 = x_18899 * x_18900;\n        ",
                   "\n        ((__global float *) mem_20281)[gtid_18871 * j_18394 + gtid_18872] =\n            defunc_1_f_res_18901;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18896\n}\n__kernel void matrixSgnzisegmap_18719(__global int *global_failure,\n                                      int64_t nz2080U_18354,\n                                      int64_t nz2082U_18355, __global\n                                      unsigned char *as_mem_20275, __global\n                                      unsigned char *mem_20280)\n{\n    #define segmap_group_sizze_18740 (matrixSgnzisegmap_group_sizze_18722)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18719 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18740 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = nz2080U_18354;\n    int64_t slice_20602 = nz2082U_18355 * slice_20601;\n    int64_t gtid_18717 = squot64(global_tid_20600, slice_20601);\n    int64_t remnant_20603 = global_tid_20600 - gtid_18717 * slice_20601;\n    int64_t gtid_18718 = remnant_20603;\n    int64_t remnant_20604 = remnant_20603 - gtid_18718;\n    \n    if (slt64(gtid_18717, nz2082U_18355) && slt64(gtid_18718, nz2080U_18354)) {\n        float x_18743 = ((__global float *) as_mem_20275)[gtid_18717 *\n                                                          nz2080U_18354 +\n                                                          gtid_18718];\n        float defunc_0_f_res_18744 = fsignum32(x_18743);\n        \n        ((__g",
                   "lobal float *) mem_20280)[gtid_18717 * nz2080U_18354 +\n                                       gtid_18718] = defunc_0_f_res_18744;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18740\n}\n__kernel void matrixSubzisegmap_18833(__global int *global_failure,\n                                      int64_t i_18382, int64_t j_18383, __global\n                                      unsigned char *A_mem_20275, __global\n                                      unsigned char *B_mem_20276, __global\n                                      unsigned char *mem_20281)\n{\n    #define segmap_group_sizze_18856 (matrixSubzisegmap_group_sizze_18836)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18833 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18856 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = j_18383;\n    int64_t slice_20602 = i_18382 * slice_20601;\n    int64_t gtid_18831 = squot64(global_tid_20600, slice_20601);\n    int64_t remnant_20603 = global_tid_20600 - gtid_18831 * slice_20601;\n    int64_t gtid_18832 = remnant_20603;\n    int64_t remnant_20604 = remnant_20603 - gtid_18832;\n    \n    if (slt64(gtid_18831, i_18382) && slt64(gtid_18832, j_18383)) {\n        float x_18859 = ((__global float *) A_mem_20275)[gtid_18831 * j_18383 +\n                                                         gtid_18832];\n        float x_18860 = ((__global float *) B_mem_20276)[gtid_18831 * j_18383 +\n                                              ",
                   "           gtid_18832];\n        float defunc_1_f_res_18861 = x_18859 - x_18860;\n        \n        ((__global float *) mem_20281)[gtid_18831 * j_18383 + gtid_18832] =\n            defunc_1_f_res_18861;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18856\n}\n__kernel void matrixVectorMulzisegmap_intragroup_19807(__global\n                                                       int *global_failure,\n                                                       __local volatile\n                                                       int64_t *color_20551_backing_aligned_0,\n                                                       int64_t i_18417,\n                                                       int64_t j_18418,\n                                                       int64_t segmap_usable_groups_18951,\n                                                       int64_t num_whole_tiles_19815,\n                                                       int64_t residual_input_19901,\n                                                       unsigned char cond_19902,\n                                                       __global\n                                                       unsigned char *v_mem_20276,\n                                                       __global\n                                                       unsigned char *mem_20279,\n                                                       __global\n                                                       unsigned char *mem_20303)\n{\n    #define segmap_group_sizze_18950 (matrixVectorMulzisegmap_group_sizze_18938)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict color_20551_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) color_20551_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20596;\n    int32_t local_tid_20597;",
                   "\n    int64_t group_sizze_20600;\n    int32_t wave_sizze_20599;\n    int32_t group_tid_20598;\n    \n    global_tid_20596 = get_global_id(0);\n    local_tid_20597 = get_local_id(0);\n    group_sizze_20600 = get_local_size(0);\n    wave_sizze_20599 = LOCKSTEP_WIDTH;\n    group_tid_20598 = get_group_id(0);\n    \n    int32_t gid_flat_19807 = group_tid_20598;\n    int64_t slice_20602 = segmap_group_sizze_18950;\n    int64_t ltid_pre_20601 = sext_i32_i64(local_tid_20597);\n    int64_t remnant_20603 = sext_i32_i64(local_tid_20597) - ltid_pre_20601;\n    int64_t slice_20604 = segmap_usable_groups_18951;\n    int64_t gid_19806 = sext_i32_i64(group_tid_20598);\n    int64_t remnant_20605 = sext_i32_i64(group_tid_20598) - gid_19806;\n    float color_20549[1];\n    float color_20550[1];\n    __local unsigned char *color_20551;\n    \n    color_20551 = (__local unsigned char *) color_20551_backing_0;\n    \n    int64_t ltid_19816 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n    int32_t ltid_flat_19817 = local_tid_20597;\n    \n    color_20550[(int64_t) 0] = 0.0F;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int64_t binop_x_19879 = segmap_group_sizze_18950 * gid_19806;\n    \n    color_20549[(int64_t) 0] = color_20550[(int64_t) 0];\n    \n    float ext_mem_20292[1];\n    float ext_mem_unused_20531[1];\n    float mem_param_20284[1];\n    float mem_param_out_20532[1];\n    \n    for (int32_t i_1 = 0; i_1 < 1; i_1++)\n        mem_param_20284[i_1] = color_20549[i_1];\n    for (int32_t i_2 = 0; i_2 < 1; i_2++)\n        mem_param_out_20532[i_2] = color_20550[i_2];\n    for (int64_t tile_id_19823 = 0; tile_id_19823 < num_whole_tiles_19815;\n         tile_id_19823++) {\n        int64_t binop_x_19869 = segmap_group_sizze_18950 * tile_id_19823;\n        int64_t ltid_19824 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19825 = local_tid_20597;\n        int64_t j_19870 = ltid_19824 + binop_x_19869;\n        bool cond_19874 = slt64(j_19870, j_18418);\n        float pre_19875;\n        \n        if (cond_19874) {\n ",
                   "           float tile_elem_19876 = ((__global float *) v_mem_20276)[j_19870];\n            \n            pre_19875 = tile_elem_19876;\n        } else {\n            pre_19875 = 0.0F;\n        }\n        ((__local float *) color_20551)[ltid_19824] = pre_19875;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int64_t ltid_19843 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19844 = local_tid_20597;\n        int64_t gtid_19880 = ltid_19843 + binop_x_19879;\n        float acc_19882 = mem_param_20284[(int64_t) 0];\n        bool cond_19885 = slt64(gtid_19880, i_18417);\n        float acc_19886;\n        \n        if (cond_19885) {\n            float x_19887;\n            float redout_20267 = acc_19882;\n            \n            for (int64_t i_20268 = 0; i_20268 < segmap_group_sizze_18950;\n                 i_20268++) {\n                float x_19891 = ((__local float *) color_20551)[i_20268];\n                int64_t slice_20273 = binop_x_19869 + i_20268;\n                float x_19892 = ((__global float *) mem_20279)[slice_20273 *\n                                                               i_18417 +\n                                                               gtid_19880];\n                float defunc_1_f_res_19893 = x_19891 * x_19892;\n                float defunc_1_op_res_19890 = defunc_1_f_res_19893 +\n                      redout_20267;\n                float redout_tmp_20609 = defunc_1_op_res_19890;\n                \n                redout_20267 = redout_tmp_20609;\n            }\n            x_19887 = redout_20267;\n            acc_19886 = x_19887;\n        } else {\n            acc_19886 = acc_19882;\n        }\n        mem_param_out_20532[(int64_t) 0] = acc_19886;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        float mem_param_tmp_20606[1];\n        \n        for (int32_t i_3 = 0; i_3 < 1; i_3++)\n            mem_param_tmp_20606[i_3] = mem_param_out_20532[i_3];\n        \n        float mem_param_out_tmp_20607[1];\n        \n        for (int32_t i_4 = 0; i_4 ",
                   "< 1; i_4++)\n            mem_param_out_tmp_20607[i_4] = mem_param_20284[i_4];\n        for (int32_t i_5 = 0; i_5 < 1; i_5++)\n            mem_param_20284[i_5] = mem_param_tmp_20606[i_5];\n        for (int32_t i_6 = 0; i_6 < 1; i_6++)\n            mem_param_out_20532[i_6] = mem_param_out_tmp_20607[i_6];\n    }\n    for (int32_t i_7 = 0; i_7 < 1; i_7++)\n        ext_mem_20292[i_7] = mem_param_20284[i_7];\n    for (int32_t i_8 = 0; i_8 < 1; i_8++)\n        ext_mem_unused_20531[i_8] = mem_param_out_20532[i_8];\n    if (cond_19902) {\n        color_20550[(int64_t) 0] = ext_mem_20292[(int64_t) 0];\n    } else {\n        int64_t binop_x_19912 = segmap_group_sizze_18950 *\n                num_whole_tiles_19815;\n        int64_t ltid_19903 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19904 = local_tid_20597;\n        int64_t j_19913 = ltid_19903 + binop_x_19912;\n        bool cond_19917 = slt64(j_19913, j_18418);\n        float pre_19918;\n        \n        if (cond_19917) {\n            float tile_elem_19919 = ((__global float *) v_mem_20276)[j_19913];\n            \n            pre_19918 = tile_elem_19919;\n        } else {\n            pre_19918 = 0.0F;\n        }\n        ((__local float *) color_20551)[ltid_19903] = pre_19918;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int64_t slice_offset_19936 = num_whole_tiles_19815 *\n                residual_input_19901;\n        int64_t ltid_19923 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19924 = local_tid_20597;\n        int64_t gtid_19933 = binop_x_19879 + ltid_19923;\n        float acc_19935 = ext_mem_20292[(int64_t) 0];\n        bool cond_19938 = slt64(gtid_19933, i_18417);\n        float acc_19939;\n        \n        if (cond_19938) {\n            float x_19940;\n            float redout_20269 = acc_19935;\n            \n            for (int64_t i_20270 = 0; i_20270 < residual_input_19901;\n                 i_20270++) {\n                float x_19944 = ((__local float *) color_20551)[i_20270];\n     ",
                   "           int64_t slice_20274 = slice_offset_19936 + i_20270;\n                float x_19945 = ((__global float *) mem_20279)[slice_20274 *\n                                                               i_18417 +\n                                                               gtid_19933];\n                float defunc_1_f_res_19946 = x_19944 * x_19945;\n                float defunc_1_op_res_19943 = defunc_1_f_res_19946 +\n                      redout_20269;\n                float redout_tmp_20610 = defunc_1_op_res_19943;\n                \n                redout_20269 = redout_tmp_20610;\n            }\n            x_19940 = redout_20269;\n            acc_19939 = x_19940;\n        } else {\n            acc_19939 = acc_19935;\n        }\n        color_20549[(int64_t) 0] = acc_19939;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        color_20550[(int64_t) 0] = color_20549[(int64_t) 0];\n    }\n    if (slt64(sext_i32_i64(local_tid_20597) + segmap_group_sizze_18950 *\n              sext_i32_i64(group_tid_20598), i_18417)) {\n        ((__global float *) mem_20303)[sext_i32_i64(local_tid_20597) +\n                                       segmap_group_sizze_18950 *\n                                       sext_i32_i64(group_tid_20598)] =\n            color_20550[(int64_t) 0];\n    }\n    \n  error_5:\n    return;\n    #undef segmap_group_sizze_18950\n}\n__kernel void matrixVectorMulzisegred_large_18970(__global int *global_failure,\n                                                  __local volatile\n                                                  int64_t *sync_arr_mem_20650_backing_aligned_0,\n                                                  __local volatile\n                                                  int64_t *red_arr_mem_20648_backing_aligned_1,\n                                                  int64_t i_18417,\n                                                  int64_t j_18418,\n                                                  int64_t num_groups_18981,\n                                                  ",
                   "int64_t groups_per_segment_20634,\n                                                  int64_t elements_per_thread_20635,\n                                                  int64_t virt_num_groups_20636,\n                                                  int64_t threads_per_segment_20638,\n                                                  __global\n                                                  unsigned char *M_mem_20275,\n                                                  __global\n                                                  unsigned char *v_mem_20276,\n                                                  __global\n                                                  unsigned char *mem_20307,\n                                                  __global\n                                                  unsigned char *segred_tmp_mem_20639,\n                                                  __global\n                                                  unsigned char *matrixVectorMulzicounter_mem_20641)\n{\n    #define segred_group_sizze_18980 (matrixVectorMulzisegred_group_sizze_18964)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict sync_arr_mem_20650_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) sync_arr_mem_20650_backing_aligned_0;\n    __local volatile unsigned char *restrict red_arr_mem_20648_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20648_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20643;\n    int32_t local_tid_20644;\n    int64_t group_sizze_20647;\n    int32_t wave_sizze_20646;\n    int32_t group_tid_20645;\n    \n    global_tid_20643 = get_global_id(0);\n    local_tid_20644 = get_local_id(0);\n    group_sizze_20647 = get_local_size(0);\n    wave_sizze_20646 = LOCKSTEP_WIDTH;\n    group_ti",
                   "d_20645 = get_group_id(0);\n    \n    int32_t phys_tid_18970 = global_tid_20643;\n    __local unsigned char *red_arr_mem_20648;\n    \n    red_arr_mem_20648 = (__local unsigned char *) red_arr_mem_20648_backing_0;\n    \n    __local unsigned char *sync_arr_mem_20650;\n    \n    sync_arr_mem_20650 = (__local unsigned char *) sync_arr_mem_20650_backing_1;\n    \n    int32_t phys_group_id_20652;\n    \n    phys_group_id_20652 = get_group_id(0);\n    for (int32_t i_20653 = 0; i_20653 <\n         sdiv_up32(sext_i64_i32(virt_num_groups_20636) - phys_group_id_20652,\n                   sext_i64_i32(num_groups_18981)); i_20653++) {\n        int32_t virt_group_id_20654 = phys_group_id_20652 + i_20653 *\n                sext_i64_i32(num_groups_18981);\n        int32_t flat_segment_id_20655 = squot32(virt_group_id_20654,\n                                                sext_i64_i32(groups_per_segment_20634));\n        int64_t global_tid_20656 = srem64(sext_i32_i64(virt_group_id_20654) *\n                                          segred_group_sizze_18980 +\n                                          sext_i32_i64(local_tid_20644),\n                                          segred_group_sizze_18980 *\n                                          groups_per_segment_20634);\n        int64_t slice_20657 = i_18417;\n        int64_t gtid_18961 = sext_i32_i64(flat_segment_id_20655);\n        int64_t remnant_20658 = sext_i32_i64(flat_segment_id_20655) -\n                gtid_18961;\n        int64_t gtid_18969;\n        float x_acc_20659;\n        int64_t chunk_sizze_20660 = smin64(elements_per_thread_20635,\n                                           sdiv_up64(j_18418 - global_tid_20656,\n                                                     threads_per_segment_20638));\n        float x_18984;\n        float x_18985;\n        \n        // neutral-initialise the accumulators\n        {\n            x_acc_20659 = 0.0F;\n        }\n        for (int64_t i_20664 = 0; i_20664 < chunk_sizze_20660; i_20664++) {\n            gtid_18969 = glob",
                   "al_tid_20656 + threads_per_segment_20638 * i_20664;\n            // apply map function\n            {\n                float x_18988 = ((__global float *) v_mem_20276)[gtid_18969];\n                float x_18989 = ((__global float *) M_mem_20275)[gtid_18961 *\n                                                                 j_18418 +\n                                                                 gtid_18969];\n                float defunc_1_f_res_18990 = x_18988 * x_18989;\n                \n                // save map-out results\n                { }\n                // load accumulator\n                {\n                    x_18984 = x_acc_20659;\n                }\n                // load new values\n                {\n                    x_18985 = defunc_1_f_res_18990;\n                }\n                // apply reduction operator\n                {\n                    float defunc_1_op_res_18986 = x_18984 + x_18985;\n                    \n                    // store in accumulator\n                    {\n                        x_acc_20659 = defunc_1_op_res_18986;\n                    }\n                }\n            }\n        }\n        // to reduce current chunk, first store our result in memory\n        {\n            x_18984 = x_acc_20659;\n            ((__local\n              float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                x_18984;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int32_t offset_20665;\n        int32_t skip_waves_20666 = 1;\n        float x_20661;\n        float x_20662;\n        \n        offset_20665 = 0;\n        // participating threads read initial accumulator\n        {\n            if (slt32(local_tid_20644,\n                      sext_i64_i32(segred_group_sizze_18980))) {\n                x_20661 = ((__local\n                            float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                        offset_20665)];\n            }\n        }\n        offset_20665 = 1;\n        wh",
                   "ile (slt32(offset_20665, wave_sizze_20646)) {\n            if (slt32(local_tid_20644 + offset_20665,\n                      sext_i64_i32(segred_group_sizze_18980)) &&\n                ((local_tid_20644 - squot32(local_tid_20644, wave_sizze_20646) *\n                  wave_sizze_20646) & (2 * offset_20665 - 1)) == 0) {\n                // read array element\n                {\n                    x_20662 = ((volatile __local\n                                float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                            offset_20665)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_1_op_res_20663 = x_20661 + x_20662;\n                    \n                    x_20661 = defunc_1_op_res_20663;\n                }\n                // write result of operation\n                {\n                    ((volatile __local\n                      float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                        x_20661;\n                }\n            }\n            offset_20665 *= 2;\n        }\n        while (slt32(skip_waves_20666,\n                     squot32(sext_i64_i32(segred_group_sizze_18980) +\n                             wave_sizze_20646 - 1, wave_sizze_20646))) {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            offset_20665 = skip_waves_20666 * wave_sizze_20646;\n            if (slt32(local_tid_20644 + offset_20665,\n                      sext_i64_i32(segred_group_sizze_18980)) &&\n                ((local_tid_20644 - squot32(local_tid_20644, wave_sizze_20646) *\n                  wave_sizze_20646) == 0 && (squot32(local_tid_20644,\n                                                     wave_sizze_20646) & (2 *\n                                                                          skip_waves_20666 -\n                                                                          1)) ==\n                 0)) {\n                // read array element\n        ",
                   "        {\n                    x_20662 = ((__local\n                                float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                            offset_20665)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_1_op_res_20663 = x_20661 + x_20662;\n                    \n                    x_20661 = defunc_1_op_res_20663;\n                }\n                // write result of operation\n                {\n                    ((__local\n                      float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                        x_20661;\n                }\n            }\n            skip_waves_20666 *= 2;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // first thread saves the result in accumulator\n        {\n            if (sext_i32_i64(local_tid_20644) == (int64_t) 0) {\n                x_acc_20659 = x_20661;\n            }\n        }\n        if (groups_per_segment_20634 == (int64_t) 1) {\n            // first thread in group saves final result to memory\n            {\n                if (local_tid_20644 == 0) {\n                    ((__global float *) mem_20307)[gtid_18961] = x_acc_20659;\n                }\n            }\n        } else {\n            int32_t old_counter_20667;\n            \n            // first thread in group saves group result to global memory\n            {\n                if (local_tid_20644 == 0) {\n                    ((__global\n                      float *) segred_tmp_mem_20639)[sext_i32_i64(virt_group_id_20654)] =\n                        x_acc_20659;\n                    mem_fence_global();\n                    old_counter_20667 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) matrixVectorMulzicounter_mem_20641)[sext_i32_i64(srem32(flat_segment_id_20655,\n                                                                                               ",
                   "                 10240))],\n                                              (int) 1);\n                    ((__local bool *) sync_arr_mem_20650)[(int64_t) 0] =\n                        old_counter_20667 == groups_per_segment_20634 -\n                        (int64_t) 1;\n                }\n            }\n            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n            \n            bool is_last_group_20668 = ((__local\n                                         bool *) sync_arr_mem_20650)[(int64_t) 0];\n            \n            if (is_last_group_20668) {\n                if (local_tid_20644 == 0) {\n                    old_counter_20667 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) matrixVectorMulzicounter_mem_20641)[sext_i32_i64(srem32(flat_segment_id_20655,\n                                                                                                                10240))],\n                                              (int) ((int64_t) 0 -\n                                                     groups_per_segment_20634));\n                }\n                // read in the per-group-results\n                {\n                    int64_t read_per_thread_20669 =\n                            sdiv_up64(groups_per_segment_20634,\n                                      segred_group_sizze_18980);\n                    \n                    x_18984 = 0.0F;\n                    for (int64_t i_20670 = 0; i_20670 < read_per_thread_20669;\n                         i_20670++) {\n                        int64_t group_res_id_20671 =\n                                sext_i32_i64(local_tid_20644) *\n                                read_per_thread_20669 + i_20670;\n                        int64_t index_of_group_res_20672 =\n                                sext_i32_i64(flat_segment_id_20655) *\n                                groups_per_segment_20634 + group_res_id_20671;\n                        \n                        if (sl",
                   "t64(group_res_id_20671,\n                                  groups_per_segment_20634)) {\n                            x_18985 = ((__global\n                                        float *) segred_tmp_mem_20639)[index_of_group_res_20672];\n                            \n                            float defunc_1_op_res_18986 = x_18984 + x_18985;\n                            \n                            x_18984 = defunc_1_op_res_18986;\n                        }\n                    }\n                }\n                ((__local\n                  float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                    x_18984;\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // reduce the per-group results\n                {\n                    int32_t offset_20673;\n                    int32_t skip_waves_20674 = 1;\n                    float x_20661;\n                    float x_20662;\n                    \n                    offset_20673 = 0;\n                    // participating threads read initial accumulator\n                    {\n                        if (slt32(local_tid_20644,\n                                  sext_i64_i32(segred_group_sizze_18980))) {\n                            x_20661 = ((__local\n                                        float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                                    offset_20673)];\n                        }\n                    }\n                    offset_20673 = 1;\n                    while (slt32(offset_20673, wave_sizze_20646)) {\n                        if (slt32(local_tid_20644 + offset_20673,\n                                  sext_i64_i32(segred_group_sizze_18980)) &&\n                            ((local_tid_20644 - squot32(local_tid_20644,\n                                                        wave_sizze_20646) *\n                              wave_sizze_20646) & (2 * offset_20673 - 1)) ==\n                            0) {\n                            //",
                   " read array element\n                            {\n                                x_20662 = ((volatile __local\n                                            float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                                        offset_20673)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_1_op_res_20663 = x_20661 + x_20662;\n                                \n                                x_20661 = defunc_1_op_res_20663;\n                            }\n                            // write result of operation\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                                    x_20661;\n                            }\n                        }\n                        offset_20673 *= 2;\n                    }\n                    while (slt32(skip_waves_20674,\n                                 squot32(sext_i64_i32(segred_group_sizze_18980) +\n                                         wave_sizze_20646 - 1,\n                                         wave_sizze_20646))) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        offset_20673 = skip_waves_20674 * wave_sizze_20646;\n                        if (slt32(local_tid_20644 + offset_20673,\n                                  sext_i64_i32(segred_group_sizze_18980)) &&\n                            ((local_tid_20644 - squot32(local_tid_20644,\n                                                        wave_sizze_20646) *\n                              wave_sizze_20646) == 0 &&\n                             (squot32(local_tid_20644, wave_sizze_20646) & (2 *\n                                                                            skip_waves_20674 -\n                                                             ",
                   "               1)) ==\n                             0)) {\n                            // read array element\n                            {\n                                x_20662 = ((__local\n                                            float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                                        offset_20673)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_1_op_res_20663 = x_20661 + x_20662;\n                                \n                                x_20661 = defunc_1_op_res_20663;\n                            }\n                            // write result of operation\n                            {\n                                ((__local\n                                  float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                                    x_20661;\n                            }\n                        }\n                        skip_waves_20674 *= 2;\n                    }\n                    // and back to memory with the final result\n                    {\n                        if (local_tid_20644 == 0) {\n                            ((__global float *) mem_20307)[gtid_18961] =\n                                x_20661;\n                        }\n                    }\n                }\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_18980\n}\n__kernel void matrixVectorMulzisegred_small_18970(__global int *global_failure,\n                                                  __local volatile\n                                                  int64_t *red_arr_mem_20618_backing_aligned_0,\n                                                  int64_t i_18417,\n                                                  int64_t j_18418,\n                                                ",
                   "  int64_t num_groups_18981,\n                                                  int64_t segment_sizze_nonzzero_20611,\n                                                  __global\n                                                  unsigned char *M_mem_20275,\n                                                  __global\n                                                  unsigned char *v_mem_20276,\n                                                  __global\n                                                  unsigned char *mem_20307)\n{\n    #define segred_group_sizze_18980 (matrixVectorMulzisegred_group_sizze_18964)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_arr_mem_20618_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20618_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20613;\n    int32_t local_tid_20614;\n    int64_t group_sizze_20617;\n    int32_t wave_sizze_20616;\n    int32_t group_tid_20615;\n    \n    global_tid_20613 = get_global_id(0);\n    local_tid_20614 = get_local_id(0);\n    group_sizze_20617 = get_local_size(0);\n    wave_sizze_20616 = LOCKSTEP_WIDTH;\n    group_tid_20615 = get_group_id(0);\n    \n    int32_t phys_tid_18970 = global_tid_20613;\n    __local unsigned char *red_arr_mem_20618;\n    \n    red_arr_mem_20618 = (__local unsigned char *) red_arr_mem_20618_backing_0;\n    \n    int32_t phys_group_id_20620;\n    \n    phys_group_id_20620 = get_group_id(0);\n    for (int32_t i_20621 = 0; i_20621 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(i_18417,\n                                          squot64(segred_group_sizze_18980,\n                                                  segment_sizze_nonzzero_20611))) -\n                   phys_group_id_20620, sext_i64_i32(num_groups_18981));\n         i_20621++) {\n        int32_t virt_group_id_20622 = phys_group_id_20",
                   "620 + i_20621 *\n                sext_i64_i32(num_groups_18981);\n        int64_t slice_20623 = i_18417;\n        int64_t gtid_18961 = squot64(sext_i32_i64(local_tid_20614),\n                                     segment_sizze_nonzzero_20611) +\n                sext_i32_i64(virt_group_id_20622) *\n                squot64(segred_group_sizze_18980, segment_sizze_nonzzero_20611);\n        int64_t remnant_20624 = squot64(sext_i32_i64(local_tid_20614),\n                                        segment_sizze_nonzzero_20611) +\n                sext_i32_i64(virt_group_id_20622) *\n                squot64(segred_group_sizze_18980,\n                        segment_sizze_nonzzero_20611) - gtid_18961;\n        int64_t gtid_18969 = srem64(sext_i32_i64(local_tid_20614), j_18418);\n        \n        // apply map function if in bounds\n        {\n            if (slt64((int64_t) 0, j_18418) && (slt64(gtid_18961, i_18417) &&\n                                                slt64(sext_i32_i64(local_tid_20614),\n                                                      j_18418 *\n                                                      squot64(segred_group_sizze_18980,\n                                                              segment_sizze_nonzzero_20611)))) {\n                float x_18988 = ((__global float *) v_mem_20276)[gtid_18969];\n                float x_18989 = ((__global float *) M_mem_20275)[gtid_18961 *\n                                                                 j_18418 +\n                                                                 gtid_18969];\n                float defunc_1_f_res_18990 = x_18988 * x_18989;\n                \n                // save map-out results\n                { }\n                // save results to be reduced\n                {\n                    ((__local\n                      float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                        defunc_1_f_res_18990;\n                }\n            } else {\n                ((__local\n                  float *",
                   ") red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                    0.0F;\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (slt64((int64_t) 0, j_18418)) {\n            // perform segmented scan to imitate reduction\n            {\n                float x_18984;\n                float x_18985;\n                float x_20625;\n                float x_20626;\n                bool ltid_in_bounds_20628 = slt64(sext_i32_i64(local_tid_20614),\n                                                  j_18418 *\n                                                  squot64(segred_group_sizze_18980,\n                                                          segment_sizze_nonzzero_20611));\n                int32_t skip_threads_20629;\n                \n                // read input for in-block scan\n                {\n                    if (ltid_in_bounds_20628) {\n                        x_18985 = ((volatile __local\n                                    float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)];\n                        if ((local_tid_20614 - squot32(local_tid_20614, 32) *\n                             32) == 0) {\n                            x_18984 = x_18985;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_20629 = 1;\n                    while (slt32(skip_threads_20629, 32)) {\n                        if (sle32(skip_threads_20629, local_tid_20614 -\n                                  squot32(local_tid_20614, 32) * 32) &&\n                            ltid_in_bounds_20628) {\n                            // read operands\n                            {\n                                x_18984 = ((volatile __local\n                                            float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614) -\n                                                                        sext_i32_i64(skip_threads_20629)];\n                  ",
                   "          }\n                            // perform operation\n                            {\n                                bool inactive_20630 =\n                                     slt64(srem64(sext_i32_i64(local_tid_20614),\n                                                  j_18418),\n                                           sext_i32_i64(local_tid_20614) -\n                                           sext_i32_i64(local_tid_20614 -\n                                           skip_threads_20629));\n                                \n                                if (inactive_20630) {\n                                    x_18984 = x_18985;\n                                }\n                                if (!inactive_20630) {\n                                    float defunc_1_op_res_18986 = x_18984 +\n                                          x_18985;\n                                    \n                                    x_18984 = defunc_1_op_res_18986;\n                                }\n                            }\n                        }\n                        if (sle32(wave_sizze_20616, skip_threads_20629)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (sle32(skip_threads_20629, local_tid_20614 -\n                                  squot32(local_tid_20614, 32) * 32) &&\n                            ltid_in_bounds_20628) {\n                            // write result\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                                    x_18984;\n                                x_18985 = x_18984;\n                            }\n                        }\n                        if (sle32(wave_sizze_20616, skip_threads_20629)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_20629 *= 2;\n           ",
                   "         }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // last thread of block 'i' writes its result to offset 'i'\n                {\n                    if ((local_tid_20614 - squot32(local_tid_20614, 32) * 32) ==\n                        31 && ltid_in_bounds_20628) {\n                        ((volatile __local\n                          float *) red_arr_mem_20618)[sext_i32_i64(squot32(local_tid_20614,\n                                                                           32))] =\n                            x_18984;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n                {\n                    int32_t skip_threads_20631;\n                    \n                    // read input for in-block scan\n                    {\n                        if (squot32(local_tid_20614, 32) == 0 &&\n                            ltid_in_bounds_20628) {\n                            x_20626 = ((volatile __local\n                                        float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)];\n                            if ((local_tid_20614 - squot32(local_tid_20614,\n                                                           32) * 32) == 0) {\n                                x_20625 = x_20626;\n                            }\n                        }\n                    }\n                    // in-block scan (hopefully no barriers needed)\n                    {\n                        skip_threads_20631 = 1;\n                        while (slt32(skip_threads_20631, 32)) {\n                            if (sle32(skip_threads_20631, local_tid_20614 -\n                                      squot32(local_tid_20614, 32) * 32) &&\n                                (squot32(local_tid_20614, 32) == 0 &&\n                                 ltid_in_bounds_20628)) {\n                                // read operands\n         ",
                   "                       {\n                                    x_20625 = ((volatile __local\n                                                float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614) -\n                                                                            sext_i32_i64(skip_threads_20631)];\n                                }\n                                // perform operation\n                                {\n                                    bool inactive_20632 =\n                                         slt64(srem64(sext_i32_i64(local_tid_20614 *\n                                                      32 + 32 - 1), j_18418),\n                                               sext_i32_i64(local_tid_20614 *\n                                               32 + 32 - 1) -\n                                               sext_i32_i64((local_tid_20614 -\n                                                             skip_threads_20631) *\n                                               32 + 32 - 1));\n                                    \n                                    if (inactive_20632) {\n                                        x_20625 = x_20626;\n                                    }\n                                    if (!inactive_20632) {\n                                        float defunc_1_op_res_20627 = x_20625 +\n                                              x_20626;\n                                        \n                                        x_20625 = defunc_1_op_res_20627;\n                                    }\n                                }\n                            }\n                            if (sle32(wave_sizze_20616, skip_threads_20631)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            if (sle32(skip_threads_20631, local_tid_20614 -\n                                      squot32(local_tid_20614, 32) * 32) &&\n                                (squot32(local_tid_20614, 32",
                   ") == 0 &&\n                                 ltid_in_bounds_20628)) {\n                                // write result\n                                {\n                                    ((volatile __local\n                                      float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                                        x_20625;\n                                    x_20626 = x_20625;\n                                }\n                            }\n                            if (sle32(wave_sizze_20616, skip_threads_20631)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            skip_threads_20631 *= 2;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // carry-in for every block except the first\n                {\n                    if (!(squot32(local_tid_20614, 32) == 0 ||\n                          !ltid_in_bounds_20628)) {\n                        // read operands\n                        {\n                            x_18985 = x_18984;\n                            x_18984 = ((__local\n                                        float *) red_arr_mem_20618)[sext_i32_i64(squot32(local_tid_20614,\n                                                                                         32)) -\n                                                                    (int64_t) 1];\n                        }\n                        // perform operation\n                        {\n                            bool inactive_20633 =\n                                 slt64(srem64(sext_i32_i64(local_tid_20614),\n                                              j_18418),\n                                       sext_i32_i64(local_tid_20614) -\n                                       sext_i32_i64(squot32(local_tid_20614,\n                                                            32) * 32 - 1));\n                            \n                   ",
                   "         if (inactive_20633) {\n                                x_18984 = x_18985;\n                            }\n                            if (!inactive_20633) {\n                                float defunc_1_op_res_18986 = x_18984 + x_18985;\n                                \n                                x_18984 = defunc_1_op_res_18986;\n                            }\n                        }\n                        // write final result\n                        {\n                            ((__local\n                              float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                                x_18984;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // restore correct values for first block\n                {\n                    if (squot32(local_tid_20614, 32) == 0) {\n                        ((__local\n                          float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                            x_18985;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // save final values of segments\n        {\n            if (slt64(sext_i32_i64(virt_group_id_20622) *\n                      squot64(segred_group_sizze_18980,\n                              segment_sizze_nonzzero_20611) +\n                      sext_i32_i64(local_tid_20614), i_18417) &&\n                slt64(sext_i32_i64(local_tid_20614),\n                      squot64(segred_group_sizze_18980,\n                              segment_sizze_nonzzero_20611))) {\n                ((__global\n                  float *) mem_20307)[sext_i32_i64(virt_group_id_20622) *\n                                      squot64(segred_group_sizze_18980,\n                                              segment_sizze_nonzzero_20611) +\n                                      sext_i32_i64(local_tid_20614)] = ((__local\n        ",
                   "                                                                 float *) red_arr_mem_20618)[(sext_i32_i64(local_tid_20614) +\n                                                                                                      (int64_t) 1) *\n                                                                                                     segment_sizze_nonzzero_20611 -\n                                                                                                     (int64_t) 1];\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_18980\n}\n__kernel void normalizzeVzisegmap_19661(__global int *global_failure,\n                                        int64_t iz2083U_18599, float f_18608,\n                                        __global unsigned char *v_mem_20275,\n                                        __global unsigned char *mem_20282)\n{\n    #define segmap_group_sizze_19669 (normalizzeVzisegmap_group_sizze_19663)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20626;\n    int32_t local_tid_20627;\n    int64_t group_sizze_20630;\n    int32_t wave_sizze_20629;\n    int32_t group_tid_20628;\n    \n    global_tid_20626 = get_global_id(0);\n    local_tid_20627 = get_local_id(0);\n    group_sizze_20630 = get_local_size(0);\n    wave_sizze_20629 = LOCKSTEP_WIDTH;\n    group_tid_20628 = get_group_id(0);\n    \n    int32_t phys_tid_19661 = global_tid_20626;\n    int64_t global_tid_20631 = sext_i32_i64(group_tid_20628) *\n            segmap_group_sizze_19669 + sext_i32_i64(local_tid_20627);\n    int64_t slice_20632 = iz2083U_18599;\n    int64_t gtid_19660 = global_tid_20631;\n    int64_t remnant_20633 = global_tid_20631 - gtid_19660;\n    \n    if (slt64(gtid_19660, iz2083U_18599)) {\n        float x_19672 = ((__global float *) v_mem_202",
                   "75)[gtid_19660];\n        float defunc_0_f_res_19673 = f_18608 * x_19672;\n        \n        ((__global float *) mem_20282)[gtid_19660] = defunc_0_f_res_19673;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_19669\n}\n__kernel void normalizzeVzisegred_nonseg_19659(__global int *global_failure,\n                                               __local volatile\n                                               int64_t *red_arr_mem_20608_backing_aligned_0,\n                                               __local volatile\n                                               int64_t *sync_arr_mem_20606_backing_aligned_1,\n                                               int64_t iz2083U_18599,\n                                               int64_t num_groups_19654,\n                                               int64_t num_threads_20600,\n                                               __global\n                                               unsigned char *v_mem_20275,\n                                               __global\n                                               unsigned char *mem_20278,\n                                               __global\n                                               unsigned char *normalizzeVzicounter_mem_20596,\n                                               __global\n                                               unsigned char *segred_tmp_mem_20598)\n{\n    #define segred_group_sizze_19652 (normalizzeVzisegred_group_sizze_19651)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_arr_mem_20608_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20608_backing_aligned_0;\n    __local volatile unsigned char *restrict sync_arr_mem_20606_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) sync_arr_mem_20606_backing_aligned_1;\n",
                   "    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20601;\n    int32_t local_tid_20602;\n    int64_t group_sizze_20605;\n    int32_t wave_sizze_20604;\n    int32_t group_tid_20603;\n    \n    global_tid_20601 = get_global_id(0);\n    local_tid_20602 = get_local_id(0);\n    group_sizze_20605 = get_local_size(0);\n    wave_sizze_20604 = LOCKSTEP_WIDTH;\n    group_tid_20603 = get_group_id(0);\n    \n    int32_t phys_tid_19659 = global_tid_20601;\n    __local unsigned char *sync_arr_mem_20606;\n    \n    sync_arr_mem_20606 = (__local unsigned char *) sync_arr_mem_20606_backing_0;\n    \n    __local unsigned char *red_arr_mem_20608;\n    \n    red_arr_mem_20608 = (__local unsigned char *) red_arr_mem_20608_backing_1;\n    \n    int64_t dummy_19657 = (int64_t) 0;\n    int64_t gtid_19658 = (int64_t) 0;\n    float x_acc_20610;\n    int64_t chunk_sizze_20611 = smin64(sdiv_up64(iz2083U_18599,\n                                                 sext_i32_i64(sext_i64_i32(segred_group_sizze_19652 *\n                                                 num_groups_19654))),\n                                       sdiv_up64(iz2083U_18599 - phys_tid_19659,\n                                                 num_threads_20600));\n    float x_18602;\n    float x_18603;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_20610 = 0.0F;\n    }\n    for (int64_t i_20615 = 0; i_20615 < chunk_sizze_20611; i_20615++) {\n        gtid_19658 = phys_tid_19659 + num_threads_20600 * i_20615;\n        // apply map function\n        {\n            float x_18605 = ((__global float *) v_mem_20275)[gtid_19658];\n            float defunc_1_f_res_18606 = x_18605 * x_18605;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_18602 = x_acc_20610;\n            }\n            // load new values\n            {\n                x_18603 = defunc_1_f_res_18606;\n            }\n            // apply reduction operator\n            {\n             ",
                   "   float defunc_1_op_res_18604 = x_18602 + x_18603;\n                \n                // store in accumulator\n                {\n                    x_acc_20610 = defunc_1_op_res_18604;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_18602 = x_acc_20610;\n        ((__local float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n            x_18602;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_20616;\n    int32_t skip_waves_20617 = 1;\n    float x_20612;\n    float x_20613;\n    \n    offset_20616 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_20602, sext_i64_i32(segred_group_sizze_19652))) {\n            x_20612 = ((__local\n                        float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                    offset_20616)];\n        }\n    }\n    offset_20616 = 1;\n    while (slt32(offset_20616, wave_sizze_20604)) {\n        if (slt32(local_tid_20602 + offset_20616,\n                  sext_i64_i32(segred_group_sizze_19652)) && ((local_tid_20602 -\n                                                               squot32(local_tid_20602,\n                                                                       wave_sizze_20604) *\n                                                               wave_sizze_20604) &\n                                                              (2 *\n                                                               offset_20616 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_20613 = ((volatile __local\n                            float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                        offset_20616)];\n            }\n            // apply reduction operation\n            {\n                float defunc_1_op_res_20614 = x_206",
                   "12 + x_20613;\n                \n                x_20612 = defunc_1_op_res_20614;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                    x_20612;\n            }\n        }\n        offset_20616 *= 2;\n    }\n    while (slt32(skip_waves_20617,\n                 squot32(sext_i64_i32(segred_group_sizze_19652) +\n                         wave_sizze_20604 - 1, wave_sizze_20604))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_20616 = skip_waves_20617 * wave_sizze_20604;\n        if (slt32(local_tid_20602 + offset_20616,\n                  sext_i64_i32(segred_group_sizze_19652)) && ((local_tid_20602 -\n                                                               squot32(local_tid_20602,\n                                                                       wave_sizze_20604) *\n                                                               wave_sizze_20604) ==\n                                                              0 &&\n                                                              (squot32(local_tid_20602,\n                                                                       wave_sizze_20604) &\n                                                               (2 *\n                                                                skip_waves_20617 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_20613 = ((__local\n                            float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                        offset_20616)];\n            }\n            // apply reduction operation\n            {\n                float defunc_1_op_res_20614 = x_20612 + x_20613;\n                \n                x_20612 = defunc_1_op_res_20614;\n            }\n            // write result of operation\n            {\n   ",
                   "             ((__local\n                  float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                    x_20612;\n            }\n        }\n        skip_waves_20617 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_20602) == (int64_t) 0) {\n            x_acc_20610 = x_20612;\n        }\n    }\n    \n    int32_t old_counter_20618;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_20602 == 0) {\n            ((__global\n              float *) segred_tmp_mem_20598)[sext_i32_i64(group_tid_20603)] =\n                x_acc_20610;\n            mem_fence_global();\n            old_counter_20618 = atomic_add_i32_global(&((volatile __global\n                                                         int *) normalizzeVzicounter_mem_20596)[(int64_t) 0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_20606)[(int64_t) 0] =\n                old_counter_20618 == num_groups_19654 - (int64_t) 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_20619 = ((__local\n                                 bool *) sync_arr_mem_20606)[(int64_t) 0];\n    \n    if (is_last_group_20619) {\n        if (local_tid_20602 == 0) {\n            old_counter_20618 = atomic_add_i32_global(&((volatile __global\n                                                         int *) normalizzeVzicounter_mem_20596)[(int64_t) 0],\n                                                      (int) ((int64_t) 0 -\n                                                             num_groups_19654));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_20620 = sdiv_up64(num_groups_19654,\n                                                      segred_group_sizze_19652);\n            \n            x_18602 = 0.0F;\n            for (int64_t i_20621 = 0; i_20621 < re",
                   "ad_per_thread_20620;\n                 i_20621++) {\n                int64_t group_res_id_20622 = sext_i32_i64(local_tid_20602) *\n                        read_per_thread_20620 + i_20621;\n                int64_t index_of_group_res_20623 = group_res_id_20622;\n                \n                if (slt64(group_res_id_20622, num_groups_19654)) {\n                    x_18603 = ((__global\n                                float *) segred_tmp_mem_20598)[index_of_group_res_20623];\n                    \n                    float defunc_1_op_res_18604 = x_18602 + x_18603;\n                    \n                    x_18602 = defunc_1_op_res_18604;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n            x_18602;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_20624;\n            int32_t skip_waves_20625 = 1;\n            float x_20612;\n            float x_20613;\n            \n            offset_20624 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_20602,\n                          sext_i64_i32(segred_group_sizze_19652))) {\n                    x_20612 = ((__local\n                                float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                            offset_20624)];\n                }\n            }\n            offset_20624 = 1;\n            while (slt32(offset_20624, wave_sizze_20604)) {\n                if (slt32(local_tid_20602 + offset_20624,\n                          sext_i64_i32(segred_group_sizze_19652)) &&\n                    ((local_tid_20602 - squot32(local_tid_20602,\n                                                wave_sizze_20604) *\n                      wave_sizze_20604) & (2 * offset_20624 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_20613 = ((volatile __",
                   "local\n                                    float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                                offset_20624)];\n                    }\n                    // apply reduction operation\n                    {\n                        float defunc_1_op_res_20614 = x_20612 + x_20613;\n                        \n                        x_20612 = defunc_1_op_res_20614;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                            x_20612;\n                    }\n                }\n                offset_20624 *= 2;\n            }\n            while (slt32(skip_waves_20625,\n                         squot32(sext_i64_i32(segred_group_sizze_19652) +\n                                 wave_sizze_20604 - 1, wave_sizze_20604))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_20624 = skip_waves_20625 * wave_sizze_20604;\n                if (slt32(local_tid_20602 + offset_20624,\n                          sext_i64_i32(segred_group_sizze_19652)) &&\n                    ((local_tid_20602 - squot32(local_tid_20602,\n                                                wave_sizze_20604) *\n                      wave_sizze_20604) == 0 && (squot32(local_tid_20602,\n                                                         wave_sizze_20604) &\n                                                 (2 * skip_waves_20625 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_20613 = ((__local\n                                    float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                                offset_20624)];\n                    }\n                    // apply reduction operation\n                    {\n                    ",
                   "    float defunc_1_op_res_20614 = x_20612 + x_20613;\n                        \n                        x_20612 = defunc_1_op_res_20614;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                            x_20612;\n                    }\n                }\n                skip_waves_20625 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_20602 == 0) {\n                    ((__global float *) mem_20278)[(int64_t) 0] = x_20612;\n                }\n            }\n        }\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19652\n}\n__kernel void scaleMzisegmap_18756(__global int *global_failure,\n                                   int64_t nz2081U_18362, int64_t nz2083U_18363,\n                                   float f_18364, __global\n                                   unsigned char *as_mem_20275, __global\n                                   unsigned char *mem_20280)\n{\n    #define segmap_group_sizze_18777 (scaleMzisegmap_group_sizze_18759)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18756 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18777 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = nz2081U_18362;\n    int64_t slice_20602 = nz2083U_18363 * slice_20601;\n    int64_t gtid_1",
                   "8754 = squot64(global_tid_20600, slice_20601);\n    int64_t remnant_20603 = global_tid_20600 - gtid_18754 * slice_20601;\n    int64_t gtid_18755 = remnant_20603;\n    int64_t remnant_20604 = remnant_20603 - gtid_18755;\n    \n    if (slt64(gtid_18754, nz2083U_18363) && slt64(gtid_18755, nz2081U_18362)) {\n        float x_18780 = ((__global float *) as_mem_20275)[gtid_18754 *\n                                                          nz2081U_18362 +\n                                                          gtid_18755];\n        float defunc_0_f_res_18781 = f_18364 * x_18780;\n        \n        ((__global float *) mem_20280)[gtid_18754 * nz2081U_18362 +\n                                       gtid_18755] = defunc_0_f_res_18781;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18777\n}\n__kernel void scaleVzisegmap_18920(__global int *global_failure,\n                                   int64_t nz2082U_18411, float f_18412,\n                                   __global unsigned char *as_mem_20275,\n                                   __global unsigned char *mem_20279)\n{\n    #define segmap_group_sizze_18928 (scaleVzisegmap_group_sizze_18922)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18920 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18928 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = nz2082U_18411;\n    int64_t gtid_18919 = global_tid_20600;\n    int64_t remnant_20602 = global_tid_20600 - gtid_18919;\n    \n    if (s",
                   "lt64(gtid_18919, nz2082U_18411)) {\n        float x_18931 = ((__global float *) as_mem_20275)[gtid_18919];\n        float defunc_0_f_res_18932 = f_18412 * x_18931;\n        \n        ((__global float *) mem_20279)[gtid_18919] = defunc_0_f_res_18932;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18928\n}\n__kernel void vectorAbszisegmap_18613(__global int *global_failure,\n                                      int64_t nz2081U_18322, __global\n                                      unsigned char *as_mem_20275, __global\n                                      unsigned char *mem_20279)\n{\n    #define segmap_group_sizze_18621 (vectorAbszisegmap_group_sizze_18615)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18613 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18621 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = nz2081U_18322;\n    int64_t gtid_18612 = global_tid_20600;\n    int64_t remnant_20602 = global_tid_20600 - gtid_18612;\n    \n    if (slt64(gtid_18612, nz2081U_18322)) {\n        float x_18624 = ((__global float *) as_mem_20275)[gtid_18612];\n        float defunc_0_f_res_18625 = (float) fabs(x_18624);\n        \n        ((__global float *) mem_20279)[gtid_18612] = defunc_0_f_res_18625;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18621\n}\n__kernel void vectorAddzisegmap_18641(__global int *global_failure,\n                                      int64_t i_18332, __global\n                         ",
                   "             unsigned char *a_mem_20275, __global\n                                      unsigned char *b_mem_20276, __global\n                                      unsigned char *mem_20280)\n{\n    #define segmap_group_sizze_18650 (vectorAddzisegmap_group_sizze_18643)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18641 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18650 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = i_18332;\n    int64_t gtid_18640 = global_tid_20600;\n    int64_t remnant_20602 = global_tid_20600 - gtid_18640;\n    \n    if (slt64(gtid_18640, i_18332)) {\n        float x_18653 = ((__global float *) a_mem_20275)[gtid_18640];\n        float x_18654 = ((__global float *) b_mem_20276)[gtid_18640];\n        float defunc_1_f_res_18655 = x_18653 + x_18654;\n        \n        ((__global float *) mem_20280)[gtid_18640] = defunc_1_f_res_18655;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18650\n}\n__kernel void vectorMatrixMulzisegmap_intragroup_19807(__global\n                                                       int *global_failure,\n                                                       __local volatile\n                                                       int64_t *color_20551_backing_aligned_0,\n                                                       int64_t i_18430,\n                                                       int64_t j_18431,\n                                                       int64",
                   "_t segmap_usable_groups_19010,\n                                                       int64_t num_whole_tiles_19815,\n                                                       int64_t residual_input_19901,\n                                                       unsigned char cond_19902,\n                                                       __global\n                                                       unsigned char *v_mem_20275,\n                                                       __global\n                                                       unsigned char *M_mem_20276,\n                                                       __global\n                                                       unsigned char *mem_20300)\n{\n    #define segmap_group_sizze_19009 (vectorMatrixMulzisegmap_group_sizze_18997)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict color_20551_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) color_20551_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20596;\n    int32_t local_tid_20597;\n    int64_t group_sizze_20600;\n    int32_t wave_sizze_20599;\n    int32_t group_tid_20598;\n    \n    global_tid_20596 = get_global_id(0);\n    local_tid_20597 = get_local_id(0);\n    group_sizze_20600 = get_local_size(0);\n    wave_sizze_20599 = LOCKSTEP_WIDTH;\n    group_tid_20598 = get_group_id(0);\n    \n    int32_t gid_flat_19807 = group_tid_20598;\n    int64_t slice_20602 = segmap_group_sizze_19009;\n    int64_t ltid_pre_20601 = sext_i32_i64(local_tid_20597);\n    int64_t remnant_20603 = sext_i32_i64(local_tid_20597) - ltid_pre_20601;\n    int64_t slice_20604 = segmap_usable_groups_19010;\n    int64_t gid_19806 = sext_i32_i64(group_tid_20598);\n    int64_t remnant_20605 = sext_i32_i64(group_tid_20598) - gid_19806;\n    float color_20548[1];\n    float color_20549[1];\n    float co",
                   "lor_20550[1];\n    __local unsigned char *color_20551;\n    \n    color_20551 = (__local unsigned char *) color_20551_backing_0;\n    \n    int64_t ltid_19816 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n    int32_t ltid_flat_19817 = local_tid_20597;\n    \n    color_20549[(int64_t) 0] = 0.0F;\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int64_t binop_x_19879 = segmap_group_sizze_19009 * gid_19806;\n    \n    color_20548[(int64_t) 0] = color_20549[(int64_t) 0];\n    \n    float ext_mem_20289[1];\n    float ext_mem_unused_20531[1];\n    float mem_param_20281[1];\n    float mem_param_out_20532[1];\n    \n    for (int32_t i_1 = 0; i_1 < 1; i_1++)\n        mem_param_20281[i_1] = color_20548[i_1];\n    for (int32_t i_2 = 0; i_2 < 1; i_2++)\n        mem_param_out_20532[i_2] = color_20549[i_2];\n    for (int64_t tile_id_19823 = 0; tile_id_19823 < num_whole_tiles_19815;\n         tile_id_19823++) {\n        int64_t binop_x_19869 = segmap_group_sizze_19009 * tile_id_19823;\n        int64_t ltid_19824 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19825 = local_tid_20597;\n        int64_t j_19870 = ltid_19824 + binop_x_19869;\n        bool cond_19874 = slt64(j_19870, i_18430);\n        float pre_19875;\n        \n        if (cond_19874) {\n            float tile_elem_19876 = ((__global float *) v_mem_20275)[j_19870];\n            \n            pre_19875 = tile_elem_19876;\n        } else {\n            pre_19875 = 0.0F;\n        }\n        ((__local float *) color_20551)[ltid_19824] = pre_19875;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int64_t ltid_19843 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19844 = local_tid_20597;\n        int64_t gtid_19880 = ltid_19843 + binop_x_19879;\n        float acc_19882 = mem_param_20281[(int64_t) 0];\n        bool cond_19885 = slt64(gtid_19880, j_18431);\n        float acc_19886;\n        \n        if (cond_19885) {\n            float x_19887;\n            float redout_20267 = acc_19882;\n            \n            for (i",
                   "nt64_t i_20268 = 0; i_20268 < segmap_group_sizze_19009;\n                 i_20268++) {\n                float x_19891 = ((__local float *) color_20551)[i_20268];\n                int64_t slice_20273 = binop_x_19869 + i_20268;\n                float x_19892 = ((__global float *) M_mem_20276)[slice_20273 *\n                                                                 j_18431 +\n                                                                 gtid_19880];\n                float defunc_1_f_res_19893 = x_19891 * x_19892;\n                float defunc_1_op_res_19890 = defunc_1_f_res_19893 +\n                      redout_20267;\n                float redout_tmp_20609 = defunc_1_op_res_19890;\n                \n                redout_20267 = redout_tmp_20609;\n            }\n            x_19887 = redout_20267;\n            acc_19886 = x_19887;\n        } else {\n            acc_19886 = acc_19882;\n        }\n        mem_param_out_20532[(int64_t) 0] = acc_19886;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        float mem_param_tmp_20606[1];\n        \n        for (int32_t i_3 = 0; i_3 < 1; i_3++)\n            mem_param_tmp_20606[i_3] = mem_param_out_20532[i_3];\n        \n        float mem_param_out_tmp_20607[1];\n        \n        for (int32_t i_4 = 0; i_4 < 1; i_4++)\n            mem_param_out_tmp_20607[i_4] = mem_param_20281[i_4];\n        for (int32_t i_5 = 0; i_5 < 1; i_5++)\n            mem_param_20281[i_5] = mem_param_tmp_20606[i_5];\n        for (int32_t i_6 = 0; i_6 < 1; i_6++)\n            mem_param_out_20532[i_6] = mem_param_out_tmp_20607[i_6];\n    }\n    for (int32_t i_7 = 0; i_7 < 1; i_7++)\n        ext_mem_20289[i_7] = mem_param_20281[i_7];\n    for (int32_t i_8 = 0; i_8 < 1; i_8++)\n        ext_mem_unused_20531[i_8] = mem_param_out_20532[i_8];\n    if (cond_19902) {\n        color_20549[(int64_t) 0] = ext_mem_20289[(int64_t) 0];\n    } else {\n        int64_t binop_x_19912 = segmap_group_sizze_19009 *\n                num_whole_tiles_19815;\n        int64_t ltid_19903 = sext_i32_i64(sext_i64",
                   "_i32(ltid_pre_20601));\n        int32_t ltid_flat_19904 = local_tid_20597;\n        int64_t j_19913 = ltid_19903 + binop_x_19912;\n        bool cond_19917 = slt64(j_19913, i_18430);\n        float pre_19918;\n        \n        if (cond_19917) {\n            float tile_elem_19919 = ((__global float *) v_mem_20275)[j_19913];\n            \n            pre_19918 = tile_elem_19919;\n        } else {\n            pre_19918 = 0.0F;\n        }\n        ((__local float *) color_20551)[ltid_19903] = pre_19918;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int64_t slice_offset_19936 = num_whole_tiles_19815 *\n                residual_input_19901;\n        int64_t ltid_19923 = sext_i32_i64(sext_i64_i32(ltid_pre_20601));\n        int32_t ltid_flat_19924 = local_tid_20597;\n        int64_t gtid_19933 = binop_x_19879 + ltid_19923;\n        float acc_19935 = ext_mem_20289[(int64_t) 0];\n        bool cond_19938 = slt64(gtid_19933, j_18431);\n        float acc_19939;\n        \n        if (cond_19938) {\n            float x_19940;\n            float redout_20269 = acc_19935;\n            \n            for (int64_t i_20270 = 0; i_20270 < residual_input_19901;\n                 i_20270++) {\n                float x_19944 = ((__local float *) color_20551)[i_20270];\n                int64_t slice_20274 = slice_offset_19936 + i_20270;\n                float x_19945 = ((__global float *) M_mem_20276)[slice_20274 *\n                                                                 j_18431 +\n                                                                 gtid_19933];\n                float defunc_1_f_res_19946 = x_19944 * x_19945;\n                float defunc_1_op_res_19943 = defunc_1_f_res_19946 +\n                      redout_20269;\n                float redout_tmp_20610 = defunc_1_op_res_19943;\n                \n                redout_20269 = redout_tmp_20610;\n            }\n            x_19940 = redout_20269;\n            acc_19939 = x_19940;\n        } else {\n            acc_19939 = acc_19935;\n        }\n        c",
                   "olor_20550[(int64_t) 0] = acc_19939;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        color_20549[(int64_t) 0] = color_20550[(int64_t) 0];\n    }\n    if (slt64(sext_i32_i64(local_tid_20597) + segmap_group_sizze_19009 *\n              sext_i32_i64(group_tid_20598), j_18431)) {\n        ((__global float *) mem_20300)[sext_i32_i64(local_tid_20597) +\n                                       segmap_group_sizze_19009 *\n                                       sext_i32_i64(group_tid_20598)] =\n            color_20549[(int64_t) 0];\n    }\n    \n  error_5:\n    return;\n    #undef segmap_group_sizze_19009\n}\n__kernel void vectorMatrixMulzisegred_large_19029(__global int *global_failure,\n                                                  __local volatile\n                                                  int64_t *sync_arr_mem_20650_backing_aligned_0,\n                                                  __local volatile\n                                                  int64_t *red_arr_mem_20648_backing_aligned_1,\n                                                  int64_t i_18430,\n                                                  int64_t j_18431,\n                                                  int64_t num_groups_19040,\n                                                  int64_t groups_per_segment_20634,\n                                                  int64_t elements_per_thread_20635,\n                                                  int64_t virt_num_groups_20636,\n                                                  int64_t threads_per_segment_20638,\n                                                  __global\n                                                  unsigned char *v_mem_20275,\n                                                  __global\n                                                  unsigned char *mem_20303,\n                                                  __global\n                                                  unsigned char *mem_20307,\n                                                  ",
                   "__global\n                                                  unsigned char *segred_tmp_mem_20639,\n                                                  __global\n                                                  unsigned char *vectorMatrixMulzicounter_mem_20641)\n{\n    #define segred_group_sizze_19039 (vectorMatrixMulzisegred_group_sizze_19023)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict sync_arr_mem_20650_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) sync_arr_mem_20650_backing_aligned_0;\n    __local volatile unsigned char *restrict red_arr_mem_20648_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20648_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20643;\n    int32_t local_tid_20644;\n    int64_t group_sizze_20647;\n    int32_t wave_sizze_20646;\n    int32_t group_tid_20645;\n    \n    global_tid_20643 = get_global_id(0);\n    local_tid_20644 = get_local_id(0);\n    group_sizze_20647 = get_local_size(0);\n    wave_sizze_20646 = LOCKSTEP_WIDTH;\n    group_tid_20645 = get_group_id(0);\n    \n    int32_t phys_tid_19029 = global_tid_20643;\n    __local unsigned char *red_arr_mem_20648;\n    \n    red_arr_mem_20648 = (__local unsigned char *) red_arr_mem_20648_backing_0;\n    \n    __local unsigned char *sync_arr_mem_20650;\n    \n    sync_arr_mem_20650 = (__local unsigned char *) sync_arr_mem_20650_backing_1;\n    \n    int32_t phys_group_id_20652;\n    \n    phys_group_id_20652 = get_group_id(0);\n    for (int32_t i_20653 = 0; i_20653 <\n         sdiv_up32(sext_i64_i32(virt_num_groups_20636) - phys_group_id_20652,\n                   sext_i64_i32(num_groups_19040)); i_20653++) {\n        int32_t virt_group_id_20654 = phys_group_id_20652 + i_20653 *\n                sext_i64_i32(num_groups_19040);\n        in",
                   "t32_t flat_segment_id_20655 = squot32(virt_group_id_20654,\n                                                sext_i64_i32(groups_per_segment_20634));\n        int64_t global_tid_20656 = srem64(sext_i32_i64(virt_group_id_20654) *\n                                          segred_group_sizze_19039 +\n                                          sext_i32_i64(local_tid_20644),\n                                          segred_group_sizze_19039 *\n                                          groups_per_segment_20634);\n        int64_t slice_20657 = j_18431;\n        int64_t gtid_19020 = sext_i32_i64(flat_segment_id_20655);\n        int64_t remnant_20658 = sext_i32_i64(flat_segment_id_20655) -\n                gtid_19020;\n        int64_t gtid_19028;\n        float x_acc_20659;\n        int64_t chunk_sizze_20660 = smin64(elements_per_thread_20635,\n                                           sdiv_up64(i_18430 - global_tid_20656,\n                                                     threads_per_segment_20638));\n        float x_19043;\n        float x_19044;\n        \n        // neutral-initialise the accumulators\n        {\n            x_acc_20659 = 0.0F;\n        }\n        for (int64_t i_20664 = 0; i_20664 < chunk_sizze_20660; i_20664++) {\n            gtid_19028 = global_tid_20656 + threads_per_segment_20638 * i_20664;\n            // apply map function\n            {\n                float x_19047 = ((__global float *) v_mem_20275)[gtid_19028];\n                float x_19048 = ((__global float *) mem_20303)[gtid_19020 *\n                                                               i_18430 +\n                                                               gtid_19028];\n                float defunc_1_f_res_19049 = x_19047 * x_19048;\n                \n                // save map-out results\n                { }\n                // load accumulator\n                {\n                    x_19043 = x_acc_20659;\n                }\n                // load new values\n                {\n                    x_19044 = de",
                   "func_1_f_res_19049;\n                }\n                // apply reduction operator\n                {\n                    float defunc_1_op_res_19045 = x_19043 + x_19044;\n                    \n                    // store in accumulator\n                    {\n                        x_acc_20659 = defunc_1_op_res_19045;\n                    }\n                }\n            }\n        }\n        // to reduce current chunk, first store our result in memory\n        {\n            x_19043 = x_acc_20659;\n            ((__local\n              float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                x_19043;\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        \n        int32_t offset_20665;\n        int32_t skip_waves_20666 = 1;\n        float x_20661;\n        float x_20662;\n        \n        offset_20665 = 0;\n        // participating threads read initial accumulator\n        {\n            if (slt32(local_tid_20644,\n                      sext_i64_i32(segred_group_sizze_19039))) {\n                x_20661 = ((__local\n                            float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                        offset_20665)];\n            }\n        }\n        offset_20665 = 1;\n        while (slt32(offset_20665, wave_sizze_20646)) {\n            if (slt32(local_tid_20644 + offset_20665,\n                      sext_i64_i32(segred_group_sizze_19039)) &&\n                ((local_tid_20644 - squot32(local_tid_20644, wave_sizze_20646) *\n                  wave_sizze_20646) & (2 * offset_20665 - 1)) == 0) {\n                // read array element\n                {\n                    x_20662 = ((volatile __local\n                                float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                            offset_20665)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_1_op_res_20663 = x_20661 + x_20662;\n            ",
                   "        \n                    x_20661 = defunc_1_op_res_20663;\n                }\n                // write result of operation\n                {\n                    ((volatile __local\n                      float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                        x_20661;\n                }\n            }\n            offset_20665 *= 2;\n        }\n        while (slt32(skip_waves_20666,\n                     squot32(sext_i64_i32(segred_group_sizze_19039) +\n                             wave_sizze_20646 - 1, wave_sizze_20646))) {\n            barrier(CLK_LOCAL_MEM_FENCE);\n            offset_20665 = skip_waves_20666 * wave_sizze_20646;\n            if (slt32(local_tid_20644 + offset_20665,\n                      sext_i64_i32(segred_group_sizze_19039)) &&\n                ((local_tid_20644 - squot32(local_tid_20644, wave_sizze_20646) *\n                  wave_sizze_20646) == 0 && (squot32(local_tid_20644,\n                                                     wave_sizze_20646) & (2 *\n                                                                          skip_waves_20666 -\n                                                                          1)) ==\n                 0)) {\n                // read array element\n                {\n                    x_20662 = ((__local\n                                float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                            offset_20665)];\n                }\n                // apply reduction operation\n                {\n                    float defunc_1_op_res_20663 = x_20661 + x_20662;\n                    \n                    x_20661 = defunc_1_op_res_20663;\n                }\n                // write result of operation\n                {\n                    ((__local\n                      float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                        x_20661;\n                }\n            }\n            skip_waves_20666 *= 2;\n        }\n     ",
                   "   barrier(CLK_LOCAL_MEM_FENCE);\n        // first thread saves the result in accumulator\n        {\n            if (sext_i32_i64(local_tid_20644) == (int64_t) 0) {\n                x_acc_20659 = x_20661;\n            }\n        }\n        if (groups_per_segment_20634 == (int64_t) 1) {\n            // first thread in group saves final result to memory\n            {\n                if (local_tid_20644 == 0) {\n                    ((__global float *) mem_20307)[gtid_19020] = x_acc_20659;\n                }\n            }\n        } else {\n            int32_t old_counter_20667;\n            \n            // first thread in group saves group result to global memory\n            {\n                if (local_tid_20644 == 0) {\n                    ((__global\n                      float *) segred_tmp_mem_20639)[sext_i32_i64(virt_group_id_20654)] =\n                        x_acc_20659;\n                    mem_fence_global();\n                    old_counter_20667 =\n                        atomic_add_i32_global(&((volatile __global\n                                                 int *) vectorMatrixMulzicounter_mem_20641)[sext_i32_i64(srem32(flat_segment_id_20655,\n                                                                                                                10240))],\n                                              (int) 1);\n                    ((__local bool *) sync_arr_mem_20650)[(int64_t) 0] =\n                        old_counter_20667 == groups_per_segment_20634 -\n                        (int64_t) 1;\n                }\n            }\n            barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n            \n            bool is_last_group_20668 = ((__local\n                                         bool *) sync_arr_mem_20650)[(int64_t) 0];\n            \n            if (is_last_group_20668) {\n                if (local_tid_20644 == 0) {\n                    old_counter_20667 =\n                        atomic_add_i32_global(&((volatile __global\n                                        ",
                   "         int *) vectorMatrixMulzicounter_mem_20641)[sext_i32_i64(srem32(flat_segment_id_20655,\n                                                                                                                10240))],\n                                              (int) ((int64_t) 0 -\n                                                     groups_per_segment_20634));\n                }\n                // read in the per-group-results\n                {\n                    int64_t read_per_thread_20669 =\n                            sdiv_up64(groups_per_segment_20634,\n                                      segred_group_sizze_19039);\n                    \n                    x_19043 = 0.0F;\n                    for (int64_t i_20670 = 0; i_20670 < read_per_thread_20669;\n                         i_20670++) {\n                        int64_t group_res_id_20671 =\n                                sext_i32_i64(local_tid_20644) *\n                                read_per_thread_20669 + i_20670;\n                        int64_t index_of_group_res_20672 =\n                                sext_i32_i64(flat_segment_id_20655) *\n                                groups_per_segment_20634 + group_res_id_20671;\n                        \n                        if (slt64(group_res_id_20671,\n                                  groups_per_segment_20634)) {\n                            x_19044 = ((__global\n                                        float *) segred_tmp_mem_20639)[index_of_group_res_20672];\n                            \n                            float defunc_1_op_res_19045 = x_19043 + x_19044;\n                            \n                            x_19043 = defunc_1_op_res_19045;\n                        }\n                    }\n                }\n                ((__local\n                  float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                    x_19043;\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // reduce the per-group results\n                {\n        ",
                   "            int32_t offset_20673;\n                    int32_t skip_waves_20674 = 1;\n                    float x_20661;\n                    float x_20662;\n                    \n                    offset_20673 = 0;\n                    // participating threads read initial accumulator\n                    {\n                        if (slt32(local_tid_20644,\n                                  sext_i64_i32(segred_group_sizze_19039))) {\n                            x_20661 = ((__local\n                                        float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                                    offset_20673)];\n                        }\n                    }\n                    offset_20673 = 1;\n                    while (slt32(offset_20673, wave_sizze_20646)) {\n                        if (slt32(local_tid_20644 + offset_20673,\n                                  sext_i64_i32(segred_group_sizze_19039)) &&\n                            ((local_tid_20644 - squot32(local_tid_20644,\n                                                        wave_sizze_20646) *\n                              wave_sizze_20646) & (2 * offset_20673 - 1)) ==\n                            0) {\n                            // read array element\n                            {\n                                x_20662 = ((volatile __local\n                                            float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                                        offset_20673)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_1_op_res_20663 = x_20661 + x_20662;\n                                \n                                x_20661 = defunc_1_op_res_20663;\n                            }\n                            // write result of operation\n                            {\n                                ((v",
                   "olatile __local\n                                  float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                                    x_20661;\n                            }\n                        }\n                        offset_20673 *= 2;\n                    }\n                    while (slt32(skip_waves_20674,\n                                 squot32(sext_i64_i32(segred_group_sizze_19039) +\n                                         wave_sizze_20646 - 1,\n                                         wave_sizze_20646))) {\n                        barrier(CLK_LOCAL_MEM_FENCE);\n                        offset_20673 = skip_waves_20674 * wave_sizze_20646;\n                        if (slt32(local_tid_20644 + offset_20673,\n                                  sext_i64_i32(segred_group_sizze_19039)) &&\n                            ((local_tid_20644 - squot32(local_tid_20644,\n                                                        wave_sizze_20646) *\n                              wave_sizze_20646) == 0 &&\n                             (squot32(local_tid_20644, wave_sizze_20646) & (2 *\n                                                                            skip_waves_20674 -\n                                                                            1)) ==\n                             0)) {\n                            // read array element\n                            {\n                                x_20662 = ((__local\n                                            float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644 +\n                                                                        offset_20673)];\n                            }\n                            // apply reduction operation\n                            {\n                                float defunc_1_op_res_20663 = x_20661 + x_20662;\n                                \n                                x_20661 = defunc_1_op_res_20663;\n                            }\n                            // write result ",
                   "of operation\n                            {\n                                ((__local\n                                  float *) red_arr_mem_20648)[sext_i32_i64(local_tid_20644)] =\n                                    x_20661;\n                            }\n                        }\n                        skip_waves_20674 *= 2;\n                    }\n                    // and back to memory with the final result\n                    {\n                        if (local_tid_20644 == 0) {\n                            ((__global float *) mem_20307)[gtid_19020] =\n                                x_20661;\n                        }\n                    }\n                }\n            }\n        }\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19039\n}\n__kernel void vectorMatrixMulzisegred_small_19029(__global int *global_failure,\n                                                  __local volatile\n                                                  int64_t *red_arr_mem_20618_backing_aligned_0,\n                                                  int64_t i_18430,\n                                                  int64_t j_18431,\n                                                  int64_t num_groups_19040,\n                                                  int64_t segment_sizze_nonzzero_20611,\n                                                  __global\n                                                  unsigned char *v_mem_20275,\n                                                  __global\n                                                  unsigned char *mem_20303,\n                                                  __global\n                                                  unsigned char *mem_20307)\n{\n    #define segred_group_sizze_19039 (vectorMatrixMulzisegred_group_sizze_19023)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_",
                   "arr_mem_20618_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20618_backing_aligned_0;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20613;\n    int32_t local_tid_20614;\n    int64_t group_sizze_20617;\n    int32_t wave_sizze_20616;\n    int32_t group_tid_20615;\n    \n    global_tid_20613 = get_global_id(0);\n    local_tid_20614 = get_local_id(0);\n    group_sizze_20617 = get_local_size(0);\n    wave_sizze_20616 = LOCKSTEP_WIDTH;\n    group_tid_20615 = get_group_id(0);\n    \n    int32_t phys_tid_19029 = global_tid_20613;\n    __local unsigned char *red_arr_mem_20618;\n    \n    red_arr_mem_20618 = (__local unsigned char *) red_arr_mem_20618_backing_0;\n    \n    int32_t phys_group_id_20620;\n    \n    phys_group_id_20620 = get_group_id(0);\n    for (int32_t i_20621 = 0; i_20621 <\n         sdiv_up32(sext_i64_i32(sdiv_up64(j_18431,\n                                          squot64(segred_group_sizze_19039,\n                                                  segment_sizze_nonzzero_20611))) -\n                   phys_group_id_20620, sext_i64_i32(num_groups_19040));\n         i_20621++) {\n        int32_t virt_group_id_20622 = phys_group_id_20620 + i_20621 *\n                sext_i64_i32(num_groups_19040);\n        int64_t slice_20623 = j_18431;\n        int64_t gtid_19020 = squot64(sext_i32_i64(local_tid_20614),\n                                     segment_sizze_nonzzero_20611) +\n                sext_i32_i64(virt_group_id_20622) *\n                squot64(segred_group_sizze_19039, segment_sizze_nonzzero_20611);\n        int64_t remnant_20624 = squot64(sext_i32_i64(local_tid_20614),\n                                        segment_sizze_nonzzero_20611) +\n                sext_i32_i64(virt_group_id_20622) *\n                squot64(segred_group_sizze_19039,\n                        segment_sizze_nonzzero_20611) - gtid_19020;\n        int64_t gtid_19028 = srem64(sext_i32_i64(local_tid_20614),",
                   " i_18430);\n        \n        // apply map function if in bounds\n        {\n            if (slt64((int64_t) 0, i_18430) && (slt64(gtid_19020, j_18431) &&\n                                                slt64(sext_i32_i64(local_tid_20614),\n                                                      i_18430 *\n                                                      squot64(segred_group_sizze_19039,\n                                                              segment_sizze_nonzzero_20611)))) {\n                float x_19047 = ((__global float *) v_mem_20275)[gtid_19028];\n                float x_19048 = ((__global float *) mem_20303)[gtid_19020 *\n                                                               i_18430 +\n                                                               gtid_19028];\n                float defunc_1_f_res_19049 = x_19047 * x_19048;\n                \n                // save map-out results\n                { }\n                // save results to be reduced\n                {\n                    ((__local\n                      float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                        defunc_1_f_res_19049;\n                }\n            } else {\n                ((__local\n                  float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                    0.0F;\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        if (slt64((int64_t) 0, i_18430)) {\n            // perform segmented scan to imitate reduction\n            {\n                float x_19043;\n                float x_19044;\n                float x_20625;\n                float x_20626;\n                bool ltid_in_bounds_20628 = slt64(sext_i32_i64(local_tid_20614),\n                                                  i_18430 *\n                                                  squot64(segred_group_sizze_19039,\n                                                          segment_sizze_nonzzero_20611));\n                int32_t skip_threads_20629;\n                \n",
                   "                // read input for in-block scan\n                {\n                    if (ltid_in_bounds_20628) {\n                        x_19044 = ((volatile __local\n                                    float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)];\n                        if ((local_tid_20614 - squot32(local_tid_20614, 32) *\n                             32) == 0) {\n                            x_19043 = x_19044;\n                        }\n                    }\n                }\n                // in-block scan (hopefully no barriers needed)\n                {\n                    skip_threads_20629 = 1;\n                    while (slt32(skip_threads_20629, 32)) {\n                        if (sle32(skip_threads_20629, local_tid_20614 -\n                                  squot32(local_tid_20614, 32) * 32) &&\n                            ltid_in_bounds_20628) {\n                            // read operands\n                            {\n                                x_19043 = ((volatile __local\n                                            float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614) -\n                                                                        sext_i32_i64(skip_threads_20629)];\n                            }\n                            // perform operation\n                            {\n                                bool inactive_20630 =\n                                     slt64(srem64(sext_i32_i64(local_tid_20614),\n                                                  i_18430),\n                                           sext_i32_i64(local_tid_20614) -\n                                           sext_i32_i64(local_tid_20614 -\n                                           skip_threads_20629));\n                                \n                                if (inactive_20630) {\n                                    x_19043 = x_19044;\n                                }\n                                if (!inactive_20630) {\n                           ",
                   "         float defunc_1_op_res_19045 = x_19043 +\n                                          x_19044;\n                                    \n                                    x_19043 = defunc_1_op_res_19045;\n                                }\n                            }\n                        }\n                        if (sle32(wave_sizze_20616, skip_threads_20629)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        if (sle32(skip_threads_20629, local_tid_20614 -\n                                  squot32(local_tid_20614, 32) * 32) &&\n                            ltid_in_bounds_20628) {\n                            // write result\n                            {\n                                ((volatile __local\n                                  float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                                    x_19043;\n                                x_19044 = x_19043;\n                            }\n                        }\n                        if (sle32(wave_sizze_20616, skip_threads_20629)) {\n                            barrier(CLK_LOCAL_MEM_FENCE);\n                        }\n                        skip_threads_20629 *= 2;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // last thread of block 'i' writes its result to offset 'i'\n                {\n                    if ((local_tid_20614 - squot32(local_tid_20614, 32) * 32) ==\n                        31 && ltid_in_bounds_20628) {\n                        ((volatile __local\n                          float *) red_arr_mem_20618)[sext_i32_i64(squot32(local_tid_20614,\n                                                                           32))] =\n                            x_19043;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // scan the first block, after which offset 'i' contains carry-in for block 'i+1'\n               ",
                   " {\n                    int32_t skip_threads_20631;\n                    \n                    // read input for in-block scan\n                    {\n                        if (squot32(local_tid_20614, 32) == 0 &&\n                            ltid_in_bounds_20628) {\n                            x_20626 = ((volatile __local\n                                        float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)];\n                            if ((local_tid_20614 - squot32(local_tid_20614,\n                                                           32) * 32) == 0) {\n                                x_20625 = x_20626;\n                            }\n                        }\n                    }\n                    // in-block scan (hopefully no barriers needed)\n                    {\n                        skip_threads_20631 = 1;\n                        while (slt32(skip_threads_20631, 32)) {\n                            if (sle32(skip_threads_20631, local_tid_20614 -\n                                      squot32(local_tid_20614, 32) * 32) &&\n                                (squot32(local_tid_20614, 32) == 0 &&\n                                 ltid_in_bounds_20628)) {\n                                // read operands\n                                {\n                                    x_20625 = ((volatile __local\n                                                float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614) -\n                                                                            sext_i32_i64(skip_threads_20631)];\n                                }\n                                // perform operation\n                                {\n                                    bool inactive_20632 =\n                                         slt64(srem64(sext_i32_i64(local_tid_20614 *\n                                                      32 + 32 - 1), i_18430),\n                                               sext_i32_i64(local_tid_20614 *\n                             ",
                   "                  32 + 32 - 1) -\n                                               sext_i32_i64((local_tid_20614 -\n                                                             skip_threads_20631) *\n                                               32 + 32 - 1));\n                                    \n                                    if (inactive_20632) {\n                                        x_20625 = x_20626;\n                                    }\n                                    if (!inactive_20632) {\n                                        float defunc_1_op_res_20627 = x_20625 +\n                                              x_20626;\n                                        \n                                        x_20625 = defunc_1_op_res_20627;\n                                    }\n                                }\n                            }\n                            if (sle32(wave_sizze_20616, skip_threads_20631)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            if (sle32(skip_threads_20631, local_tid_20614 -\n                                      squot32(local_tid_20614, 32) * 32) &&\n                                (squot32(local_tid_20614, 32) == 0 &&\n                                 ltid_in_bounds_20628)) {\n                                // write result\n                                {\n                                    ((volatile __local\n                                      float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                                        x_20625;\n                                    x_20626 = x_20625;\n                                }\n                            }\n                            if (sle32(wave_sizze_20616, skip_threads_20631)) {\n                                barrier(CLK_LOCAL_MEM_FENCE);\n                            }\n                            skip_threads_20631 *= 2;\n                        }\n                    }\n              ",
                   "  }\n                barrier(CLK_LOCAL_MEM_FENCE);\n                // carry-in for every block except the first\n                {\n                    if (!(squot32(local_tid_20614, 32) == 0 ||\n                          !ltid_in_bounds_20628)) {\n                        // read operands\n                        {\n                            x_19044 = x_19043;\n                            x_19043 = ((__local\n                                        float *) red_arr_mem_20618)[sext_i32_i64(squot32(local_tid_20614,\n                                                                                         32)) -\n                                                                    (int64_t) 1];\n                        }\n                        // perform operation\n                        {\n                            bool inactive_20633 =\n                                 slt64(srem64(sext_i32_i64(local_tid_20614),\n                                              i_18430),\n                                       sext_i32_i64(local_tid_20614) -\n                                       sext_i32_i64(squot32(local_tid_20614,\n                                                            32) * 32 - 1));\n                            \n                            if (inactive_20633) {\n                                x_19043 = x_19044;\n                            }\n                            if (!inactive_20633) {\n                                float defunc_1_op_res_19045 = x_19043 + x_19044;\n                                \n                                x_19043 = defunc_1_op_res_19045;\n                            }\n                        }\n                        // write final result\n                        {\n                            ((__local\n                              float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                                x_19043;\n                        }\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n      ",
                   "          // restore correct values for first block\n                {\n                    if (squot32(local_tid_20614, 32) == 0) {\n                        ((__local\n                          float *) red_arr_mem_20618)[sext_i32_i64(local_tid_20614)] =\n                            x_19044;\n                    }\n                }\n                barrier(CLK_LOCAL_MEM_FENCE);\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // save final values of segments\n        {\n            if (slt64(sext_i32_i64(virt_group_id_20622) *\n                      squot64(segred_group_sizze_19039,\n                              segment_sizze_nonzzero_20611) +\n                      sext_i32_i64(local_tid_20614), j_18431) &&\n                slt64(sext_i32_i64(local_tid_20614),\n                      squot64(segred_group_sizze_19039,\n                              segment_sizze_nonzzero_20611))) {\n                ((__global\n                  float *) mem_20307)[sext_i32_i64(virt_group_id_20622) *\n                                      squot64(segred_group_sizze_19039,\n                                              segment_sizze_nonzzero_20611) +\n                                      sext_i32_i64(local_tid_20614)] = ((__local\n                                                                         float *) red_arr_mem_20618)[(sext_i32_i64(local_tid_20614) +\n                                                                                                      (int64_t) 1) *\n                                                                                                     segment_sizze_nonzzero_20611 -\n                                                                                                     (int64_t) 1];\n            }\n        }\n        barrier(CLK_LOCAL_MEM_FENCE);\n        barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    }\n    \n  error_1:\n    return;\n    #undef segred_group_sizze_19039\n}\n__kernel void vectorMulzisegmap_18904(__global int *global_failure,\n     ",
                   "                                 int64_t i_18404, __global\n                                      unsigned char *a_mem_20275, __global\n                                      unsigned char *b_mem_20276, __global\n                                      unsigned char *mem_20280)\n{\n    #define segmap_group_sizze_18913 (vectorMulzisegmap_group_sizze_18906)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18904 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18913 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = i_18404;\n    int64_t gtid_18903 = global_tid_20600;\n    int64_t remnant_20602 = global_tid_20600 - gtid_18903;\n    \n    if (slt64(gtid_18903, i_18404)) {\n        float x_18916 = ((__global float *) a_mem_20275)[gtid_18903];\n        float x_18917 = ((__global float *) b_mem_20276)[gtid_18903];\n        float defunc_1_f_res_18918 = x_18916 * x_18917;\n        \n        ((__global float *) mem_20280)[gtid_18903] = defunc_1_f_res_18918;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18913\n}\n__kernel void vectorNormzisegred_nonseg_19649(__global int *global_failure,\n                                              __local volatile\n                                              int64_t *red_arr_mem_20608_backing_aligned_0,\n                                              __local volatile\n                                              int64_t *sync_arr_mem_20606_backing_aligned_1,\n                                        ",
                   "      int64_t iz2083U_18590,\n                                              int64_t num_groups_19644,\n                                              int64_t num_threads_20600,\n                                              __global\n                                              unsigned char *v_mem_20275,\n                                              __global unsigned char *mem_20278,\n                                              __global\n                                              unsigned char *vectorNormzicounter_mem_20596,\n                                              __global\n                                              unsigned char *segred_tmp_mem_20598)\n{\n    #define segred_group_sizze_19642 (vectorNormzisegred_group_sizze_19641)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    __local volatile unsigned char *restrict red_arr_mem_20608_backing_1 =\n                                   (__local volatile\n                                    unsigned char *) red_arr_mem_20608_backing_aligned_0;\n    __local volatile unsigned char *restrict sync_arr_mem_20606_backing_0 =\n                                   (__local volatile\n                                    unsigned char *) sync_arr_mem_20606_backing_aligned_1;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20601;\n    int32_t local_tid_20602;\n    int64_t group_sizze_20605;\n    int32_t wave_sizze_20604;\n    int32_t group_tid_20603;\n    \n    global_tid_20601 = get_global_id(0);\n    local_tid_20602 = get_local_id(0);\n    group_sizze_20605 = get_local_size(0);\n    wave_sizze_20604 = LOCKSTEP_WIDTH;\n    group_tid_20603 = get_group_id(0);\n    \n    int32_t phys_tid_19649 = global_tid_20601;\n    __local unsigned char *sync_arr_mem_20606;\n    \n    sync_arr_mem_20606 = (__local unsigned char *) sync_arr_mem_20606_backing_0;\n    \n    __local unsigned char *red_arr_mem_20608;\n    \n    red_arr_mem_20608 = (__local unsigned char *) red_arr_mem_20608_",
                   "backing_1;\n    \n    int64_t dummy_19647 = (int64_t) 0;\n    int64_t gtid_19648 = (int64_t) 0;\n    float x_acc_20610;\n    int64_t chunk_sizze_20611 = smin64(sdiv_up64(iz2083U_18590,\n                                                 sext_i32_i64(sext_i64_i32(segred_group_sizze_19642 *\n                                                 num_groups_19644))),\n                                       sdiv_up64(iz2083U_18590 - phys_tid_19649,\n                                                 num_threads_20600));\n    float x_18593;\n    float x_18594;\n    \n    // neutral-initialise the accumulators\n    {\n        x_acc_20610 = 0.0F;\n    }\n    for (int64_t i_20615 = 0; i_20615 < chunk_sizze_20611; i_20615++) {\n        gtid_19648 = phys_tid_19649 + num_threads_20600 * i_20615;\n        // apply map function\n        {\n            float x_18596 = ((__global float *) v_mem_20275)[gtid_19648];\n            float defunc_1_f_res_18597 = x_18596 * x_18596;\n            \n            // save map-out results\n            { }\n            // load accumulator\n            {\n                x_18593 = x_acc_20610;\n            }\n            // load new values\n            {\n                x_18594 = defunc_1_f_res_18597;\n            }\n            // apply reduction operator\n            {\n                float defunc_1_op_res_18595 = x_18593 + x_18594;\n                \n                // store in accumulator\n                {\n                    x_acc_20610 = defunc_1_op_res_18595;\n                }\n            }\n        }\n    }\n    // to reduce current chunk, first store our result in memory\n    {\n        x_18593 = x_acc_20610;\n        ((__local float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n            x_18593;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    \n    int32_t offset_20616;\n    int32_t skip_waves_20617 = 1;\n    float x_20612;\n    float x_20613;\n    \n    offset_20616 = 0;\n    // participating threads read initial accumulator\n    {\n        if (slt32(local_tid_20602, sext_i64_i32(segred_g",
                   "roup_sizze_19642))) {\n            x_20612 = ((__local\n                        float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                    offset_20616)];\n        }\n    }\n    offset_20616 = 1;\n    while (slt32(offset_20616, wave_sizze_20604)) {\n        if (slt32(local_tid_20602 + offset_20616,\n                  sext_i64_i32(segred_group_sizze_19642)) && ((local_tid_20602 -\n                                                               squot32(local_tid_20602,\n                                                                       wave_sizze_20604) *\n                                                               wave_sizze_20604) &\n                                                              (2 *\n                                                               offset_20616 -\n                                                               1)) == 0) {\n            // read array element\n            {\n                x_20613 = ((volatile __local\n                            float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                        offset_20616)];\n            }\n            // apply reduction operation\n            {\n                float defunc_1_op_res_20614 = x_20612 + x_20613;\n                \n                x_20612 = defunc_1_op_res_20614;\n            }\n            // write result of operation\n            {\n                ((volatile __local\n                  float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                    x_20612;\n            }\n        }\n        offset_20616 *= 2;\n    }\n    while (slt32(skip_waves_20617,\n                 squot32(sext_i64_i32(segred_group_sizze_19642) +\n                         wave_sizze_20604 - 1, wave_sizze_20604))) {\n        barrier(CLK_LOCAL_MEM_FENCE);\n        offset_20616 = skip_waves_20617 * wave_sizze_20604;\n        if (slt32(local_tid_20602 + offset_20616,\n                  sext_i64_i32(segred_group_sizze_196",
                   "42)) && ((local_tid_20602 -\n                                                               squot32(local_tid_20602,\n                                                                       wave_sizze_20604) *\n                                                               wave_sizze_20604) ==\n                                                              0 &&\n                                                              (squot32(local_tid_20602,\n                                                                       wave_sizze_20604) &\n                                                               (2 *\n                                                                skip_waves_20617 -\n                                                                1)) == 0)) {\n            // read array element\n            {\n                x_20613 = ((__local\n                            float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                        offset_20616)];\n            }\n            // apply reduction operation\n            {\n                float defunc_1_op_res_20614 = x_20612 + x_20613;\n                \n                x_20612 = defunc_1_op_res_20614;\n            }\n            // write result of operation\n            {\n                ((__local\n                  float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                    x_20612;\n            }\n        }\n        skip_waves_20617 *= 2;\n    }\n    barrier(CLK_LOCAL_MEM_FENCE);\n    // first thread saves the result in accumulator\n    {\n        if (sext_i32_i64(local_tid_20602) == (int64_t) 0) {\n            x_acc_20610 = x_20612;\n        }\n    }\n    \n    int32_t old_counter_20618;\n    \n    // first thread in group saves group result to global memory\n    {\n        if (local_tid_20602 == 0) {\n            ((__global\n              float *) segred_tmp_mem_20598)[sext_i32_i64(group_tid_20603)] =\n                x_acc_20610;\n            mem_fence_global();\n            old",
                   "_counter_20618 = atomic_add_i32_global(&((volatile __global\n                                                         int *) vectorNormzicounter_mem_20596)[(int64_t) 0],\n                                                      (int) 1);\n            ((__local bool *) sync_arr_mem_20606)[(int64_t) 0] =\n                old_counter_20618 == num_groups_19644 - (int64_t) 1;\n        }\n    }\n    barrier(CLK_GLOBAL_MEM_FENCE | CLK_LOCAL_MEM_FENCE);\n    \n    bool is_last_group_20619 = ((__local\n                                 bool *) sync_arr_mem_20606)[(int64_t) 0];\n    \n    if (is_last_group_20619) {\n        if (local_tid_20602 == 0) {\n            old_counter_20618 = atomic_add_i32_global(&((volatile __global\n                                                         int *) vectorNormzicounter_mem_20596)[(int64_t) 0],\n                                                      (int) ((int64_t) 0 -\n                                                             num_groups_19644));\n        }\n        // read in the per-group-results\n        {\n            int64_t read_per_thread_20620 = sdiv_up64(num_groups_19644,\n                                                      segred_group_sizze_19642);\n            \n            x_18593 = 0.0F;\n            for (int64_t i_20621 = 0; i_20621 < read_per_thread_20620;\n                 i_20621++) {\n                int64_t group_res_id_20622 = sext_i32_i64(local_tid_20602) *\n                        read_per_thread_20620 + i_20621;\n                int64_t index_of_group_res_20623 = group_res_id_20622;\n                \n                if (slt64(group_res_id_20622, num_groups_19644)) {\n                    x_18594 = ((__global\n                                float *) segred_tmp_mem_20598)[index_of_group_res_20623];\n                    \n                    float defunc_1_op_res_18595 = x_18593 + x_18594;\n                    \n                    x_18593 = defunc_1_op_res_18595;\n                }\n            }\n        }\n        ((__local float *) red_arr_mem_20608)",
                   "[sext_i32_i64(local_tid_20602)] =\n            x_18593;\n        barrier(CLK_LOCAL_MEM_FENCE);\n        // reduce the per-group results\n        {\n            int32_t offset_20624;\n            int32_t skip_waves_20625 = 1;\n            float x_20612;\n            float x_20613;\n            \n            offset_20624 = 0;\n            // participating threads read initial accumulator\n            {\n                if (slt32(local_tid_20602,\n                          sext_i64_i32(segred_group_sizze_19642))) {\n                    x_20612 = ((__local\n                                float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                            offset_20624)];\n                }\n            }\n            offset_20624 = 1;\n            while (slt32(offset_20624, wave_sizze_20604)) {\n                if (slt32(local_tid_20602 + offset_20624,\n                          sext_i64_i32(segred_group_sizze_19642)) &&\n                    ((local_tid_20602 - squot32(local_tid_20602,\n                                                wave_sizze_20604) *\n                      wave_sizze_20604) & (2 * offset_20624 - 1)) == 0) {\n                    // read array element\n                    {\n                        x_20613 = ((volatile __local\n                                    float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                                offset_20624)];\n                    }\n                    // apply reduction operation\n                    {\n                        float defunc_1_op_res_20614 = x_20612 + x_20613;\n                        \n                        x_20612 = defunc_1_op_res_20614;\n                    }\n                    // write result of operation\n                    {\n                        ((volatile __local\n                          float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                            x_20612;\n                    }\n           ",
                   "     }\n                offset_20624 *= 2;\n            }\n            while (slt32(skip_waves_20625,\n                         squot32(sext_i64_i32(segred_group_sizze_19642) +\n                                 wave_sizze_20604 - 1, wave_sizze_20604))) {\n                barrier(CLK_LOCAL_MEM_FENCE);\n                offset_20624 = skip_waves_20625 * wave_sizze_20604;\n                if (slt32(local_tid_20602 + offset_20624,\n                          sext_i64_i32(segred_group_sizze_19642)) &&\n                    ((local_tid_20602 - squot32(local_tid_20602,\n                                                wave_sizze_20604) *\n                      wave_sizze_20604) == 0 && (squot32(local_tid_20602,\n                                                         wave_sizze_20604) &\n                                                 (2 * skip_waves_20625 - 1)) ==\n                     0)) {\n                    // read array element\n                    {\n                        x_20613 = ((__local\n                                    float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602 +\n                                                                offset_20624)];\n                    }\n                    // apply reduction operation\n                    {\n                        float defunc_1_op_res_20614 = x_20612 + x_20613;\n                        \n                        x_20612 = defunc_1_op_res_20614;\n                    }\n                    // write result of operation\n                    {\n                        ((__local\n                          float *) red_arr_mem_20608)[sext_i32_i64(local_tid_20602)] =\n                            x_20612;\n                    }\n                }\n                skip_waves_20625 *= 2;\n            }\n            // and back to memory with the final result\n            {\n                if (local_tid_20602 == 0) {\n                    ((__global float *) mem_20278)[(int64_t) 0] = x_20612;\n                }\n            }\n        }\n    }\n    \n ",
                   " error_1:\n    return;\n    #undef segred_group_sizze_19642\n}\n__kernel void vectorSgnzisegmap_18627(__global int *global_failure,\n                                      int64_t nz2081U_18327, __global\n                                      unsigned char *as_mem_20275, __global\n                                      unsigned char *mem_20279)\n{\n    #define segmap_group_sizze_18635 (vectorSgnzisegmap_group_sizze_18629)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18627 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18635 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = nz2081U_18327;\n    int64_t gtid_18626 = global_tid_20600;\n    int64_t remnant_20602 = global_tid_20600 - gtid_18626;\n    \n    if (slt64(gtid_18626, nz2081U_18327)) {\n        float x_18638 = ((__global float *) as_mem_20275)[gtid_18626];\n        float defunc_0_f_res_18639 = fsignum32(x_18638);\n        \n        ((__global float *) mem_20279)[gtid_18626] = defunc_0_f_res_18639;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18635\n}\n__kernel void vectorSubzisegmap_18657(__global int *global_failure,\n                                      int64_t i_18339, __global\n                                      unsigned char *a_mem_20275, __global\n                                      unsigned char *b_mem_20276, __global\n                                      unsigned char *mem_20280)\n{\n    #define segmap_group_sizze_18666 (vectorSubzisegmap_group_sizze_18",
                   "659)\n    \n    const int block_dim0 = 0;\n    const int block_dim1 = 1;\n    const int block_dim2 = 2;\n    \n    if (*global_failure >= 0)\n        return;\n    \n    int32_t global_tid_20595;\n    int32_t local_tid_20596;\n    int64_t group_sizze_20599;\n    int32_t wave_sizze_20598;\n    int32_t group_tid_20597;\n    \n    global_tid_20595 = get_global_id(0);\n    local_tid_20596 = get_local_id(0);\n    group_sizze_20599 = get_local_size(0);\n    wave_sizze_20598 = LOCKSTEP_WIDTH;\n    group_tid_20597 = get_group_id(0);\n    \n    int32_t phys_tid_18657 = global_tid_20595;\n    int64_t global_tid_20600 = sext_i32_i64(group_tid_20597) *\n            segmap_group_sizze_18666 + sext_i32_i64(local_tid_20596);\n    int64_t slice_20601 = i_18339;\n    int64_t gtid_18656 = global_tid_20600;\n    int64_t remnant_20602 = global_tid_20600 - gtid_18656;\n    \n    if (slt64(gtid_18656, i_18339)) {\n        float x_18669 = ((__global float *) a_mem_20275)[gtid_18656];\n        float x_18670 = ((__global float *) b_mem_20276)[gtid_18656];\n        float defunc_1_f_res_18671 = x_18669 - x_18670;\n        \n        ((__global float *) mem_20280)[gtid_18656] = defunc_1_f_res_18671;\n    }\n    \n  error_0:\n    return;\n    #undef segmap_group_sizze_18666\n}\n",
                   NULL};
static const char *tuning_param_names[] =
                  {"builtin#replicate_f64.group_size_20602",
                   "dot.segred_group_size_19179", "dot.segred_num_groups_19181",
                   "main.segmap_group_size_19204",
                   "main.segmap_group_size_19249",
                   "main.segmap_group_size_19337",
                   "main.segmap_group_size_19429",
                   "main.segmap_group_size_19506",
                   "main.segmap_group_size_19563",
                   "main.segmap_group_size_19581",
                   "matrixAbs.segmap_group_size_18685",
                   "matrixAdd.segmap_group_size_18796",
                   "matrixMatrixMul.Rx_19809", "matrixMatrixMul.Ry_19810",
                   "matrixMatrixMul.Tk_19806", "matrixMatrixMul.Tx_19807",
                   "matrixMatrixMul.Ty_19808",
                   "matrixMatrixMul.segmap_group_size_19056",
                   "matrixMatrixMul.segmap_num_groups_19058",
                   "matrixMatrixMul.segred_group_size_19112",
                   "matrixMatrixMul.segred_num_groups_19114",
                   "matrixMatrixMul.suff_outer_par_0",
                   "matrixMatrixMul.suff_outer_par_1",
                   "matrixMul.segmap_group_size_18876",
                   "matrixSgn.segmap_group_size_18722",
                   "matrixSub.segmap_group_size_18836",
                   "matrixVectorMul.segmap_group_size_18938",
                   "matrixVectorMul.segred_group_size_18964",
                   "matrixVectorMul.segred_num_groups_18966",
                   "matrixVectorMul.suff_outer_par_0",
                   "normalizeV.segmap_group_size_19663",
                   "normalizeV.segred_group_size_19651",
                   "normalizeV.segred_num_groups_19653",
                   "scaleM.segmap_group_size_18759",
                   "scaleV.segmap_group_size_18922",
                   "vectorAbs.segmap_group_size_18615",
                   "vectorAdd.segmap_group_size_18643",
                   "vectorMatrixMul.segmap_group_size_18997",
                   "vectorMatrixMul.segred_group_size_19023",
                   "vectorMatrixMul.segred_num_groups_19025",
                   "vectorMatrixMul.suff_outer_par_0",
                   "vectorMul.segmap_group_size_18906",
                   "vectorNorm.segred_group_size_19641",
                   "vectorNorm.segred_num_groups_19643",
                   "vectorSgn.segmap_group_size_18629",
                   "vectorSub.segmap_group_size_18659"};
static const char *tuning_param_vars[] =
                  {"builtinzhreplicate_f64zigroup_sizze_20602",
                   "dotzisegred_group_sizze_19179",
                   "dotzisegred_num_groups_19181",
                   "mainzisegmap_group_sizze_19204",
                   "mainzisegmap_group_sizze_19249",
                   "mainzisegmap_group_sizze_19337",
                   "mainzisegmap_group_sizze_19429",
                   "mainzisegmap_group_sizze_19506",
                   "mainzisegmap_group_sizze_19563",
                   "mainzisegmap_group_sizze_19581",
                   "matrixAbszisegmap_group_sizze_18685",
                   "matrixAddzisegmap_group_sizze_18796",
                   "matrixMatrixMulziRx_19809", "matrixMatrixMulziRy_19810",
                   "matrixMatrixMulziTk_19806", "matrixMatrixMulziTx_19807",
                   "matrixMatrixMulziTy_19808",
                   "matrixMatrixMulzisegmap_group_sizze_19056",
                   "matrixMatrixMulzisegmap_num_groups_19058",
                   "matrixMatrixMulzisegred_group_sizze_19112",
                   "matrixMatrixMulzisegred_num_groups_19114",
                   "matrixMatrixMulzisuff_outer_par_0",
                   "matrixMatrixMulzisuff_outer_par_1",
                   "matrixMulzisegmap_group_sizze_18876",
                   "matrixSgnzisegmap_group_sizze_18722",
                   "matrixSubzisegmap_group_sizze_18836",
                   "matrixVectorMulzisegmap_group_sizze_18938",
                   "matrixVectorMulzisegred_group_sizze_18964",
                   "matrixVectorMulzisegred_num_groups_18966",
                   "matrixVectorMulzisuff_outer_par_0",
                   "normalizzeVzisegmap_group_sizze_19663",
                   "normalizzeVzisegred_group_sizze_19651",
                   "normalizzeVzisegred_num_groups_19653",
                   "scaleMzisegmap_group_sizze_18759",
                   "scaleVzisegmap_group_sizze_18922",
                   "vectorAbszisegmap_group_sizze_18615",
                   "vectorAddzisegmap_group_sizze_18643",
                   "vectorMatrixMulzisegmap_group_sizze_18997",
                   "vectorMatrixMulzisegred_group_sizze_19023",
                   "vectorMatrixMulzisegred_num_groups_19025",
                   "vectorMatrixMulzisuff_outer_par_0",
                   "vectorMulzisegmap_group_sizze_18906",
                   "vectorNormzisegred_group_sizze_19641",
                   "vectorNormzisegred_num_groups_19643",
                   "vectorSgnzisegmap_group_sizze_18629",
                   "vectorSubzisegmap_group_sizze_18659"};
static const char *tuning_param_classes[] = {"group_size", "group_size",
                                             "num_groups", "group_size",
                                             "group_size", "group_size",
                                             "group_size", "group_size",
                                             "group_size", "group_size",
                                             "group_size", "group_size",
                                             "reg_tile_size", "reg_tile_size",
                                             "tile_size", "tile_size",
                                             "tile_size", "group_size",
                                             "num_groups", "group_size",
                                             "num_groups", "threshold(def,)",
                                             "threshold(def, !matrixMatrixMul.suff_outer_par_0)",
                                             "group_size", "group_size",
                                             "group_size", "group_size",
                                             "group_size", "num_groups",
                                             "threshold(def,)", "group_size",
                                             "group_size", "num_groups",
                                             "group_size", "group_size",
                                             "group_size", "group_size",
                                             "group_size", "group_size",
                                             "num_groups", "threshold(def,)",
                                             "group_size", "group_size",
                                             "num_groups", "group_size",
                                             "group_size"};
struct tuning_params {
    int64_t *builtinzhreplicate_f64zigroup_sizze_20602;
    int64_t *dotzisegred_group_sizze_19179;
    int64_t *dotzisegred_num_groups_19181;
    int64_t *mainzisegmap_group_sizze_19204;
    int64_t *mainzisegmap_group_sizze_19249;
    int64_t *mainzisegmap_group_sizze_19337;
    int64_t *mainzisegmap_group_sizze_19429;
    int64_t *mainzisegmap_group_sizze_19506;
    int64_t *mainzisegmap_group_sizze_19563;
    int64_t *mainzisegmap_group_sizze_19581;
    int64_t *matrixAbszisegmap_group_sizze_18685;
    int64_t *matrixAddzisegmap_group_sizze_18796;
    int64_t *matrixMatrixMulziRx_19809;
    int64_t *matrixMatrixMulziRy_19810;
    int64_t *matrixMatrixMulziTk_19806;
    int64_t *matrixMatrixMulziTx_19807;
    int64_t *matrixMatrixMulziTy_19808;
    int64_t *matrixMatrixMulzisegmap_group_sizze_19056;
    int64_t *matrixMatrixMulzisegmap_num_groups_19058;
    int64_t *matrixMatrixMulzisegred_group_sizze_19112;
    int64_t *matrixMatrixMulzisegred_num_groups_19114;
    int64_t *matrixMatrixMulzisuff_outer_par_0;
    int64_t *matrixMatrixMulzisuff_outer_par_1;
    int64_t *matrixMulzisegmap_group_sizze_18876;
    int64_t *matrixSgnzisegmap_group_sizze_18722;
    int64_t *matrixSubzisegmap_group_sizze_18836;
    int64_t *matrixVectorMulzisegmap_group_sizze_18938;
    int64_t *matrixVectorMulzisegred_group_sizze_18964;
    int64_t *matrixVectorMulzisegred_num_groups_18966;
    int64_t *matrixVectorMulzisuff_outer_par_0;
    int64_t *normalizzeVzisegmap_group_sizze_19663;
    int64_t *normalizzeVzisegred_group_sizze_19651;
    int64_t *normalizzeVzisegred_num_groups_19653;
    int64_t *scaleMzisegmap_group_sizze_18759;
    int64_t *scaleVzisegmap_group_sizze_18922;
    int64_t *vectorAbszisegmap_group_sizze_18615;
    int64_t *vectorAddzisegmap_group_sizze_18643;
    int64_t *vectorMatrixMulzisegmap_group_sizze_18997;
    int64_t *vectorMatrixMulzisegred_group_sizze_19023;
    int64_t *vectorMatrixMulzisegred_num_groups_19025;
    int64_t *vectorMatrixMulzisuff_outer_par_0;
    int64_t *vectorMulzisegmap_group_sizze_18906;
    int64_t *vectorNormzisegred_group_sizze_19641;
    int64_t *vectorNormzisegred_num_groups_19643;
    int64_t *vectorSgnzisegmap_group_sizze_18629;
    int64_t *vectorSubzisegmap_group_sizze_18659;
};
struct futhark_context_config {
    struct opencl_config opencl;
    int64_t tuning_params[46];
    int num_build_opts;
    const char **build_opts;
};
struct futhark_context_config *futhark_context_config_new(void)
{
    struct futhark_context_config *cfg =
                                  (struct futhark_context_config *) malloc(sizeof(struct futhark_context_config));
    
    if (cfg == NULL)
        return NULL;
    cfg->num_build_opts = 0;
    cfg->build_opts = (const char **) malloc(sizeof(const char *));
    cfg->build_opts[0] = NULL;
    cfg->tuning_params[0] = 0;
    cfg->tuning_params[1] = 0;
    cfg->tuning_params[2] = 0;
    cfg->tuning_params[3] = 0;
    cfg->tuning_params[4] = 0;
    cfg->tuning_params[5] = 0;
    cfg->tuning_params[6] = 0;
    cfg->tuning_params[7] = 0;
    cfg->tuning_params[8] = 0;
    cfg->tuning_params[9] = 0;
    cfg->tuning_params[10] = 0;
    cfg->tuning_params[11] = 0;
    cfg->tuning_params[12] = 0;
    cfg->tuning_params[13] = 0;
    cfg->tuning_params[14] = 0;
    cfg->tuning_params[15] = 0;
    cfg->tuning_params[16] = 0;
    cfg->tuning_params[17] = 0;
    cfg->tuning_params[18] = 0;
    cfg->tuning_params[19] = 0;
    cfg->tuning_params[20] = 0;
    cfg->tuning_params[21] = 0;
    cfg->tuning_params[22] = 0;
    cfg->tuning_params[23] = 0;
    cfg->tuning_params[24] = 0;
    cfg->tuning_params[25] = 0;
    cfg->tuning_params[26] = 0;
    cfg->tuning_params[27] = 0;
    cfg->tuning_params[28] = 0;
    cfg->tuning_params[29] = 0;
    cfg->tuning_params[30] = 0;
    cfg->tuning_params[31] = 0;
    cfg->tuning_params[32] = 0;
    cfg->tuning_params[33] = 0;
    cfg->tuning_params[34] = 0;
    cfg->tuning_params[35] = 0;
    cfg->tuning_params[36] = 0;
    cfg->tuning_params[37] = 0;
    cfg->tuning_params[38] = 0;
    cfg->tuning_params[39] = 0;
    cfg->tuning_params[40] = 0;
    cfg->tuning_params[41] = 0;
    cfg->tuning_params[42] = 0;
    cfg->tuning_params[43] = 0;
    cfg->tuning_params[44] = 0;
    cfg->tuning_params[45] = 0;
    opencl_config_init(&cfg->opencl, 46, tuning_param_names, tuning_param_vars,
                       cfg->tuning_params, tuning_param_classes);
    return cfg;
}
void futhark_context_config_free(struct futhark_context_config *cfg)
{
    free(cfg->build_opts);
    free(cfg);
}
void futhark_context_config_add_build_option(struct futhark_context_config *cfg,
                                             const char *opt)
{
    cfg->build_opts[cfg->num_build_opts] = opt;
    cfg->num_build_opts++;
    cfg->build_opts = (const char **) realloc(cfg->build_opts,
                                              (cfg->num_build_opts + 1) *
                                              sizeof(const char *));
    cfg->build_opts[cfg->num_build_opts] = NULL;
}
void futhark_context_config_set_debugging(struct futhark_context_config *cfg,
                                          int flag)
{
    cfg->opencl.profiling = cfg->opencl.logging = cfg->opencl.debugging = flag;
}
void futhark_context_config_set_profiling(struct futhark_context_config *cfg,
                                          int flag)
{
    cfg->opencl.profiling = flag;
}
void futhark_context_config_set_logging(struct futhark_context_config *cfg,
                                        int flag)
{
    cfg->opencl.logging = flag;
}
void futhark_context_config_set_device(struct futhark_context_config *cfg, const
                                       char *s)
{
    set_preferred_device(&cfg->opencl, s);
}
void futhark_context_config_set_platform(struct futhark_context_config *cfg,
                                         const char *s)
{
    set_preferred_platform(&cfg->opencl, s);
}
void futhark_context_config_select_device_interactively(struct futhark_context_config *cfg)
{
    select_device_interactively(&cfg->opencl);
}
void futhark_context_config_list_devices(struct futhark_context_config *cfg)
{
    (void) cfg;
    list_devices();
}
void futhark_context_config_dump_program_to(struct futhark_context_config *cfg,
                                            const char *path)
{
    cfg->opencl.dump_program_to = path;
}
void futhark_context_config_load_program_from(struct futhark_context_config *cfg,
                                              const char *path)
{
    cfg->opencl.load_program_from = path;
}
void futhark_context_config_dump_binary_to(struct futhark_context_config *cfg,
                                           const char *path)
{
    cfg->opencl.dump_binary_to = path;
}
void futhark_context_config_load_binary_from(struct futhark_context_config *cfg,
                                             const char *path)
{
    cfg->opencl.load_binary_from = path;
}
void futhark_context_config_set_default_group_size(struct futhark_context_config *cfg,
                                                   int size)
{
    cfg->opencl.default_group_size = size;
    cfg->opencl.default_group_size_changed = 1;
}
void futhark_context_config_set_default_num_groups(struct futhark_context_config *cfg,
                                                   int num)
{
    cfg->opencl.default_num_groups = num;
}
void futhark_context_config_set_default_tile_size(struct futhark_context_config *cfg,
                                                  int size)
{
    cfg->opencl.default_tile_size = size;
    cfg->opencl.default_tile_size_changed = 1;
}
void futhark_context_config_set_default_reg_tile_size(struct futhark_context_config *cfg,
                                                      int size)
{
    cfg->opencl.default_reg_tile_size = size;
}
void futhark_context_config_set_default_threshold(struct futhark_context_config *cfg,
                                                  int size)
{
    cfg->opencl.default_threshold = size;
}
int futhark_context_config_set_tuning_param(struct futhark_context_config *cfg,
                                            const char *param_name,
                                            size_t new_value)
{
    for (int i = 0; i < 46; i++) {
        if (strcmp(param_name, tuning_param_names[i]) == 0) {
            cfg->tuning_params[i] = new_value;
            return 0;
        }
    }
    if (strcmp(param_name, "default_group_size") == 0) {
        cfg->opencl.default_group_size = new_value;
        return 0;
    }
    if (strcmp(param_name, "default_num_groups") == 0) {
        cfg->opencl.default_num_groups = new_value;
        return 0;
    }
    if (strcmp(param_name, "default_threshold") == 0) {
        cfg->opencl.default_threshold = new_value;
        return 0;
    }
    if (strcmp(param_name, "default_tile_size") == 0) {
        cfg->opencl.default_tile_size = new_value;
        return 0;
    }
    if (strcmp(param_name, "default_reg_tile_size") == 0) {
        cfg->opencl.default_reg_tile_size = new_value;
        return 0;
    }
    return 1;
}
struct futhark_context {
    int detail_memory;
    int debugging;
    int profiling;
    int profiling_paused;
    int logging;
    lock_t lock;
    char *error;
    FILE *log;
    int64_t peak_mem_usage_device;
    int64_t cur_mem_usage_device;
    int64_t peak_mem_usage_default;
    int64_t cur_mem_usage_default;
    struct {
        int dummy;
    } constants;
    struct memblock_device dotzicounter_mem_20596;
    struct memblock_device matrixMatrixMulzicounter_mem_20718;
    struct memblock_device matrixVectorMulzicounter_mem_20641;
    struct memblock_device normalizzeVzicounter_mem_20596;
    struct memblock_device vectorMatrixMulzicounter_mem_20641;
    struct memblock_device vectorNormzicounter_mem_20596;
    int total_runs;
    long total_runtime;
    cl_kernel builtinzhreplicate_f64zireplicate_20599;
    cl_kernel dotzisegred_nonseg_19187;
    cl_kernel gpu_map_transpose_f32;
    cl_kernel gpu_map_transpose_f32_low_height;
    cl_kernel gpu_map_transpose_f32_low_width;
    cl_kernel gpu_map_transpose_f32_small;
    cl_kernel mainzisegmap_19201;
    cl_kernel mainzisegmap_19247;
    cl_kernel mainzisegmap_19333;
    cl_kernel mainzisegmap_19425;
    cl_kernel mainzisegmap_19503;
    cl_kernel mainzisegmap_19559;
    cl_kernel mainzisegmap_19578;
    cl_kernel matrixAbszisegmap_18682;
    cl_kernel matrixAddzisegmap_18793;
    cl_kernel matrixMatrixMulzisegmap_19054;
    cl_kernel matrixMatrixMulzisegmap_intragroup_19830;
    cl_kernel matrixMatrixMulzisegred_large_19118;
    cl_kernel matrixMatrixMulzisegred_small_19118;
    cl_kernel matrixMulzisegmap_18873;
    cl_kernel matrixSgnzisegmap_18719;
    cl_kernel matrixSubzisegmap_18833;
    cl_kernel matrixVectorMulzisegmap_intragroup_19807;
    cl_kernel matrixVectorMulzisegred_large_18970;
    cl_kernel matrixVectorMulzisegred_small_18970;
    cl_kernel normalizzeVzisegmap_19661;
    cl_kernel normalizzeVzisegred_nonseg_19659;
    cl_kernel scaleMzisegmap_18756;
    cl_kernel scaleVzisegmap_18920;
    cl_kernel vectorAbszisegmap_18613;
    cl_kernel vectorAddzisegmap_18641;
    cl_kernel vectorMatrixMulzisegmap_intragroup_19807;
    cl_kernel vectorMatrixMulzisegred_large_19029;
    cl_kernel vectorMatrixMulzisegred_small_19029;
    cl_kernel vectorMulzisegmap_18904;
    cl_kernel vectorNormzisegred_nonseg_19649;
    cl_kernel vectorSgnzisegmap_18627;
    cl_kernel vectorSubzisegmap_18657;
    int64_t copy_dev_to_dev_total_runtime;
    int copy_dev_to_dev_runs;
    int64_t copy_dev_to_host_total_runtime;
    int copy_dev_to_host_runs;
    int64_t copy_host_to_dev_total_runtime;
    int copy_host_to_dev_runs;
    int64_t copy_scalar_to_dev_total_runtime;
    int copy_scalar_to_dev_runs;
    int64_t copy_scalar_from_dev_total_runtime;
    int copy_scalar_from_dev_runs;
    int64_t builtinzhreplicate_f64zireplicate_20599_total_runtime;
    int builtinzhreplicate_f64zireplicate_20599_runs;
    int64_t dotzisegred_nonseg_19187_total_runtime;
    int dotzisegred_nonseg_19187_runs;
    int64_t gpu_map_transpose_f32_total_runtime;
    int gpu_map_transpose_f32_runs;
    int64_t gpu_map_transpose_f32_low_height_total_runtime;
    int gpu_map_transpose_f32_low_height_runs;
    int64_t gpu_map_transpose_f32_low_width_total_runtime;
    int gpu_map_transpose_f32_low_width_runs;
    int64_t gpu_map_transpose_f32_small_total_runtime;
    int gpu_map_transpose_f32_small_runs;
    int64_t mainzisegmap_19201_total_runtime;
    int mainzisegmap_19201_runs;
    int64_t mainzisegmap_19247_total_runtime;
    int mainzisegmap_19247_runs;
    int64_t mainzisegmap_19333_total_runtime;
    int mainzisegmap_19333_runs;
    int64_t mainzisegmap_19425_total_runtime;
    int mainzisegmap_19425_runs;
    int64_t mainzisegmap_19503_total_runtime;
    int mainzisegmap_19503_runs;
    int64_t mainzisegmap_19559_total_runtime;
    int mainzisegmap_19559_runs;
    int64_t mainzisegmap_19578_total_runtime;
    int mainzisegmap_19578_runs;
    int64_t matrixAbszisegmap_18682_total_runtime;
    int matrixAbszisegmap_18682_runs;
    int64_t matrixAddzisegmap_18793_total_runtime;
    int matrixAddzisegmap_18793_runs;
    int64_t matrixMatrixMulzisegmap_19054_total_runtime;
    int matrixMatrixMulzisegmap_19054_runs;
    int64_t matrixMatrixMulzisegmap_intragroup_19830_total_runtime;
    int matrixMatrixMulzisegmap_intragroup_19830_runs;
    int64_t matrixMatrixMulzisegred_large_19118_total_runtime;
    int matrixMatrixMulzisegred_large_19118_runs;
    int64_t matrixMatrixMulzisegred_small_19118_total_runtime;
    int matrixMatrixMulzisegred_small_19118_runs;
    int64_t matrixMulzisegmap_18873_total_runtime;
    int matrixMulzisegmap_18873_runs;
    int64_t matrixSgnzisegmap_18719_total_runtime;
    int matrixSgnzisegmap_18719_runs;
    int64_t matrixSubzisegmap_18833_total_runtime;
    int matrixSubzisegmap_18833_runs;
    int64_t matrixVectorMulzisegmap_intragroup_19807_total_runtime;
    int matrixVectorMulzisegmap_intragroup_19807_runs;
    int64_t matrixVectorMulzisegred_large_18970_total_runtime;
    int matrixVectorMulzisegred_large_18970_runs;
    int64_t matrixVectorMulzisegred_small_18970_total_runtime;
    int matrixVectorMulzisegred_small_18970_runs;
    int64_t normalizzeVzisegmap_19661_total_runtime;
    int normalizzeVzisegmap_19661_runs;
    int64_t normalizzeVzisegred_nonseg_19659_total_runtime;
    int normalizzeVzisegred_nonseg_19659_runs;
    int64_t scaleMzisegmap_18756_total_runtime;
    int scaleMzisegmap_18756_runs;
    int64_t scaleVzisegmap_18920_total_runtime;
    int scaleVzisegmap_18920_runs;
    int64_t vectorAbszisegmap_18613_total_runtime;
    int vectorAbszisegmap_18613_runs;
    int64_t vectorAddzisegmap_18641_total_runtime;
    int vectorAddzisegmap_18641_runs;
    int64_t vectorMatrixMulzisegmap_intragroup_19807_total_runtime;
    int vectorMatrixMulzisegmap_intragroup_19807_runs;
    int64_t vectorMatrixMulzisegred_large_19029_total_runtime;
    int vectorMatrixMulzisegred_large_19029_runs;
    int64_t vectorMatrixMulzisegred_small_19029_total_runtime;
    int vectorMatrixMulzisegred_small_19029_runs;
    int64_t vectorMulzisegmap_18904_total_runtime;
    int vectorMulzisegmap_18904_runs;
    int64_t vectorNormzisegred_nonseg_19649_total_runtime;
    int vectorNormzisegred_nonseg_19649_runs;
    int64_t vectorSgnzisegmap_18627_total_runtime;
    int vectorSgnzisegmap_18627_runs;
    int64_t vectorSubzisegmap_18657_total_runtime;
    int vectorSubzisegmap_18657_runs;
    cl_mem global_failure;
    cl_mem global_failure_args;
    struct opencl_context opencl;
    struct tuning_params tuning_params;
    cl_int failure_is_an_option;
};
void post_opencl_setup(struct opencl_context *ctx,
                       struct opencl_device_option *option)
{
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name,
                                            "NVIDIA CUDA") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 32;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name,
                                            "AMD Accelerated Parallel Processing") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 32;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->lockstep_width = 1;
    }
    if ((ctx->cfg.default_num_groups == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS,
                        sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val,
                        NULL);
        ctx->cfg.default_num_groups = 4 * MAX_COMPUTE_UNITS_val;
    }
    if ((ctx->cfg.default_group_size == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_group_size = 256;
    }
    if ((ctx->cfg.default_tile_size == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_tile_size = 32;
    }
    if ((ctx->cfg.default_reg_tile_size == 0 && strstr(option->platform_name,
                                                       "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_GPU) == CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_reg_tile_size = 2;
    }
    if ((ctx->cfg.default_threshold == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_GPU) ==
        CL_DEVICE_TYPE_GPU) {
        ctx->cfg.default_threshold = 32768;
    }
    if ((ctx->lockstep_width == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) ==
        CL_DEVICE_TYPE_CPU) {
        ctx->lockstep_width = 1;
    }
    if ((ctx->cfg.default_num_groups == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS,
                        sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val,
                        NULL);
        ctx->cfg.default_num_groups = MAX_COMPUTE_UNITS_val;
    }
    if ((ctx->cfg.default_group_size == 0 && strstr(option->platform_name,
                                                    "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->cfg.default_group_size = 32;
    }
    if ((ctx->cfg.default_tile_size == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) ==
        CL_DEVICE_TYPE_CPU) {
        ctx->cfg.default_tile_size = 4;
    }
    if ((ctx->cfg.default_reg_tile_size == 0 && strstr(option->platform_name,
                                                       "") != NULL) &&
        (option->device_type & CL_DEVICE_TYPE_CPU) == CL_DEVICE_TYPE_CPU) {
        ctx->cfg.default_reg_tile_size = 1;
    }
    if ((ctx->cfg.default_threshold == 0 && strstr(option->platform_name, "") !=
         NULL) && (option->device_type & CL_DEVICE_TYPE_CPU) ==
        CL_DEVICE_TYPE_CPU) {
        size_t MAX_COMPUTE_UNITS_val = 0;
        
        clGetDeviceInfo(ctx->device, CL_DEVICE_MAX_COMPUTE_UNITS,
                        sizeof(MAX_COMPUTE_UNITS_val), &MAX_COMPUTE_UNITS_val,
                        NULL);
        ctx->cfg.default_threshold = MAX_COMPUTE_UNITS_val;
    }
}
static void init_context_early(struct futhark_context_config *cfg,
                               struct futhark_context *ctx)
{
    ctx->opencl.cfg = cfg->opencl;
    ctx->detail_memory = cfg->opencl.debugging;
    ctx->debugging = cfg->opencl.debugging;
    ctx->profiling = cfg->opencl.profiling;
    ctx->profiling_paused = 0;
    ctx->logging = cfg->opencl.logging;
    ctx->error = NULL;
    ctx->log = stderr;
    ctx->opencl.profiling_records_capacity = 200;
    ctx->opencl.profiling_records_used = 0;
    ctx->opencl.profiling_records =
        malloc(ctx->opencl.profiling_records_capacity *
        sizeof(struct profiling_record));
    create_lock(&ctx->lock);
    ctx->failure_is_an_option = 0;
    ctx->peak_mem_usage_device = 0;
    ctx->cur_mem_usage_device = 0;
    ctx->peak_mem_usage_default = 0;
    ctx->cur_mem_usage_default = 0;
    ctx->total_runs = 0;
    ctx->total_runtime = 0;
    ctx->copy_dev_to_dev_total_runtime = 0;
    ctx->copy_dev_to_dev_runs = 0;
    ctx->copy_dev_to_host_total_runtime = 0;
    ctx->copy_dev_to_host_runs = 0;
    ctx->copy_host_to_dev_total_runtime = 0;
    ctx->copy_host_to_dev_runs = 0;
    ctx->copy_scalar_to_dev_total_runtime = 0;
    ctx->copy_scalar_to_dev_runs = 0;
    ctx->copy_scalar_from_dev_total_runtime = 0;
    ctx->copy_scalar_from_dev_runs = 0;
    ctx->builtinzhreplicate_f64zireplicate_20599_total_runtime = 0;
    ctx->builtinzhreplicate_f64zireplicate_20599_runs = 0;
    ctx->dotzisegred_nonseg_19187_total_runtime = 0;
    ctx->dotzisegred_nonseg_19187_runs = 0;
    ctx->gpu_map_transpose_f32_total_runtime = 0;
    ctx->gpu_map_transpose_f32_runs = 0;
    ctx->gpu_map_transpose_f32_low_height_total_runtime = 0;
    ctx->gpu_map_transpose_f32_low_height_runs = 0;
    ctx->gpu_map_transpose_f32_low_width_total_runtime = 0;
    ctx->gpu_map_transpose_f32_low_width_runs = 0;
    ctx->gpu_map_transpose_f32_small_total_runtime = 0;
    ctx->gpu_map_transpose_f32_small_runs = 0;
    ctx->mainzisegmap_19201_total_runtime = 0;
    ctx->mainzisegmap_19201_runs = 0;
    ctx->mainzisegmap_19247_total_runtime = 0;
    ctx->mainzisegmap_19247_runs = 0;
    ctx->mainzisegmap_19333_total_runtime = 0;
    ctx->mainzisegmap_19333_runs = 0;
    ctx->mainzisegmap_19425_total_runtime = 0;
    ctx->mainzisegmap_19425_runs = 0;
    ctx->mainzisegmap_19503_total_runtime = 0;
    ctx->mainzisegmap_19503_runs = 0;
    ctx->mainzisegmap_19559_total_runtime = 0;
    ctx->mainzisegmap_19559_runs = 0;
    ctx->mainzisegmap_19578_total_runtime = 0;
    ctx->mainzisegmap_19578_runs = 0;
    ctx->matrixAbszisegmap_18682_total_runtime = 0;
    ctx->matrixAbszisegmap_18682_runs = 0;
    ctx->matrixAddzisegmap_18793_total_runtime = 0;
    ctx->matrixAddzisegmap_18793_runs = 0;
    ctx->matrixMatrixMulzisegmap_19054_total_runtime = 0;
    ctx->matrixMatrixMulzisegmap_19054_runs = 0;
    ctx->matrixMatrixMulzisegmap_intragroup_19830_total_runtime = 0;
    ctx->matrixMatrixMulzisegmap_intragroup_19830_runs = 0;
    ctx->matrixMatrixMulzisegred_large_19118_total_runtime = 0;
    ctx->matrixMatrixMulzisegred_large_19118_runs = 0;
    ctx->matrixMatrixMulzisegred_small_19118_total_runtime = 0;
    ctx->matrixMatrixMulzisegred_small_19118_runs = 0;
    ctx->matrixMulzisegmap_18873_total_runtime = 0;
    ctx->matrixMulzisegmap_18873_runs = 0;
    ctx->matrixSgnzisegmap_18719_total_runtime = 0;
    ctx->matrixSgnzisegmap_18719_runs = 0;
    ctx->matrixSubzisegmap_18833_total_runtime = 0;
    ctx->matrixSubzisegmap_18833_runs = 0;
    ctx->matrixVectorMulzisegmap_intragroup_19807_total_runtime = 0;
    ctx->matrixVectorMulzisegmap_intragroup_19807_runs = 0;
    ctx->matrixVectorMulzisegred_large_18970_total_runtime = 0;
    ctx->matrixVectorMulzisegred_large_18970_runs = 0;
    ctx->matrixVectorMulzisegred_small_18970_total_runtime = 0;
    ctx->matrixVectorMulzisegred_small_18970_runs = 0;
    ctx->normalizzeVzisegmap_19661_total_runtime = 0;
    ctx->normalizzeVzisegmap_19661_runs = 0;
    ctx->normalizzeVzisegred_nonseg_19659_total_runtime = 0;
    ctx->normalizzeVzisegred_nonseg_19659_runs = 0;
    ctx->scaleMzisegmap_18756_total_runtime = 0;
    ctx->scaleMzisegmap_18756_runs = 0;
    ctx->scaleVzisegmap_18920_total_runtime = 0;
    ctx->scaleVzisegmap_18920_runs = 0;
    ctx->vectorAbszisegmap_18613_total_runtime = 0;
    ctx->vectorAbszisegmap_18613_runs = 0;
    ctx->vectorAddzisegmap_18641_total_runtime = 0;
    ctx->vectorAddzisegmap_18641_runs = 0;
    ctx->vectorMatrixMulzisegmap_intragroup_19807_total_runtime = 0;
    ctx->vectorMatrixMulzisegmap_intragroup_19807_runs = 0;
    ctx->vectorMatrixMulzisegred_large_19029_total_runtime = 0;
    ctx->vectorMatrixMulzisegred_large_19029_runs = 0;
    ctx->vectorMatrixMulzisegred_small_19029_total_runtime = 0;
    ctx->vectorMatrixMulzisegred_small_19029_runs = 0;
    ctx->vectorMulzisegmap_18904_total_runtime = 0;
    ctx->vectorMulzisegmap_18904_runs = 0;
    ctx->vectorNormzisegred_nonseg_19649_total_runtime = 0;
    ctx->vectorNormzisegred_nonseg_19649_runs = 0;
    ctx->vectorSgnzisegmap_18627_total_runtime = 0;
    ctx->vectorSgnzisegmap_18627_runs = 0;
    ctx->vectorSubzisegmap_18657_total_runtime = 0;
    ctx->vectorSubzisegmap_18657_runs = 0;
}
static int init_context_late(struct futhark_context_config *cfg,
                             struct futhark_context *ctx, cl_program prog)
{
    cl_int error;
    cl_int no_error = -1;
    
    ctx->global_failure = clCreateBuffer(ctx->opencl.ctx, CL_MEM_READ_WRITE |
                                         CL_MEM_COPY_HOST_PTR, sizeof(cl_int),
                                         &no_error, &error);
    OPENCL_SUCCEED_OR_RETURN(error);
    // The +1 is to avoid zero-byte allocations.
    ctx->global_failure_args = clCreateBuffer(ctx->opencl.ctx,
                                              CL_MEM_READ_WRITE,
                                              sizeof(int64_t) * (0 + 1), NULL,
                                              &error);
    OPENCL_SUCCEED_OR_RETURN(error);
    {
        ctx->builtinzhreplicate_f64zireplicate_20599 = clCreateKernel(prog,
                                                                      "builtinzhreplicate_f64zireplicate_20599",
                                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "builtin#replicate_f64.replicate_20599");
    }
    {
        ctx->dotzisegred_nonseg_19187 = clCreateKernel(prog,
                                                       "dotzisegred_nonseg_19187",
                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "dot.segred_nonseg_19187");
    }
    {
        ctx->gpu_map_transpose_f32 = clCreateKernel(prog,
                                                    "gpu_map_transpose_f32",
                                                    &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "gpu_map_transpose_f32");
    }
    {
        ctx->gpu_map_transpose_f32_low_height = clCreateKernel(prog,
                                                               "gpu_map_transpose_f32_low_height",
                                                               &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "gpu_map_transpose_f32_low_height");
    }
    {
        ctx->gpu_map_transpose_f32_low_width = clCreateKernel(prog,
                                                              "gpu_map_transpose_f32_low_width",
                                                              &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "gpu_map_transpose_f32_low_width");
    }
    {
        ctx->gpu_map_transpose_f32_small = clCreateKernel(prog,
                                                          "gpu_map_transpose_f32_small",
                                                          &error);
        OPENCL_SUCCEED_FATAL(error);
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "gpu_map_transpose_f32_small");
    }
    {
        ctx->mainzisegmap_19201 = clCreateKernel(prog, "mainzisegmap_19201",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19201, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19201");
    }
    {
        ctx->mainzisegmap_19247 = clCreateKernel(prog, "mainzisegmap_19247",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19247, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19247");
    }
    {
        ctx->mainzisegmap_19333 = clCreateKernel(prog, "mainzisegmap_19333",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19333, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19333");
    }
    {
        ctx->mainzisegmap_19425 = clCreateKernel(prog, "mainzisegmap_19425",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19425, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19425");
    }
    {
        ctx->mainzisegmap_19503 = clCreateKernel(prog, "mainzisegmap_19503",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19503, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19503");
    }
    {
        ctx->mainzisegmap_19559 = clCreateKernel(prog, "mainzisegmap_19559",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19559, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19559");
    }
    {
        ctx->mainzisegmap_19578 = clCreateKernel(prog, "mainzisegmap_19578",
                                                 &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->mainzisegmap_19578, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "main.segmap_19578");
    }
    {
        ctx->matrixAbszisegmap_18682 = clCreateKernel(prog,
                                                      "matrixAbszisegmap_18682",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixAbszisegmap_18682, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "matrixAbs.segmap_18682");
    }
    {
        ctx->matrixAddzisegmap_18793 = clCreateKernel(prog,
                                                      "matrixAddzisegmap_18793",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixAddzisegmap_18793, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "matrixAdd.segmap_18793");
    }
    {
        ctx->matrixMatrixMulzisegmap_19054 = clCreateKernel(prog,
                                                            "matrixMatrixMulzisegmap_19054",
                                                            &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixMatrixMul.segmap_19054");
    }
    {
        ctx->matrixMatrixMulzisegmap_intragroup_19830 = clCreateKernel(prog,
                                                                       "matrixMatrixMulzisegmap_intragroup_19830",
                                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixMatrixMul.segmap_intragroup_19830");
    }
    {
        ctx->matrixMatrixMulzisegred_large_19118 = clCreateKernel(prog,
                                                                  "matrixMatrixMulzisegred_large_19118",
                                                                  &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixMatrixMul.segred_large_19118");
    }
    {
        ctx->matrixMatrixMulzisegred_small_19118 = clCreateKernel(prog,
                                                                  "matrixMatrixMulzisegred_small_19118",
                                                                  &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixMatrixMul.segred_small_19118");
    }
    {
        ctx->matrixMulzisegmap_18873 = clCreateKernel(prog,
                                                      "matrixMulzisegmap_18873",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixMulzisegmap_18873, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "matrixMul.segmap_18873");
    }
    {
        ctx->matrixSgnzisegmap_18719 = clCreateKernel(prog,
                                                      "matrixSgnzisegmap_18719",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixSgnzisegmap_18719, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "matrixSgn.segmap_18719");
    }
    {
        ctx->matrixSubzisegmap_18833 = clCreateKernel(prog,
                                                      "matrixSubzisegmap_18833",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixSubzisegmap_18833, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "matrixSub.segmap_18833");
    }
    {
        ctx->matrixVectorMulzisegmap_intragroup_19807 = clCreateKernel(prog,
                                                                       "matrixVectorMulzisegmap_intragroup_19807",
                                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixVectorMul.segmap_intragroup_19807");
    }
    {
        ctx->matrixVectorMulzisegred_large_18970 = clCreateKernel(prog,
                                                                  "matrixVectorMulzisegred_large_18970",
                                                                  &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixVectorMul.segred_large_18970");
    }
    {
        ctx->matrixVectorMulzisegred_small_18970 = clCreateKernel(prog,
                                                                  "matrixVectorMulzisegred_small_18970",
                                                                  &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "matrixVectorMul.segred_small_18970");
    }
    {
        ctx->normalizzeVzisegmap_19661 = clCreateKernel(prog,
                                                        "normalizzeVzisegmap_19661",
                                                        &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->normalizzeVzisegmap_19661, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "normalizeV.segmap_19661");
    }
    {
        ctx->normalizzeVzisegred_nonseg_19659 = clCreateKernel(prog,
                                                               "normalizzeVzisegred_nonseg_19659",
                                                               &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "normalizeV.segred_nonseg_19659");
    }
    {
        ctx->scaleMzisegmap_18756 = clCreateKernel(prog, "scaleMzisegmap_18756",
                                                   &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->scaleMzisegmap_18756, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "scaleM.segmap_18756");
    }
    {
        ctx->scaleVzisegmap_18920 = clCreateKernel(prog, "scaleVzisegmap_18920",
                                                   &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->scaleVzisegmap_18920, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "scaleV.segmap_18920");
    }
    {
        ctx->vectorAbszisegmap_18613 = clCreateKernel(prog,
                                                      "vectorAbszisegmap_18613",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorAbszisegmap_18613, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "vectorAbs.segmap_18613");
    }
    {
        ctx->vectorAddzisegmap_18641 = clCreateKernel(prog,
                                                      "vectorAddzisegmap_18641",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorAddzisegmap_18641, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "vectorAdd.segmap_18641");
    }
    {
        ctx->vectorMatrixMulzisegmap_intragroup_19807 = clCreateKernel(prog,
                                                                       "vectorMatrixMulzisegmap_intragroup_19807",
                                                                       &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "vectorMatrixMul.segmap_intragroup_19807");
    }
    {
        ctx->vectorMatrixMulzisegred_large_19029 = clCreateKernel(prog,
                                                                  "vectorMatrixMulzisegred_large_19029",
                                                                  &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "vectorMatrixMul.segred_large_19029");
    }
    {
        ctx->vectorMatrixMulzisegred_small_19029 = clCreateKernel(prog,
                                                                  "vectorMatrixMulzisegred_small_19029",
                                                                  &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "vectorMatrixMul.segred_small_19029");
    }
    {
        ctx->vectorMulzisegmap_18904 = clCreateKernel(prog,
                                                      "vectorMulzisegmap_18904",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorMulzisegmap_18904, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "vectorMul.segmap_18904");
    }
    {
        ctx->vectorNormzisegred_nonseg_19649 = clCreateKernel(prog,
                                                              "vectorNormzisegred_nonseg_19649",
                                                              &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            0, sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n",
                    "vectorNorm.segred_nonseg_19649");
    }
    {
        ctx->vectorSgnzisegmap_18627 = clCreateKernel(prog,
                                                      "vectorSgnzisegmap_18627",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorSgnzisegmap_18627, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "vectorSgn.segmap_18627");
    }
    {
        ctx->vectorSubzisegmap_18657 = clCreateKernel(prog,
                                                      "vectorSubzisegmap_18657",
                                                      &error);
        OPENCL_SUCCEED_FATAL(error);
        OPENCL_SUCCEED_FATAL(clSetKernelArg(ctx->vectorSubzisegmap_18657, 0,
                                            sizeof(cl_mem),
                                            &ctx->global_failure));
        if (ctx->debugging)
            fprintf(ctx->log, "Created kernel %s.\n", "vectorSub.segmap_18657");
    }
    {
        cl_int success;
        
        ctx->dotzicounter_mem_20596.references = NULL;
        ctx->dotzicounter_mem_20596.size = 0;
        ctx->dotzicounter_mem_20596.mem = clCreateBuffer(ctx->opencl.ctx,
                                                         CL_MEM_READ_WRITE,
                                                         (10 > 0 ? 10 : 1) *
                                                         sizeof(int32_t), NULL,
                                                         &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->dotzicounter_mem_20596.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          dotzicounter_mem_realtype_20782,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->matrixMatrixMulzicounter_mem_20718.references = NULL;
        ctx->matrixMatrixMulzicounter_mem_20718.size = 0;
        ctx->matrixMatrixMulzicounter_mem_20718.mem =
            clCreateBuffer(ctx->opencl.ctx, CL_MEM_READ_WRITE, (10240 >
                                                                0 ? 10240 : 1) *
                           sizeof(int32_t), NULL, &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10240 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->matrixMatrixMulzicounter_mem_20718.mem,
                                                          CL_TRUE, 0, 10240 *
                                                          sizeof(int32_t),
                                                          matrixMatrixMulzicounter_mem_realtype_20853,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->matrixVectorMulzicounter_mem_20641.references = NULL;
        ctx->matrixVectorMulzicounter_mem_20641.size = 0;
        ctx->matrixVectorMulzicounter_mem_20641.mem =
            clCreateBuffer(ctx->opencl.ctx, CL_MEM_READ_WRITE, (10240 >
                                                                0 ? 10240 : 1) *
                           sizeof(int32_t), NULL, &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10240 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->matrixVectorMulzicounter_mem_20641.mem,
                                                          CL_TRUE, 0, 10240 *
                                                          sizeof(int32_t),
                                                          matrixVectorMulzicounter_mem_realtype_20888,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->normalizzeVzicounter_mem_20596.references = NULL;
        ctx->normalizzeVzicounter_mem_20596.size = 0;
        ctx->normalizzeVzicounter_mem_20596.mem =
            clCreateBuffer(ctx->opencl.ctx, CL_MEM_READ_WRITE, (10 >
                                                                0 ? 10 : 1) *
                           sizeof(int32_t), NULL, &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->normalizzeVzicounter_mem_20596.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          normalizzeVzicounter_mem_realtype_20895,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->vectorMatrixMulzicounter_mem_20641.references = NULL;
        ctx->vectorMatrixMulzicounter_mem_20641.size = 0;
        ctx->vectorMatrixMulzicounter_mem_20641.mem =
            clCreateBuffer(ctx->opencl.ctx, CL_MEM_READ_WRITE, (10240 >
                                                                0 ? 10240 : 1) *
                           sizeof(int32_t), NULL, &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10240 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->vectorMatrixMulzicounter_mem_20641.mem,
                                                          CL_TRUE, 0, 10240 *
                                                          sizeof(int32_t),
                                                          vectorMatrixMulzicounter_mem_realtype_20942,
                                                          0, NULL, NULL));
    }
    {
        cl_int success;
        
        ctx->vectorNormzicounter_mem_20596.references = NULL;
        ctx->vectorNormzicounter_mem_20596.size = 0;
        ctx->vectorNormzicounter_mem_20596.mem = clCreateBuffer(ctx->opencl.ctx,
                                                                CL_MEM_READ_WRITE,
                                                                (10 >
                                                                 0 ? 10 : 1) *
                                                                sizeof(int32_t),
                                                                NULL, &success);
        OPENCL_SUCCEED_OR_RETURN(success);
        if (10 > 0)
            OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                          ctx->vectorNormzicounter_mem_20596.mem,
                                                          CL_TRUE, 0, 10 *
                                                          sizeof(int32_t),
                                                          vectorNormzicounter_mem_realtype_20955,
                                                          0, NULL, NULL));
    }
    ctx->tuning_params.builtinzhreplicate_f64zigroup_sizze_20602 =
        &cfg->tuning_params[0];
    ctx->tuning_params.dotzisegred_group_sizze_19179 = &cfg->tuning_params[1];
    ctx->tuning_params.dotzisegred_num_groups_19181 = &cfg->tuning_params[2];
    ctx->tuning_params.mainzisegmap_group_sizze_19204 = &cfg->tuning_params[3];
    ctx->tuning_params.mainzisegmap_group_sizze_19249 = &cfg->tuning_params[4];
    ctx->tuning_params.mainzisegmap_group_sizze_19337 = &cfg->tuning_params[5];
    ctx->tuning_params.mainzisegmap_group_sizze_19429 = &cfg->tuning_params[6];
    ctx->tuning_params.mainzisegmap_group_sizze_19506 = &cfg->tuning_params[7];
    ctx->tuning_params.mainzisegmap_group_sizze_19563 = &cfg->tuning_params[8];
    ctx->tuning_params.mainzisegmap_group_sizze_19581 = &cfg->tuning_params[9];
    ctx->tuning_params.matrixAbszisegmap_group_sizze_18685 =
        &cfg->tuning_params[10];
    ctx->tuning_params.matrixAddzisegmap_group_sizze_18796 =
        &cfg->tuning_params[11];
    ctx->tuning_params.matrixMatrixMulziRx_19809 = &cfg->tuning_params[12];
    ctx->tuning_params.matrixMatrixMulziRy_19810 = &cfg->tuning_params[13];
    ctx->tuning_params.matrixMatrixMulziTk_19806 = &cfg->tuning_params[14];
    ctx->tuning_params.matrixMatrixMulziTx_19807 = &cfg->tuning_params[15];
    ctx->tuning_params.matrixMatrixMulziTy_19808 = &cfg->tuning_params[16];
    ctx->tuning_params.matrixMatrixMulzisegmap_group_sizze_19056 =
        &cfg->tuning_params[17];
    ctx->tuning_params.matrixMatrixMulzisegmap_num_groups_19058 =
        &cfg->tuning_params[18];
    ctx->tuning_params.matrixMatrixMulzisegred_group_sizze_19112 =
        &cfg->tuning_params[19];
    ctx->tuning_params.matrixMatrixMulzisegred_num_groups_19114 =
        &cfg->tuning_params[20];
    ctx->tuning_params.matrixMatrixMulzisuff_outer_par_0 =
        &cfg->tuning_params[21];
    ctx->tuning_params.matrixMatrixMulzisuff_outer_par_1 =
        &cfg->tuning_params[22];
    ctx->tuning_params.matrixMulzisegmap_group_sizze_18876 =
        &cfg->tuning_params[23];
    ctx->tuning_params.matrixSgnzisegmap_group_sizze_18722 =
        &cfg->tuning_params[24];
    ctx->tuning_params.matrixSubzisegmap_group_sizze_18836 =
        &cfg->tuning_params[25];
    ctx->tuning_params.matrixVectorMulzisegmap_group_sizze_18938 =
        &cfg->tuning_params[26];
    ctx->tuning_params.matrixVectorMulzisegred_group_sizze_18964 =
        &cfg->tuning_params[27];
    ctx->tuning_params.matrixVectorMulzisegred_num_groups_18966 =
        &cfg->tuning_params[28];
    ctx->tuning_params.matrixVectorMulzisuff_outer_par_0 =
        &cfg->tuning_params[29];
    ctx->tuning_params.normalizzeVzisegmap_group_sizze_19663 =
        &cfg->tuning_params[30];
    ctx->tuning_params.normalizzeVzisegred_group_sizze_19651 =
        &cfg->tuning_params[31];
    ctx->tuning_params.normalizzeVzisegred_num_groups_19653 =
        &cfg->tuning_params[32];
    ctx->tuning_params.scaleMzisegmap_group_sizze_18759 =
        &cfg->tuning_params[33];
    ctx->tuning_params.scaleVzisegmap_group_sizze_18922 =
        &cfg->tuning_params[34];
    ctx->tuning_params.vectorAbszisegmap_group_sizze_18615 =
        &cfg->tuning_params[35];
    ctx->tuning_params.vectorAddzisegmap_group_sizze_18643 =
        &cfg->tuning_params[36];
    ctx->tuning_params.vectorMatrixMulzisegmap_group_sizze_18997 =
        &cfg->tuning_params[37];
    ctx->tuning_params.vectorMatrixMulzisegred_group_sizze_19023 =
        &cfg->tuning_params[38];
    ctx->tuning_params.vectorMatrixMulzisegred_num_groups_19025 =
        &cfg->tuning_params[39];
    ctx->tuning_params.vectorMatrixMulzisuff_outer_par_0 =
        &cfg->tuning_params[40];
    ctx->tuning_params.vectorMulzisegmap_group_sizze_18906 =
        &cfg->tuning_params[41];
    ctx->tuning_params.vectorNormzisegred_group_sizze_19641 =
        &cfg->tuning_params[42];
    ctx->tuning_params.vectorNormzisegred_num_groups_19643 =
        &cfg->tuning_params[43];
    ctx->tuning_params.vectorSgnzisegmap_group_sizze_18629 =
        &cfg->tuning_params[44];
    ctx->tuning_params.vectorSubzisegmap_group_sizze_18659 =
        &cfg->tuning_params[45];
    init_constants(ctx);
    // Clear the free list of any deallocations that occurred while initialising constants.
    OPENCL_SUCCEED_OR_RETURN(opencl_free_all(&ctx->opencl));
    // The program will be properly freed after all the kernels have also been freed.
    OPENCL_SUCCEED_OR_RETURN(clReleaseProgram(prog));
    return futhark_context_sync(ctx);
}
struct futhark_context *futhark_context_new(struct futhark_context_config *cfg)
{
    struct futhark_context *ctx =
                           (struct futhark_context *) malloc(sizeof(struct futhark_context));
    
    if (ctx == NULL)
        return NULL;
    
    int required_types = 0;
    
    required_types |= OPENCL_F64;
    init_context_early(cfg, ctx);
    
    cl_program prog = setup_opencl(&ctx->opencl, opencl_program, required_types,
                                   cfg->build_opts);
    
    init_context_late(cfg, ctx, prog);
    return ctx;
}
struct futhark_context *futhark_context_new_with_command_queue(struct futhark_context_config *cfg,
                                                               cl_command_queue queue)
{
    struct futhark_context *ctx =
                           (struct futhark_context *) malloc(sizeof(struct futhark_context));
    
    if (ctx == NULL)
        return NULL;
    
    int required_types = 0;
    
    required_types |= OPENCL_F64;
    init_context_early(cfg, ctx);
    
    cl_program prog = setup_opencl_with_command_queue(&ctx->opencl, queue,
                                                      opencl_program,
                                                      required_types,
                                                      cfg->build_opts);
    
    init_context_late(cfg, ctx, prog);
    return ctx;
}
void futhark_context_free(struct futhark_context *ctx)
{
    free_constants(ctx);
    free_lock(&ctx->lock);
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->builtinzhreplicate_f64zireplicate_20599));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->dotzisegred_nonseg_19187));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32_low_height));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32_low_width));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->gpu_map_transpose_f32_small));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19201));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19247));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19333));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19425));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19503));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19559));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->mainzisegmap_19578));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixAbszisegmap_18682));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixAddzisegmap_18793));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixMatrixMulzisegmap_19054));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixMatrixMulzisegmap_intragroup_19830));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixMatrixMulzisegred_large_19118));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixMatrixMulzisegred_small_19118));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixMulzisegmap_18873));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixSgnzisegmap_18719));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixSubzisegmap_18833));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixVectorMulzisegmap_intragroup_19807));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixVectorMulzisegred_large_18970));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->matrixVectorMulzisegred_small_18970));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->normalizzeVzisegmap_19661));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->normalizzeVzisegred_nonseg_19659));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->scaleMzisegmap_18756));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->scaleVzisegmap_18920));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorAbszisegmap_18613));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorAddzisegmap_18641));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorMatrixMulzisegmap_intragroup_19807));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorMatrixMulzisegred_large_19029));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorMatrixMulzisegred_small_19029));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorMulzisegmap_18904));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorNormzisegred_nonseg_19649));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorSgnzisegmap_18627));
    OPENCL_SUCCEED_FATAL(clReleaseKernel(ctx->vectorSubzisegmap_18657));
    teardown_opencl(&ctx->opencl);
    free(ctx);
}
int futhark_context_sync(struct futhark_context *ctx)
{
    cl_int failure_idx = -1;
    
    if (ctx->failure_is_an_option) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     ctx->global_failure,
                                                     CL_FALSE, 0,
                                                     sizeof(cl_int),
                                                     &failure_idx, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_scalar_from_dev_runs,
                                                                                               &ctx->copy_scalar_from_dev_total_runtime)));
        ctx->failure_is_an_option = 0;
    }
    OPENCL_SUCCEED_OR_RETURN(clFinish(ctx->opencl.queue));
    if (failure_idx >= 0) {
        cl_int no_failure = -1;
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      ctx->global_failure,
                                                      CL_TRUE, 0,
                                                      sizeof(cl_int),
                                                      &no_failure, 0, NULL,
                                                      NULL));
        
        int64_t args[0 + 1];
        
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     ctx->global_failure_args,
                                                     CL_TRUE, 0, sizeof(args),
                                                     &args, 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_host_runs,
                                                                                               &ctx->copy_dev_to_host_total_runtime)));
        switch (failure_idx) { }
        return 1;
    }
    return 0;
}
cl_command_queue futhark_context_get_command_queue(struct futhark_context *ctx)
{
    return ctx->opencl.queue;
}
static int memblock_unref_device(struct futhark_context *ctx,
                                 struct memblock_device *block, const
                                 char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log,
                    "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n",
                    desc, block->desc, "space 'device'", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_device -= block->size;
            OPENCL_SUCCEED_OR_RETURN(opencl_free(&ctx->opencl, block->mem,
                                                 desc));
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log,
                        "%lld bytes freed (now allocated: %lld bytes)\n",
                        (long long) block->size,
                        (long long) ctx->cur_mem_usage_device);
        }
        block->references = NULL;
    }
    return 0;
}
static int memblock_alloc_device(struct futhark_context *ctx,
                                 struct memblock_device *block, int64_t size,
                                 const char *desc)
{
    if (size < 0)
        futhark_panic(1,
                      "Negative allocation of %lld bytes attempted for %s in %s.\n",
                      (long long) size, desc, "space 'device'",
                      ctx->cur_mem_usage_device);
    
    int ret = memblock_unref_device(ctx, block, desc);
    
    ctx->cur_mem_usage_device += size;
    if (ctx->detail_memory)
        fprintf(ctx->log,
                "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)",
                (long long) size, desc, "space 'device'",
                (long long) ctx->cur_mem_usage_device);
    if (ctx->cur_mem_usage_device > ctx->peak_mem_usage_device) {
        ctx->peak_mem_usage_device = ctx->cur_mem_usage_device;
        if (ctx->detail_memory)
            fprintf(ctx->log, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(ctx->log, ".\n");
    OPENCL_SUCCEED_OR_RETURN(opencl_alloc(&ctx->opencl, (size_t) size, desc,
                                          &block->mem));
    block->references = (int *) malloc(sizeof(int));
    *block->references = 1;
    block->size = size;
    block->desc = desc;
    return ret;
}
static int memblock_set_device(struct futhark_context *ctx,
                               struct memblock_device *lhs,
                               struct memblock_device *rhs, const
                               char *lhs_desc)
{
    int ret = memblock_unref_device(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
static int memblock_unref(struct futhark_context *ctx, struct memblock *block,
                          const char *desc)
{
    if (block->references != NULL) {
        *block->references -= 1;
        if (ctx->detail_memory)
            fprintf(ctx->log,
                    "Unreferencing block %s (allocated as %s) in %s: %d references remaining.\n",
                    desc, block->desc, "default space", *block->references);
        if (*block->references == 0) {
            ctx->cur_mem_usage_default -= block->size;
            free(block->mem);
            free(block->references);
            if (ctx->detail_memory)
                fprintf(ctx->log,
                        "%lld bytes freed (now allocated: %lld bytes)\n",
                        (long long) block->size,
                        (long long) ctx->cur_mem_usage_default);
        }
        block->references = NULL;
    }
    return 0;
}
static int memblock_alloc(struct futhark_context *ctx, struct memblock *block,
                          int64_t size, const char *desc)
{
    if (size < 0)
        futhark_panic(1,
                      "Negative allocation of %lld bytes attempted for %s in %s.\n",
                      (long long) size, desc, "default space",
                      ctx->cur_mem_usage_default);
    
    int ret = memblock_unref(ctx, block, desc);
    
    ctx->cur_mem_usage_default += size;
    if (ctx->detail_memory)
        fprintf(ctx->log,
                "Allocating %lld bytes for %s in %s (then allocated: %lld bytes)",
                (long long) size, desc, "default space",
                (long long) ctx->cur_mem_usage_default);
    if (ctx->cur_mem_usage_default > ctx->peak_mem_usage_default) {
        ctx->peak_mem_usage_default = ctx->cur_mem_usage_default;
        if (ctx->detail_memory)
            fprintf(ctx->log, " (new peak).\n");
    } else if (ctx->detail_memory)
        fprintf(ctx->log, ".\n");
    block->mem = (unsigned char *) malloc((size_t) size);
    block->references = (int *) malloc(sizeof(int));
    *block->references = 1;
    block->size = size;
    block->desc = desc;
    return ret;
}
static int memblock_set(struct futhark_context *ctx, struct memblock *lhs,
                        struct memblock *rhs, const char *lhs_desc)
{
    int ret = memblock_unref(ctx, lhs, lhs_desc);
    
    if (rhs->references != NULL)
        (*rhs->references)++;
    *lhs = *rhs;
    return ret;
}
int futhark_get_tuning_param_count(void)
{
    return sizeof(tuning_param_names) / sizeof(tuning_param_names[0]);
}
const char *futhark_get_tuning_param_name(int i)
{
    return tuning_param_names[i];
}
const char *futhark_get_tuning_param_class(int i)
{
    return tuning_param_classes[i];
}
char *futhark_context_report(struct futhark_context *ctx)
{
    if (futhark_context_sync(ctx) != 0)
        return NULL;
    
    struct str_builder builder;
    
    str_builder_init(&builder);
    if (ctx->detail_memory || ctx->profiling || ctx->logging) {
        str_builder(&builder,
                    "Peak memory usage for space 'device': %lld bytes.\n",
                    (long long) ctx->peak_mem_usage_device);
        { }
    }
    if (ctx->profiling) {
        OPENCL_SUCCEED_FATAL(opencl_tally_profiling_records(&ctx->opencl));
        str_builder(&builder,
                    "copy_dev_to_dev                         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_dev_to_dev_runs,
                    (long) ctx->copy_dev_to_dev_total_runtime /
                    (ctx->copy_dev_to_dev_runs !=
                     0 ? ctx->copy_dev_to_dev_runs : 1),
                    (long) ctx->copy_dev_to_dev_total_runtime);
        ctx->total_runtime += ctx->copy_dev_to_dev_total_runtime;
        ctx->total_runs += ctx->copy_dev_to_dev_runs;
        str_builder(&builder,
                    "copy_dev_to_host                        ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_dev_to_host_runs,
                    (long) ctx->copy_dev_to_host_total_runtime /
                    (ctx->copy_dev_to_host_runs !=
                     0 ? ctx->copy_dev_to_host_runs : 1),
                    (long) ctx->copy_dev_to_host_total_runtime);
        ctx->total_runtime += ctx->copy_dev_to_host_total_runtime;
        ctx->total_runs += ctx->copy_dev_to_host_runs;
        str_builder(&builder,
                    "copy_host_to_dev                        ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_host_to_dev_runs,
                    (long) ctx->copy_host_to_dev_total_runtime /
                    (ctx->copy_host_to_dev_runs !=
                     0 ? ctx->copy_host_to_dev_runs : 1),
                    (long) ctx->copy_host_to_dev_total_runtime);
        ctx->total_runtime += ctx->copy_host_to_dev_total_runtime;
        ctx->total_runs += ctx->copy_host_to_dev_runs;
        str_builder(&builder,
                    "copy_scalar_to_dev                      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_scalar_to_dev_runs,
                    (long) ctx->copy_scalar_to_dev_total_runtime /
                    (ctx->copy_scalar_to_dev_runs !=
                     0 ? ctx->copy_scalar_to_dev_runs : 1),
                    (long) ctx->copy_scalar_to_dev_total_runtime);
        ctx->total_runtime += ctx->copy_scalar_to_dev_total_runtime;
        ctx->total_runs += ctx->copy_scalar_to_dev_runs;
        str_builder(&builder,
                    "copy_scalar_from_dev                    ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->copy_scalar_from_dev_runs,
                    (long) ctx->copy_scalar_from_dev_total_runtime /
                    (ctx->copy_scalar_from_dev_runs !=
                     0 ? ctx->copy_scalar_from_dev_runs : 1),
                    (long) ctx->copy_scalar_from_dev_total_runtime);
        ctx->total_runtime += ctx->copy_scalar_from_dev_total_runtime;
        ctx->total_runs += ctx->copy_scalar_from_dev_runs;
        str_builder(&builder,
                    "builtin#replicate_f64.replicate_20599   ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->builtinzhreplicate_f64zireplicate_20599_runs,
                    (long) ctx->builtinzhreplicate_f64zireplicate_20599_total_runtime /
                    (ctx->builtinzhreplicate_f64zireplicate_20599_runs !=
                     0 ? ctx->builtinzhreplicate_f64zireplicate_20599_runs : 1),
                    (long) ctx->builtinzhreplicate_f64zireplicate_20599_total_runtime);
        ctx->total_runtime +=
            ctx->builtinzhreplicate_f64zireplicate_20599_total_runtime;
        ctx->total_runs += ctx->builtinzhreplicate_f64zireplicate_20599_runs;
        str_builder(&builder,
                    "dot.segred_nonseg_19187                 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->dotzisegred_nonseg_19187_runs,
                    (long) ctx->dotzisegred_nonseg_19187_total_runtime /
                    (ctx->dotzisegred_nonseg_19187_runs !=
                     0 ? ctx->dotzisegred_nonseg_19187_runs : 1),
                    (long) ctx->dotzisegred_nonseg_19187_total_runtime);
        ctx->total_runtime += ctx->dotzisegred_nonseg_19187_total_runtime;
        ctx->total_runs += ctx->dotzisegred_nonseg_19187_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32                   ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_runs,
                    (long) ctx->gpu_map_transpose_f32_total_runtime /
                    (ctx->gpu_map_transpose_f32_runs !=
                     0 ? ctx->gpu_map_transpose_f32_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_total_runtime);
        ctx->total_runtime += ctx->gpu_map_transpose_f32_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32_low_height        ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_low_height_runs,
                    (long) ctx->gpu_map_transpose_f32_low_height_total_runtime /
                    (ctx->gpu_map_transpose_f32_low_height_runs !=
                     0 ? ctx->gpu_map_transpose_f32_low_height_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_low_height_total_runtime);
        ctx->total_runtime +=
            ctx->gpu_map_transpose_f32_low_height_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_low_height_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32_low_width         ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_low_width_runs,
                    (long) ctx->gpu_map_transpose_f32_low_width_total_runtime /
                    (ctx->gpu_map_transpose_f32_low_width_runs !=
                     0 ? ctx->gpu_map_transpose_f32_low_width_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_low_width_total_runtime);
        ctx->total_runtime +=
            ctx->gpu_map_transpose_f32_low_width_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_low_width_runs;
        str_builder(&builder,
                    "gpu_map_transpose_f32_small             ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->gpu_map_transpose_f32_small_runs,
                    (long) ctx->gpu_map_transpose_f32_small_total_runtime /
                    (ctx->gpu_map_transpose_f32_small_runs !=
                     0 ? ctx->gpu_map_transpose_f32_small_runs : 1),
                    (long) ctx->gpu_map_transpose_f32_small_total_runtime);
        ctx->total_runtime += ctx->gpu_map_transpose_f32_small_total_runtime;
        ctx->total_runs += ctx->gpu_map_transpose_f32_small_runs;
        str_builder(&builder,
                    "main.segmap_19201                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19201_runs,
                    (long) ctx->mainzisegmap_19201_total_runtime /
                    (ctx->mainzisegmap_19201_runs !=
                     0 ? ctx->mainzisegmap_19201_runs : 1),
                    (long) ctx->mainzisegmap_19201_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19201_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19201_runs;
        str_builder(&builder,
                    "main.segmap_19247                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19247_runs,
                    (long) ctx->mainzisegmap_19247_total_runtime /
                    (ctx->mainzisegmap_19247_runs !=
                     0 ? ctx->mainzisegmap_19247_runs : 1),
                    (long) ctx->mainzisegmap_19247_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19247_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19247_runs;
        str_builder(&builder,
                    "main.segmap_19333                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19333_runs,
                    (long) ctx->mainzisegmap_19333_total_runtime /
                    (ctx->mainzisegmap_19333_runs !=
                     0 ? ctx->mainzisegmap_19333_runs : 1),
                    (long) ctx->mainzisegmap_19333_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19333_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19333_runs;
        str_builder(&builder,
                    "main.segmap_19425                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19425_runs,
                    (long) ctx->mainzisegmap_19425_total_runtime /
                    (ctx->mainzisegmap_19425_runs !=
                     0 ? ctx->mainzisegmap_19425_runs : 1),
                    (long) ctx->mainzisegmap_19425_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19425_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19425_runs;
        str_builder(&builder,
                    "main.segmap_19503                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19503_runs,
                    (long) ctx->mainzisegmap_19503_total_runtime /
                    (ctx->mainzisegmap_19503_runs !=
                     0 ? ctx->mainzisegmap_19503_runs : 1),
                    (long) ctx->mainzisegmap_19503_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19503_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19503_runs;
        str_builder(&builder,
                    "main.segmap_19559                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19559_runs,
                    (long) ctx->mainzisegmap_19559_total_runtime /
                    (ctx->mainzisegmap_19559_runs !=
                     0 ? ctx->mainzisegmap_19559_runs : 1),
                    (long) ctx->mainzisegmap_19559_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19559_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19559_runs;
        str_builder(&builder,
                    "main.segmap_19578                       ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->mainzisegmap_19578_runs,
                    (long) ctx->mainzisegmap_19578_total_runtime /
                    (ctx->mainzisegmap_19578_runs !=
                     0 ? ctx->mainzisegmap_19578_runs : 1),
                    (long) ctx->mainzisegmap_19578_total_runtime);
        ctx->total_runtime += ctx->mainzisegmap_19578_total_runtime;
        ctx->total_runs += ctx->mainzisegmap_19578_runs;
        str_builder(&builder,
                    "matrixAbs.segmap_18682                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixAbszisegmap_18682_runs,
                    (long) ctx->matrixAbszisegmap_18682_total_runtime /
                    (ctx->matrixAbszisegmap_18682_runs !=
                     0 ? ctx->matrixAbszisegmap_18682_runs : 1),
                    (long) ctx->matrixAbszisegmap_18682_total_runtime);
        ctx->total_runtime += ctx->matrixAbszisegmap_18682_total_runtime;
        ctx->total_runs += ctx->matrixAbszisegmap_18682_runs;
        str_builder(&builder,
                    "matrixAdd.segmap_18793                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixAddzisegmap_18793_runs,
                    (long) ctx->matrixAddzisegmap_18793_total_runtime /
                    (ctx->matrixAddzisegmap_18793_runs !=
                     0 ? ctx->matrixAddzisegmap_18793_runs : 1),
                    (long) ctx->matrixAddzisegmap_18793_total_runtime);
        ctx->total_runtime += ctx->matrixAddzisegmap_18793_total_runtime;
        ctx->total_runs += ctx->matrixAddzisegmap_18793_runs;
        str_builder(&builder,
                    "matrixMatrixMul.segmap_19054            ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixMatrixMulzisegmap_19054_runs,
                    (long) ctx->matrixMatrixMulzisegmap_19054_total_runtime /
                    (ctx->matrixMatrixMulzisegmap_19054_runs !=
                     0 ? ctx->matrixMatrixMulzisegmap_19054_runs : 1),
                    (long) ctx->matrixMatrixMulzisegmap_19054_total_runtime);
        ctx->total_runtime += ctx->matrixMatrixMulzisegmap_19054_total_runtime;
        ctx->total_runs += ctx->matrixMatrixMulzisegmap_19054_runs;
        str_builder(&builder,
                    "matrixMatrixMul.segmap_intragroup_19830 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixMatrixMulzisegmap_intragroup_19830_runs,
                    (long) ctx->matrixMatrixMulzisegmap_intragroup_19830_total_runtime /
                    (ctx->matrixMatrixMulzisegmap_intragroup_19830_runs !=
                     0 ? ctx->matrixMatrixMulzisegmap_intragroup_19830_runs : 1),
                    (long) ctx->matrixMatrixMulzisegmap_intragroup_19830_total_runtime);
        ctx->total_runtime +=
            ctx->matrixMatrixMulzisegmap_intragroup_19830_total_runtime;
        ctx->total_runs += ctx->matrixMatrixMulzisegmap_intragroup_19830_runs;
        str_builder(&builder,
                    "matrixMatrixMul.segred_large_19118      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixMatrixMulzisegred_large_19118_runs,
                    (long) ctx->matrixMatrixMulzisegred_large_19118_total_runtime /
                    (ctx->matrixMatrixMulzisegred_large_19118_runs !=
                     0 ? ctx->matrixMatrixMulzisegred_large_19118_runs : 1),
                    (long) ctx->matrixMatrixMulzisegred_large_19118_total_runtime);
        ctx->total_runtime +=
            ctx->matrixMatrixMulzisegred_large_19118_total_runtime;
        ctx->total_runs += ctx->matrixMatrixMulzisegred_large_19118_runs;
        str_builder(&builder,
                    "matrixMatrixMul.segred_small_19118      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixMatrixMulzisegred_small_19118_runs,
                    (long) ctx->matrixMatrixMulzisegred_small_19118_total_runtime /
                    (ctx->matrixMatrixMulzisegred_small_19118_runs !=
                     0 ? ctx->matrixMatrixMulzisegred_small_19118_runs : 1),
                    (long) ctx->matrixMatrixMulzisegred_small_19118_total_runtime);
        ctx->total_runtime +=
            ctx->matrixMatrixMulzisegred_small_19118_total_runtime;
        ctx->total_runs += ctx->matrixMatrixMulzisegred_small_19118_runs;
        str_builder(&builder,
                    "matrixMul.segmap_18873                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixMulzisegmap_18873_runs,
                    (long) ctx->matrixMulzisegmap_18873_total_runtime /
                    (ctx->matrixMulzisegmap_18873_runs !=
                     0 ? ctx->matrixMulzisegmap_18873_runs : 1),
                    (long) ctx->matrixMulzisegmap_18873_total_runtime);
        ctx->total_runtime += ctx->matrixMulzisegmap_18873_total_runtime;
        ctx->total_runs += ctx->matrixMulzisegmap_18873_runs;
        str_builder(&builder,
                    "matrixSgn.segmap_18719                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixSgnzisegmap_18719_runs,
                    (long) ctx->matrixSgnzisegmap_18719_total_runtime /
                    (ctx->matrixSgnzisegmap_18719_runs !=
                     0 ? ctx->matrixSgnzisegmap_18719_runs : 1),
                    (long) ctx->matrixSgnzisegmap_18719_total_runtime);
        ctx->total_runtime += ctx->matrixSgnzisegmap_18719_total_runtime;
        ctx->total_runs += ctx->matrixSgnzisegmap_18719_runs;
        str_builder(&builder,
                    "matrixSub.segmap_18833                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixSubzisegmap_18833_runs,
                    (long) ctx->matrixSubzisegmap_18833_total_runtime /
                    (ctx->matrixSubzisegmap_18833_runs !=
                     0 ? ctx->matrixSubzisegmap_18833_runs : 1),
                    (long) ctx->matrixSubzisegmap_18833_total_runtime);
        ctx->total_runtime += ctx->matrixSubzisegmap_18833_total_runtime;
        ctx->total_runs += ctx->matrixSubzisegmap_18833_runs;
        str_builder(&builder,
                    "matrixVectorMul.segmap_intragroup_19807 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixVectorMulzisegmap_intragroup_19807_runs,
                    (long) ctx->matrixVectorMulzisegmap_intragroup_19807_total_runtime /
                    (ctx->matrixVectorMulzisegmap_intragroup_19807_runs !=
                     0 ? ctx->matrixVectorMulzisegmap_intragroup_19807_runs : 1),
                    (long) ctx->matrixVectorMulzisegmap_intragroup_19807_total_runtime);
        ctx->total_runtime +=
            ctx->matrixVectorMulzisegmap_intragroup_19807_total_runtime;
        ctx->total_runs += ctx->matrixVectorMulzisegmap_intragroup_19807_runs;
        str_builder(&builder,
                    "matrixVectorMul.segred_large_18970      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixVectorMulzisegred_large_18970_runs,
                    (long) ctx->matrixVectorMulzisegred_large_18970_total_runtime /
                    (ctx->matrixVectorMulzisegred_large_18970_runs !=
                     0 ? ctx->matrixVectorMulzisegred_large_18970_runs : 1),
                    (long) ctx->matrixVectorMulzisegred_large_18970_total_runtime);
        ctx->total_runtime +=
            ctx->matrixVectorMulzisegred_large_18970_total_runtime;
        ctx->total_runs += ctx->matrixVectorMulzisegred_large_18970_runs;
        str_builder(&builder,
                    "matrixVectorMul.segred_small_18970      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->matrixVectorMulzisegred_small_18970_runs,
                    (long) ctx->matrixVectorMulzisegred_small_18970_total_runtime /
                    (ctx->matrixVectorMulzisegred_small_18970_runs !=
                     0 ? ctx->matrixVectorMulzisegred_small_18970_runs : 1),
                    (long) ctx->matrixVectorMulzisegred_small_18970_total_runtime);
        ctx->total_runtime +=
            ctx->matrixVectorMulzisegred_small_18970_total_runtime;
        ctx->total_runs += ctx->matrixVectorMulzisegred_small_18970_runs;
        str_builder(&builder,
                    "normalizeV.segmap_19661                 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->normalizzeVzisegmap_19661_runs,
                    (long) ctx->normalizzeVzisegmap_19661_total_runtime /
                    (ctx->normalizzeVzisegmap_19661_runs !=
                     0 ? ctx->normalizzeVzisegmap_19661_runs : 1),
                    (long) ctx->normalizzeVzisegmap_19661_total_runtime);
        ctx->total_runtime += ctx->normalizzeVzisegmap_19661_total_runtime;
        ctx->total_runs += ctx->normalizzeVzisegmap_19661_runs;
        str_builder(&builder,
                    "normalizeV.segred_nonseg_19659          ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->normalizzeVzisegred_nonseg_19659_runs,
                    (long) ctx->normalizzeVzisegred_nonseg_19659_total_runtime /
                    (ctx->normalizzeVzisegred_nonseg_19659_runs !=
                     0 ? ctx->normalizzeVzisegred_nonseg_19659_runs : 1),
                    (long) ctx->normalizzeVzisegred_nonseg_19659_total_runtime);
        ctx->total_runtime +=
            ctx->normalizzeVzisegred_nonseg_19659_total_runtime;
        ctx->total_runs += ctx->normalizzeVzisegred_nonseg_19659_runs;
        str_builder(&builder,
                    "scaleM.segmap_18756                     ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->scaleMzisegmap_18756_runs,
                    (long) ctx->scaleMzisegmap_18756_total_runtime /
                    (ctx->scaleMzisegmap_18756_runs !=
                     0 ? ctx->scaleMzisegmap_18756_runs : 1),
                    (long) ctx->scaleMzisegmap_18756_total_runtime);
        ctx->total_runtime += ctx->scaleMzisegmap_18756_total_runtime;
        ctx->total_runs += ctx->scaleMzisegmap_18756_runs;
        str_builder(&builder,
                    "scaleV.segmap_18920                     ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->scaleVzisegmap_18920_runs,
                    (long) ctx->scaleVzisegmap_18920_total_runtime /
                    (ctx->scaleVzisegmap_18920_runs !=
                     0 ? ctx->scaleVzisegmap_18920_runs : 1),
                    (long) ctx->scaleVzisegmap_18920_total_runtime);
        ctx->total_runtime += ctx->scaleVzisegmap_18920_total_runtime;
        ctx->total_runs += ctx->scaleVzisegmap_18920_runs;
        str_builder(&builder,
                    "vectorAbs.segmap_18613                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorAbszisegmap_18613_runs,
                    (long) ctx->vectorAbszisegmap_18613_total_runtime /
                    (ctx->vectorAbszisegmap_18613_runs !=
                     0 ? ctx->vectorAbszisegmap_18613_runs : 1),
                    (long) ctx->vectorAbszisegmap_18613_total_runtime);
        ctx->total_runtime += ctx->vectorAbszisegmap_18613_total_runtime;
        ctx->total_runs += ctx->vectorAbszisegmap_18613_runs;
        str_builder(&builder,
                    "vectorAdd.segmap_18641                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorAddzisegmap_18641_runs,
                    (long) ctx->vectorAddzisegmap_18641_total_runtime /
                    (ctx->vectorAddzisegmap_18641_runs !=
                     0 ? ctx->vectorAddzisegmap_18641_runs : 1),
                    (long) ctx->vectorAddzisegmap_18641_total_runtime);
        ctx->total_runtime += ctx->vectorAddzisegmap_18641_total_runtime;
        ctx->total_runs += ctx->vectorAddzisegmap_18641_runs;
        str_builder(&builder,
                    "vectorMatrixMul.segmap_intragroup_19807 ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorMatrixMulzisegmap_intragroup_19807_runs,
                    (long) ctx->vectorMatrixMulzisegmap_intragroup_19807_total_runtime /
                    (ctx->vectorMatrixMulzisegmap_intragroup_19807_runs !=
                     0 ? ctx->vectorMatrixMulzisegmap_intragroup_19807_runs : 1),
                    (long) ctx->vectorMatrixMulzisegmap_intragroup_19807_total_runtime);
        ctx->total_runtime +=
            ctx->vectorMatrixMulzisegmap_intragroup_19807_total_runtime;
        ctx->total_runs += ctx->vectorMatrixMulzisegmap_intragroup_19807_runs;
        str_builder(&builder,
                    "vectorMatrixMul.segred_large_19029      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorMatrixMulzisegred_large_19029_runs,
                    (long) ctx->vectorMatrixMulzisegred_large_19029_total_runtime /
                    (ctx->vectorMatrixMulzisegred_large_19029_runs !=
                     0 ? ctx->vectorMatrixMulzisegred_large_19029_runs : 1),
                    (long) ctx->vectorMatrixMulzisegred_large_19029_total_runtime);
        ctx->total_runtime +=
            ctx->vectorMatrixMulzisegred_large_19029_total_runtime;
        ctx->total_runs += ctx->vectorMatrixMulzisegred_large_19029_runs;
        str_builder(&builder,
                    "vectorMatrixMul.segred_small_19029      ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorMatrixMulzisegred_small_19029_runs,
                    (long) ctx->vectorMatrixMulzisegred_small_19029_total_runtime /
                    (ctx->vectorMatrixMulzisegred_small_19029_runs !=
                     0 ? ctx->vectorMatrixMulzisegred_small_19029_runs : 1),
                    (long) ctx->vectorMatrixMulzisegred_small_19029_total_runtime);
        ctx->total_runtime +=
            ctx->vectorMatrixMulzisegred_small_19029_total_runtime;
        ctx->total_runs += ctx->vectorMatrixMulzisegred_small_19029_runs;
        str_builder(&builder,
                    "vectorMul.segmap_18904                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorMulzisegmap_18904_runs,
                    (long) ctx->vectorMulzisegmap_18904_total_runtime /
                    (ctx->vectorMulzisegmap_18904_runs !=
                     0 ? ctx->vectorMulzisegmap_18904_runs : 1),
                    (long) ctx->vectorMulzisegmap_18904_total_runtime);
        ctx->total_runtime += ctx->vectorMulzisegmap_18904_total_runtime;
        ctx->total_runs += ctx->vectorMulzisegmap_18904_runs;
        str_builder(&builder,
                    "vectorNorm.segred_nonseg_19649          ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorNormzisegred_nonseg_19649_runs,
                    (long) ctx->vectorNormzisegred_nonseg_19649_total_runtime /
                    (ctx->vectorNormzisegred_nonseg_19649_runs !=
                     0 ? ctx->vectorNormzisegred_nonseg_19649_runs : 1),
                    (long) ctx->vectorNormzisegred_nonseg_19649_total_runtime);
        ctx->total_runtime +=
            ctx->vectorNormzisegred_nonseg_19649_total_runtime;
        ctx->total_runs += ctx->vectorNormzisegred_nonseg_19649_runs;
        str_builder(&builder,
                    "vectorSgn.segmap_18627                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorSgnzisegmap_18627_runs,
                    (long) ctx->vectorSgnzisegmap_18627_total_runtime /
                    (ctx->vectorSgnzisegmap_18627_runs !=
                     0 ? ctx->vectorSgnzisegmap_18627_runs : 1),
                    (long) ctx->vectorSgnzisegmap_18627_total_runtime);
        ctx->total_runtime += ctx->vectorSgnzisegmap_18627_total_runtime;
        ctx->total_runs += ctx->vectorSgnzisegmap_18627_runs;
        str_builder(&builder,
                    "vectorSub.segmap_18657                  ran %5d times; avg: %8ldus; total: %8ldus\n",
                    ctx->vectorSubzisegmap_18657_runs,
                    (long) ctx->vectorSubzisegmap_18657_total_runtime /
                    (ctx->vectorSubzisegmap_18657_runs !=
                     0 ? ctx->vectorSubzisegmap_18657_runs : 1),
                    (long) ctx->vectorSubzisegmap_18657_total_runtime);
        ctx->total_runtime += ctx->vectorSubzisegmap_18657_total_runtime;
        ctx->total_runs += ctx->vectorSubzisegmap_18657_runs;
        str_builder(&builder, "%d operations with cumulative runtime: %6ldus\n",
                    ctx->total_runs, ctx->total_runtime);
    }
    return builder.str;
}
char *futhark_context_get_error(struct futhark_context *ctx)
{
    char *error = ctx->error;
    
    ctx->error = NULL;
    return error;
}
void futhark_context_set_logging_file(struct futhark_context *ctx, FILE *f)
{
    ctx->log = f;
}
void futhark_context_pause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 1;
}
void futhark_context_unpause_profiling(struct futhark_context *ctx)
{
    ctx->profiling_paused = 0;
}
int futhark_context_clear_caches(struct futhark_context *ctx)
{
    lock_lock(&ctx->lock);
    ctx->peak_mem_usage_device = 0;
    ctx->peak_mem_usage_default = 0;
    if (ctx->error == NULL)
        ctx->error = OPENCL_SUCCEED_NONFATAL(opencl_free_all(&ctx->opencl));
    lock_unlock(&ctx->lock);
    return ctx->error != NULL;
}

static int futrts_builtinzhgpu_map_transpose_f32(struct futhark_context *ctx,
                                                 struct memblock_device destmem_0,
                                                 int32_t destoffset_1,
                                                 struct memblock_device srcmem_2,
                                                 int32_t srcoffset_3,
                                                 int32_t num_arrays_4,
                                                 int32_t x_elems_5,
                                                 int32_t y_elems_6);
static int futrts_builtinzhreplicate_f64(struct futhark_context *ctx,
                                         struct memblock_device mem_20595,
                                         int32_t num_elems_20596,
                                         double val_20597);
static int futrts_entry_dot(struct futhark_context *ctx,
                            float *out_prim_out_20781,
                            struct memblock_device a_mem_20275,
                            struct memblock_device b_mem_20276,
                            int64_t i_18461);
static int futrts_entry_main(struct futhark_context *ctx,
                             struct memblock_device *mem_out_p_20789,
                             int64_t lenX_18471);
static int futrts_entry_matrixAbs(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20825,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2080U_18346, int64_t nz2082U_18347);
static int futrts_entry_matrixAdd(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20831,
                                  struct memblock_device A_mem_20275,
                                  struct memblock_device B_mem_20276,
                                  int64_t i_18371, int64_t j_18372);
static int futrts_entry_matrixMatrixMul(struct futhark_context *ctx,
                                        struct memblock_device *mem_out_p_20837,
                                        struct memblock_device A_mem_20275,
                                        struct memblock_device B_mem_20276,
                                        int64_t i_18444, int64_t j_18445,
                                        int64_t k_18446);
static int futrts_entry_matrixMul(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20859,
                                  struct memblock_device A_mem_20275,
                                  struct memblock_device B_mem_20276,
                                  int64_t i_18393, int64_t j_18394);
static int futrts_entry_matrixSgn(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20865,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2080U_18354, int64_t nz2082U_18355);
static int futrts_entry_matrixSub(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20871,
                                  struct memblock_device A_mem_20275,
                                  struct memblock_device B_mem_20276,
                                  int64_t i_18382, int64_t j_18383);
static int futrts_entry_matrixVectorMul(struct futhark_context *ctx,
                                        struct memblock_device *mem_out_p_20877,
                                        struct memblock_device M_mem_20275,
                                        struct memblock_device v_mem_20276,
                                        int64_t i_18417, int64_t j_18418);
static int futrts_entry_normalizzeV(struct futhark_context *ctx,
                                    struct memblock_device *mem_out_p_20894,
                                    struct memblock_device v_mem_20275,
                                    int64_t iz2083U_18599);
static int futrts_entry_scaleM(struct futhark_context *ctx,
                               struct memblock_device *mem_out_p_20907,
                               struct memblock_device as_mem_20275,
                               int64_t nz2081U_18362, int64_t nz2083U_18363,
                               float f_18364);
static int futrts_entry_scaleV(struct futhark_context *ctx,
                               struct memblock_device *mem_out_p_20913,
                               struct memblock_device as_mem_20275,
                               int64_t nz2082U_18411, float f_18412);
static int futrts_entry_vectorAbs(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20919,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2081U_18322);
static int futrts_entry_vectorAdd(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20925,
                                  struct memblock_device a_mem_20275,
                                  struct memblock_device b_mem_20276,
                                  int64_t i_18332);
static int futrts_entry_vectorMatrixMul(struct futhark_context *ctx,
                                        struct memblock_device *mem_out_p_20931,
                                        struct memblock_device v_mem_20275,
                                        struct memblock_device M_mem_20276,
                                        int64_t i_18430, int64_t j_18431);
static int futrts_entry_vectorMul(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20948,
                                  struct memblock_device a_mem_20275,
                                  struct memblock_device b_mem_20276,
                                  int64_t i_18404);
static int futrts_entry_vectorNorm(struct futhark_context *ctx,
                                   float *out_prim_out_20954,
                                   struct memblock_device v_mem_20275,
                                   int64_t iz2083U_18590);
static int futrts_entry_vectorSgn(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20962,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2081U_18327);
static int futrts_entry_vectorSub(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20968,
                                  struct memblock_device a_mem_20275,
                                  struct memblock_device b_mem_20276,
                                  int64_t i_18339);

static int init_constants(struct futhark_context *ctx)
{
    (void) ctx;
    
    int err = 0;
    
    
  cleanup:
    return err;
}
static int free_constants(struct futhark_context *ctx)
{
    (void) ctx;
    return 0;
}
struct futhark_u8_3d {
    struct memblock_device mem;
    int64_t shape[3];
};
struct futhark_u8_3d *futhark_new_u8_3d(struct futhark_context *ctx, const
                                        uint8_t *data, int64_t dim0,
                                        int64_t dim1, int64_t dim2)
{
    struct futhark_u8_3d *bad = NULL;
    struct futhark_u8_3d *arr =
                         (struct futhark_u8_3d *) malloc(sizeof(struct futhark_u8_3d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * dim1 * dim2 * 1,
                              "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    arr->shape[2] = dim2;
    if ((size_t) (dim0 * dim1 * dim2) * 1 > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      arr->mem.mem, CL_TRUE,
                                                      (size_t) 0,
                                                      (size_t) ((size_t) (dim0 *
                                                                          dim1 *
                                                                          dim2) *
                                                                1), data + 0, 0,
                                                      NULL,
                                                      ctx->profiling_paused ||
                                                      !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                &ctx->copy_dev_to_host_runs,
                                                                                                &ctx->copy_dev_to_host_total_runtime)));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_u8_3d *futhark_new_raw_u8_3d(struct futhark_context *ctx, const
                                            cl_mem data, int64_t offset,
                                            int64_t dim0, int64_t dim1,
                                            int64_t dim2)
{
    struct futhark_u8_3d *bad = NULL;
    struct futhark_u8_3d *arr =
                         (struct futhark_u8_3d *) malloc(sizeof(struct futhark_u8_3d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * dim1 * dim2 * 1,
                              "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    arr->shape[2] = dim2;
    if ((size_t) (dim0 * dim1 * dim2) * 1 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue, data,
                                                     arr->mem.mem,
                                                     (size_t) offset,
                                                     (size_t) 0,
                                                     (size_t) ((size_t) (dim0 *
                                                                         dim1 *
                                                                         dim2) *
                                                               1), 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_u8_3d(struct futhark_context *ctx, struct futhark_u8_3d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_u8_3d(struct futhark_context *ctx, struct futhark_u8_3d *arr,
                         uint8_t *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) (arr->shape[0] * arr->shape[1] * arr->shape[2]) * 1 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     arr->mem.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     (size_t) 0,
                                                     (size_t) ((size_t) (arr->shape[0] *
                                                                         arr->shape[1] *
                                                                         arr->shape[2]) *
                                                               1), data + 0, 0,
                                                     NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_host_to_dev_runs,
                                                                                               &ctx->copy_host_to_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_u8_3d(struct futhark_context *ctx,
                                struct futhark_u8_3d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_u8_3d(struct futhark_context *ctx,
                                   struct futhark_u8_3d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_f32_1d {
    struct memblock_device mem;
    int64_t shape[1];
};
struct futhark_f32_1d *futhark_new_f32_1d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      arr->mem.mem, CL_TRUE,
                                                      (size_t) 0,
                                                      (size_t) ((size_t) dim0 *
                                                                4), data + 0, 0,
                                                      NULL,
                                                      ctx->profiling_paused ||
                                                      !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                &ctx->copy_dev_to_host_runs,
                                                                                                &ctx->copy_dev_to_host_total_runtime)));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_f32_1d *futhark_new_raw_f32_1d(struct futhark_context *ctx, const
                                              cl_mem data, int64_t offset,
                                              int64_t dim0)
{
    struct futhark_f32_1d *bad = NULL;
    struct futhark_f32_1d *arr =
                          (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    if ((size_t) dim0 * 4 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue, data,
                                                     arr->mem.mem,
                                                     (size_t) offset,
                                                     (size_t) 0,
                                                     (size_t) ((size_t) dim0 *
                                                               4), 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f32_1d(struct futhark_context *ctx, struct futhark_f32_1d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f32_1d(struct futhark_context *ctx,
                          struct futhark_f32_1d *arr, float *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) arr->shape[0] * 4 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     arr->mem.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     (size_t) 0,
                                                     (size_t) ((size_t) arr->shape[0] *
                                                               4), data + 0, 0,
                                                     NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_host_to_dev_runs,
                                                                                               &ctx->copy_host_to_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_f32_1d(struct futhark_context *ctx,
                                 struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f32_1d(struct futhark_context *ctx,
                                    struct futhark_f32_1d *arr)
{
    (void) ctx;
    return arr->shape;
}
struct futhark_f32_2d {
    struct memblock_device mem;
    int64_t shape[2];
};
struct futhark_f32_2d *futhark_new_f32_2d(struct futhark_context *ctx, const
                                          float *data, int64_t dim0,
                                          int64_t dim1)
{
    struct futhark_f32_2d *bad = NULL;
    struct futhark_f32_2d *arr =
                          (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * dim1 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 4 > 0)
        OPENCL_SUCCEED_OR_RETURN(clEnqueueWriteBuffer(ctx->opencl.queue,
                                                      arr->mem.mem, CL_TRUE,
                                                      (size_t) 0,
                                                      (size_t) ((size_t) (dim0 *
                                                                          dim1) *
                                                                4), data + 0, 0,
                                                      NULL,
                                                      ctx->profiling_paused ||
                                                      !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                &ctx->copy_dev_to_host_runs,
                                                                                                &ctx->copy_dev_to_host_total_runtime)));
    lock_unlock(&ctx->lock);
    return arr;
}
struct futhark_f32_2d *futhark_new_raw_f32_2d(struct futhark_context *ctx, const
                                              cl_mem data, int64_t offset,
                                              int64_t dim0, int64_t dim1)
{
    struct futhark_f32_2d *bad = NULL;
    struct futhark_f32_2d *arr =
                          (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d));
    
    if (arr == NULL)
        return bad;
    lock_lock(&ctx->lock);
    arr->mem.references = NULL;
    if (memblock_alloc_device(ctx, &arr->mem, dim0 * dim1 * 4, "arr->mem"))
        return NULL;
    arr->shape[0] = dim0;
    arr->shape[1] = dim1;
    if ((size_t) (dim0 * dim1) * 4 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue, data,
                                                     arr->mem.mem,
                                                     (size_t) offset,
                                                     (size_t) 0,
                                                     (size_t) ((size_t) (dim0 *
                                                                         dim1) *
                                                               4), 0, NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_dev_to_dev_runs,
                                                                                               &ctx->copy_dev_to_dev_total_runtime)));
        if (ctx->debugging)
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
    }
    lock_unlock(&ctx->lock);
    return arr;
}
int futhark_free_f32_2d(struct futhark_context *ctx, struct futhark_f32_2d *arr)
{
    lock_lock(&ctx->lock);
    if (memblock_unref_device(ctx, &arr->mem, "arr->mem") != 0)
        return 1;
    lock_unlock(&ctx->lock);
    free(arr);
    return 0;
}
int futhark_values_f32_2d(struct futhark_context *ctx,
                          struct futhark_f32_2d *arr, float *data)
{
    lock_lock(&ctx->lock);
    if ((size_t) (arr->shape[0] * arr->shape[1]) * 4 > 0) {
        OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                     arr->mem.mem,
                                                     ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                     (size_t) 0,
                                                     (size_t) ((size_t) (arr->shape[0] *
                                                                         arr->shape[1]) *
                                                               4), data + 0, 0,
                                                     NULL,
                                                     ctx->profiling_paused ||
                                                     !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                               &ctx->copy_host_to_dev_runs,
                                                                                               &ctx->copy_host_to_dev_total_runtime)));
        if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
            return 1;
    }
    lock_unlock(&ctx->lock);
    return 0;
}
cl_mem futhark_values_raw_f32_2d(struct futhark_context *ctx,
                                 struct futhark_f32_2d *arr)
{
    (void) ctx;
    return arr->mem.mem;
}
const int64_t *futhark_shape_f32_2d(struct futhark_context *ctx,
                                    struct futhark_f32_2d *arr)
{
    (void) ctx;
    return arr->shape;
}

static int futrts_builtinzhgpu_map_transpose_f32(struct futhark_context *ctx,
                                                 struct memblock_device destmem_0,
                                                 int32_t destoffset_1,
                                                 struct memblock_device srcmem_2,
                                                 int32_t srcoffset_3,
                                                 int32_t num_arrays_4,
                                                 int32_t x_elems_5,
                                                 int32_t y_elems_6)
{
    (void) ctx;
    
    int err = 0;
    
    if (!(num_arrays_4 == 0 || (x_elems_5 == 0 || y_elems_6 == 0))) {
        int32_t muly_8 = squot32(16, x_elems_5);
        int32_t mulx_7 = squot32(16, y_elems_6);
        
        if (num_arrays_4 == 1 && (x_elems_5 == 1 || y_elems_6 == 1)) {
            if (sext_i32_i64(x_elems_5 * y_elems_6 * 4) > 0) {
                OPENCL_SUCCEED_OR_RETURN(clEnqueueCopyBuffer(ctx->opencl.queue,
                                                             srcmem_2.mem,
                                                             destmem_0.mem,
                                                             (size_t) sext_i32_i64(srcoffset_3),
                                                             (size_t) sext_i32_i64(destoffset_1),
                                                             (size_t) sext_i32_i64(x_elems_5 *
                                                             y_elems_6 * 4), 0,
                                                             NULL,
                                                             ctx->profiling_paused ||
                                                             !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                       &ctx->copy_dev_to_dev_runs,
                                                                                                       &ctx->copy_dev_to_dev_total_runtime)));
                if (ctx->debugging)
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            }
        } else {
            if (sle32(x_elems_5, 8) && slt32(16, y_elems_6)) {
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        0,
                                                        (size_t) (int64_t) 1088,
                                                        NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        1, sizeof(destoffset_1),
                                                        &destoffset_1));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        2, sizeof(srcoffset_3),
                                                        &srcoffset_3));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        3, sizeof(num_arrays_4),
                                                        &num_arrays_4));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        4, sizeof(x_elems_5),
                                                        &x_elems_5));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        5, sizeof(y_elems_6),
                                                        &y_elems_6));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        6, sizeof(mulx_7),
                                                        &mulx_7));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        7, sizeof(muly_8),
                                                        &muly_8));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        8,
                                                        sizeof(destmem_0.mem),
                                                        &destmem_0.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_width,
                                                        9, sizeof(srcmem_2.mem),
                                                        &srcmem_2.mem));
                if (1 * ((size_t) sdiv_up32(x_elems_5, 16) * (size_t) 16) *
                    ((size_t) sdiv_up32(sdiv_up32(y_elems_6, muly_8), 16) *
                     (size_t) 16) * ((size_t) num_arrays_4 * (size_t) 1) != 0) {
                    const size_t global_work_sizze_20756[3] =
                                 {(size_t) sdiv_up32(x_elems_5, 16) *
                                  (size_t) 16,
                                  (size_t) sdiv_up32(sdiv_up32(y_elems_6,
                                                               muly_8), 16) *
                                  (size_t) 16, (size_t) num_arrays_4 *
                                  (size_t) 1};
                    const size_t local_work_sizze_20760[3] = {(size_t) 16,
                                                              (size_t) 16,
                                                              (size_t) 1};
                    int64_t time_start_20757 = 0, time_end_20758 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(ctx->log,
                                "Launching %s with global work size [%zu, %zu, %zu] and local work size [%zu, %zu, %zu]; local memory: %d bytes.\n",
                                "gpu_map_transpose_f32_low_width",
                                global_work_sizze_20756[0],
                                global_work_sizze_20756[1],
                                global_work_sizze_20756[2],
                                local_work_sizze_20760[0],
                                local_work_sizze_20760[1],
                                local_work_sizze_20760[2], (int) (0 +
                                                                  (int64_t) 1088));
                        time_start_20757 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->gpu_map_transpose_f32_low_width,
                                                                    3, NULL,
                                                                    global_work_sizze_20756,
                                                                    local_work_sizze_20760,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->gpu_map_transpose_f32_low_width_runs,
                                                                                                              &ctx->gpu_map_transpose_f32_low_width_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_20758 = get_wall_time();
                        
                        long time_diff_20759 = time_end_20758 -
                             time_start_20757;
                        
                        fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                                "gpu_map_transpose_f32_low_width",
                                time_diff_20759);
                    }
                }
            } else {
                if (sle32(y_elems_6, 8) && slt32(16, x_elems_5)) {
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            0,
                                                            (size_t) (int64_t) 1088,
                                                            NULL));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            1,
                                                            sizeof(destoffset_1),
                                                            &destoffset_1));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            2,
                                                            sizeof(srcoffset_3),
                                                            &srcoffset_3));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            3,
                                                            sizeof(num_arrays_4),
                                                            &num_arrays_4));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            4,
                                                            sizeof(x_elems_5),
                                                            &x_elems_5));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            5,
                                                            sizeof(y_elems_6),
                                                            &y_elems_6));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            6, sizeof(mulx_7),
                                                            &mulx_7));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            7, sizeof(muly_8),
                                                            &muly_8));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            8,
                                                            sizeof(destmem_0.mem),
                                                            &destmem_0.mem));
                    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_low_height,
                                                            9,
                                                            sizeof(srcmem_2.mem),
                                                            &srcmem_2.mem));
                    if (1 * ((size_t) sdiv_up32(sdiv_up32(x_elems_5, mulx_7),
                                                16) * (size_t) 16) *
                        ((size_t) sdiv_up32(y_elems_6, 16) * (size_t) 16) *
                        ((size_t) num_arrays_4 * (size_t) 1) != 0) {
                        const size_t global_work_sizze_20761[3] =
                                     {(size_t) sdiv_up32(sdiv_up32(x_elems_5,
                                                                   mulx_7),
                                                         16) * (size_t) 16,
                                      (size_t) sdiv_up32(y_elems_6, 16) *
                                      (size_t) 16, (size_t) num_arrays_4 *
                                      (size_t) 1};
                        const size_t local_work_sizze_20765[3] = {(size_t) 16,
                                                                  (size_t) 16,
                                                                  (size_t) 1};
                        int64_t time_start_20762 = 0, time_end_20763 = 0;
                        
                        if (ctx->debugging) {
                            fprintf(ctx->log,
                                    "Launching %s with global work size [%zu, %zu, %zu] and local work size [%zu, %zu, %zu]; local memory: %d bytes.\n",
                                    "gpu_map_transpose_f32_low_height",
                                    global_work_sizze_20761[0],
                                    global_work_sizze_20761[1],
                                    global_work_sizze_20761[2],
                                    local_work_sizze_20765[0],
                                    local_work_sizze_20765[1],
                                    local_work_sizze_20765[2], (int) (0 +
                                                                      (int64_t) 1088));
                            time_start_20762 = get_wall_time();
                        }
                        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                        ctx->gpu_map_transpose_f32_low_height,
                                                                        3, NULL,
                                                                        global_work_sizze_20761,
                                                                        local_work_sizze_20765,
                                                                        0, NULL,
                                                                        ctx->profiling_paused ||
                                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                  &ctx->gpu_map_transpose_f32_low_height_runs,
                                                                                                                  &ctx->gpu_map_transpose_f32_low_height_total_runtime)));
                        if (ctx->debugging) {
                            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                            time_end_20763 = get_wall_time();
                            
                            long time_diff_20764 = time_end_20763 -
                                 time_start_20762;
                            
                            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                                    "gpu_map_transpose_f32_low_height",
                                    time_diff_20764);
                        }
                    }
                } else {
                    if (sle32(x_elems_5, 8) && sle32(y_elems_6, 8)) {
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                0,
                                                                (size_t) (int64_t) 1,
                                                                NULL));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                1,
                                                                sizeof(destoffset_1),
                                                                &destoffset_1));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                2,
                                                                sizeof(srcoffset_3),
                                                                &srcoffset_3));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                3,
                                                                sizeof(num_arrays_4),
                                                                &num_arrays_4));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                4,
                                                                sizeof(x_elems_5),
                                                                &x_elems_5));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                5,
                                                                sizeof(y_elems_6),
                                                                &y_elems_6));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                6,
                                                                sizeof(mulx_7),
                                                                &mulx_7));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                7,
                                                                sizeof(muly_8),
                                                                &muly_8));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                8,
                                                                sizeof(destmem_0.mem),
                                                                &destmem_0.mem));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32_small,
                                                                9,
                                                                sizeof(srcmem_2.mem),
                                                                &srcmem_2.mem));
                        if (1 * ((size_t) sdiv_up32(num_arrays_4 * x_elems_5 *
                                                    y_elems_6, 256) *
                                 (size_t) 256) != 0) {
                            const size_t global_work_sizze_20766[1] =
                                         {(size_t) sdiv_up32(num_arrays_4 *
                                                             x_elems_5 *
                                                             y_elems_6, 256) *
                                         (size_t) 256};
                            const size_t local_work_sizze_20770[1] =
                                         {(size_t) 256};
                            int64_t time_start_20767 = 0, time_end_20768 = 0;
                            
                            if (ctx->debugging) {
                                fprintf(ctx->log,
                                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                                        "gpu_map_transpose_f32_small",
                                        global_work_sizze_20766[0],
                                        local_work_sizze_20770[0], (int) (0 +
                                                                          (int64_t) 1));
                                time_start_20767 = get_wall_time();
                            }
                            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                            ctx->gpu_map_transpose_f32_small,
                                                                            1,
                                                                            NULL,
                                                                            global_work_sizze_20766,
                                                                            local_work_sizze_20770,
                                                                            0,
                                                                            NULL,
                                                                            ctx->profiling_paused ||
                                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                      &ctx->gpu_map_transpose_f32_small_runs,
                                                                                                                      &ctx->gpu_map_transpose_f32_small_total_runtime)));
                            if (ctx->debugging) {
                                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                                time_end_20768 = get_wall_time();
                                
                                long time_diff_20769 = time_end_20768 -
                                     time_start_20767;
                                
                                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                                        "gpu_map_transpose_f32_small",
                                        time_diff_20769);
                            }
                        }
                    } else {
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                0,
                                                                (size_t) (int64_t) 4224,
                                                                NULL));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                1,
                                                                sizeof(destoffset_1),
                                                                &destoffset_1));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                2,
                                                                sizeof(srcoffset_3),
                                                                &srcoffset_3));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                3,
                                                                sizeof(num_arrays_4),
                                                                &num_arrays_4));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                4,
                                                                sizeof(x_elems_5),
                                                                &x_elems_5));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                5,
                                                                sizeof(y_elems_6),
                                                                &y_elems_6));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                6,
                                                                sizeof(mulx_7),
                                                                &mulx_7));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                7,
                                                                sizeof(muly_8),
                                                                &muly_8));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                8,
                                                                sizeof(destmem_0.mem),
                                                                &destmem_0.mem));
                        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->gpu_map_transpose_f32,
                                                                9,
                                                                sizeof(srcmem_2.mem),
                                                                &srcmem_2.mem));
                        if (1 * ((size_t) sdiv_up32(x_elems_5, 32) *
                                 (size_t) 32) * ((size_t) sdiv_up32(y_elems_6,
                                                                    32) *
                                                 (size_t) 8) *
                            ((size_t) num_arrays_4 * (size_t) 1) != 0) {
                            const size_t global_work_sizze_20771[3] =
                                         {(size_t) sdiv_up32(x_elems_5, 32) *
                                          (size_t) 32,
                                          (size_t) sdiv_up32(y_elems_6, 32) *
                                          (size_t) 8, (size_t) num_arrays_4 *
                                          (size_t) 1};
                            const size_t local_work_sizze_20775[3] =
                                         {(size_t) 32, (size_t) 8, (size_t) 1};
                            int64_t time_start_20772 = 0, time_end_20773 = 0;
                            
                            if (ctx->debugging) {
                                fprintf(ctx->log,
                                        "Launching %s with global work size [%zu, %zu, %zu] and local work size [%zu, %zu, %zu]; local memory: %d bytes.\n",
                                        "gpu_map_transpose_f32",
                                        global_work_sizze_20771[0],
                                        global_work_sizze_20771[1],
                                        global_work_sizze_20771[2],
                                        local_work_sizze_20775[0],
                                        local_work_sizze_20775[1],
                                        local_work_sizze_20775[2], (int) (0 +
                                                                          (int64_t) 4224));
                                time_start_20772 = get_wall_time();
                            }
                            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                            ctx->gpu_map_transpose_f32,
                                                                            3,
                                                                            NULL,
                                                                            global_work_sizze_20771,
                                                                            local_work_sizze_20775,
                                                                            0,
                                                                            NULL,
                                                                            ctx->profiling_paused ||
                                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                                      &ctx->gpu_map_transpose_f32_runs,
                                                                                                                      &ctx->gpu_map_transpose_f32_total_runtime)));
                            if (ctx->debugging) {
                                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                                time_end_20773 = get_wall_time();
                                
                                long time_diff_20774 = time_end_20773 -
                                     time_start_20772;
                                
                                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                                        "gpu_map_transpose_f32",
                                        time_diff_20774);
                            }
                        }
                    }
                }
            }
        }
    }
    
  cleanup:
    { }
    return err;
}
static int futrts_builtinzhreplicate_f64(struct futhark_context *ctx,
                                         struct memblock_device mem_20595,
                                         int32_t num_elems_20596,
                                         double val_20597)
{
    (void) ctx;
    
    int err = 0;
    int64_t group_sizze_20602;
    
    group_sizze_20602 =
        *ctx->tuning_params.builtinzhreplicate_f64zigroup_sizze_20602;
    
    int64_t num_groups_20603 = sdiv_up64(num_elems_20596, group_sizze_20602);
    
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->builtinzhreplicate_f64zireplicate_20599,
                                            0, sizeof(num_elems_20596),
                                            &num_elems_20596));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->builtinzhreplicate_f64zireplicate_20599,
                                            1, sizeof(val_20597), &val_20597));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->builtinzhreplicate_f64zireplicate_20599,
                                            2, sizeof(mem_20595.mem),
                                            &mem_20595.mem));
    if (1 * ((size_t) num_groups_20603 * (size_t) group_sizze_20602) != 0) {
        const size_t global_work_sizze_20776[1] = {(size_t) num_groups_20603 *
                     (size_t) group_sizze_20602};
        const size_t local_work_sizze_20780[1] = {(size_t) group_sizze_20602};
        int64_t time_start_20777 = 0, time_end_20778 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "builtin#replicate_f64.replicate_20599",
                    global_work_sizze_20776[0], local_work_sizze_20780[0],
                    (int) 0);
            time_start_20777 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->builtinzhreplicate_f64zireplicate_20599,
                                                        1, NULL,
                                                        global_work_sizze_20776,
                                                        local_work_sizze_20780,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->builtinzhreplicate_f64zireplicate_20599_runs,
                                                                                                  &ctx->builtinzhreplicate_f64zireplicate_20599_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20778 = get_wall_time();
            
            long time_diff_20779 = time_end_20778 - time_start_20777;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "builtin#replicate_f64.replicate_20599", time_diff_20779);
        }
    }
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_dot(struct futhark_context *ctx,
                            float *out_prim_out_20781,
                            struct memblock_device a_mem_20275,
                            struct memblock_device b_mem_20276, int64_t i_18461)
{
    (void) ctx;
    
    int err = 0;
    float prim_out_20594;
    int64_t segred_group_sizze_19180;
    
    segred_group_sizze_19180 =
        *ctx->tuning_params.dotzisegred_group_sizze_19179;
    
    int64_t num_groups_19182;
    int32_t max_num_groups_20595;
    
    max_num_groups_20595 = *ctx->tuning_params.dotzisegred_num_groups_19181;
    num_groups_19182 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(i_18461,
                                                            segred_group_sizze_19180),
                                                  sext_i32_i64(max_num_groups_20595))));
    
    struct memblock_device mem_20279;
    
    mem_20279.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20279, (int64_t) 4, "mem_20279")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device dotzicounter_mem_20596 = ctx->dotzicounter_mem_20596;
    struct memblock_device segred_tmp_mem_20598;
    
    segred_tmp_mem_20598.references = NULL;
    if (memblock_alloc_device(ctx, &segred_tmp_mem_20598, (int64_t) 4 *
                              num_groups_19182, "segred_tmp_mem_20598")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t num_threads_20600 = num_groups_19182 * segred_group_sizze_19180;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegRed");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 1,
                                            (size_t) ((int64_t) 4 *
                                                      segred_group_sizze_19180),
                                            NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 2,
                                            (size_t) 1, NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 3,
                                            sizeof(i_18461), &i_18461));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 4,
                                            sizeof(num_groups_19182),
                                            &num_groups_19182));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 5,
                                            sizeof(num_threads_20600),
                                            &num_threads_20600));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 6,
                                            sizeof(a_mem_20275.mem),
                                            &a_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 7,
                                            sizeof(b_mem_20276.mem),
                                            &b_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 8,
                                            sizeof(mem_20279.mem),
                                            &mem_20279.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 9,
                                            sizeof(dotzicounter_mem_20596.mem),
                                            &dotzicounter_mem_20596.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->dotzisegred_nonseg_19187, 10,
                                            sizeof(segred_tmp_mem_20598.mem),
                                            &segred_tmp_mem_20598.mem));
    if (1 * ((size_t) num_groups_19182 * (size_t) segred_group_sizze_19180) !=
        0) {
        const size_t global_work_sizze_20783[1] = {(size_t) num_groups_19182 *
                     (size_t) segred_group_sizze_19180};
        const size_t local_work_sizze_20787[1] =
                     {(size_t) segred_group_sizze_19180};
        int64_t time_start_20784 = 0, time_end_20785 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "dot.segred_nonseg_19187", global_work_sizze_20783[0],
                    local_work_sizze_20787[0], (int) (0 + (int64_t) 4 *
                                                      segred_group_sizze_19180 +
                                                      1));
            time_start_20784 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->dotzisegred_nonseg_19187,
                                                        1, NULL,
                                                        global_work_sizze_20783,
                                                        local_work_sizze_20787,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->dotzisegred_nonseg_19187_runs,
                                                                                                  &ctx->dotzisegred_nonseg_19187_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20785 = get_wall_time();
            
            long time_diff_20786 = time_end_20785 - time_start_20784;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "dot.segred_nonseg_19187", time_diff_20786);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
    float read_res_20788;
    
    OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                 mem_20279.mem,
                                                 ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                 (int64_t) 0 * sizeof(float),
                                                 sizeof(float), &read_res_20788,
                                                 0, NULL,
                                                 ctx->profiling_paused ||
                                                 !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                           &ctx->copy_scalar_from_dev_runs,
                                                                                           &ctx->copy_scalar_from_dev_total_runtime)));
    if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
        return 1;
    
    float defunc_0_f_res_18464 = read_res_20788;
    
    if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
        return 1;
    prim_out_20594 = defunc_0_f_res_18464;
    *out_prim_out_20781 = prim_out_20594;
    if (memblock_unref_device(ctx, &segred_tmp_mem_20598,
                              "segred_tmp_mem_20598") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_main(struct futhark_context *ctx,
                             struct memblock_device *mem_out_p_20789,
                             int64_t lenX_18471)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t binop_x_20275 = lenX_18471 * lenX_18471;
    int64_t binop_y_20276 = (int64_t) 8 * binop_x_20275;
    int64_t bytes_20277 = smax64((int64_t) 0, binop_y_20276);
    struct memblock_device mem_20278;
    
    mem_20278.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20278, bytes_20277, "mem_20278")) {
        err = 1;
        goto cleanup;
    }
    if (futrts_builtinzhreplicate_f64(ctx, mem_20278, lenX_18471 * lenX_18471,
                                      0.0) != 0) {
        err = 1;
        goto cleanup;
    }
    
    int64_t segmap_group_sizze_19266;
    
    segmap_group_sizze_19266 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19249;
    
    int64_t segmap_group_sizze_19288;
    
    segmap_group_sizze_19288 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19204;
    
    int64_t segmap_group_sizze_19389;
    
    segmap_group_sizze_19389 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19337;
    
    int64_t segmap_group_sizze_19481;
    
    segmap_group_sizze_19481 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19429;
    
    int64_t segmap_group_sizze_19526;
    
    segmap_group_sizze_19526 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19506;
    
    int64_t segmap_usable_groups_19527 = sdiv_up_safe64(binop_x_20275,
                                                        segmap_group_sizze_19526);
    struct memblock_device ext_mem_20317;
    
    ext_mem_20317.references = NULL;
    
    struct memblock_device mem_param_20286;
    
    mem_param_20286.references = NULL;
    if (memblock_set_device(ctx, &mem_param_20286, &mem_20278, "mem_20278") !=
        0)
        return 1;
    for (int32_t i_19728 = 0; i_19728 < 5; i_19728++) {
        int64_t i_19189 = sext_i32_i64(i_19728);
        int32_t x_18486 = lshr32(i_19728, 16);
        int32_t x_18487 = x_18486 ^ i_19728;
        int32_t x_18488 = mul32(73244475, x_18487);
        int32_t x_18489 = lshr32(x_18488, 16);
        int32_t x_18490 = x_18488 ^ x_18489;
        int32_t x_18491 = mul32(73244475, x_18490);
        int32_t x_18492 = lshr32(x_18491, 16);
        int32_t x_18493 = x_18491 ^ x_18492;
        int32_t unsign_arg_18494 = 960428694 ^ x_18493;
        bool nonnegative_18495 = sle64((int64_t) 0, i_19189);
        bool nonzzero_cert_18496;
        
        if (!nonnegative_18495) {
            ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                   "negative exponent",
                                   "-> #0  noise.fut:36:16-26\n   #1  noise.fut:68:23-53\n   #2  /prelude/functional.fut:9:42-44\n   #3  noise.fut:66:20-68:54\n   #4  noise.fut:92:18-48\n   #5  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t binop_p_18497 = shl64((int64_t) 1, i_19189);
        bool zzero_18498 = binop_p_18497 == (int64_t) 0;
        bool nonzzero_18499 = !zzero_18498;
        bool nonzzero_cert_18500;
        
        if (!nonzzero_18499) {
            ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                   "division by zero",
                                   "-> #0  noise.fut:36:31-40\n   #1  /prelude/functional.fut:9:42-44\n   #2  noise.fut:36:16-40\n   #3  noise.fut:68:23-53\n   #4  /prelude/functional.fut:9:42-44\n   #5  noise.fut:66:20-68:54\n   #6  noise.fut:92:18-48\n   #7  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t defunc_0_f_res_18501 = sdiv64((int64_t) 32, binop_p_18497);
        double i64_res_18502 = sitofp_i64_f64(defunc_0_f_res_18501);
        bool zzero_18503 = defunc_0_f_res_18501 == (int64_t) 0;
        bool nonzzero_18504 = !zzero_18503;
        bool nonzzero_cert_18505;
        
        if (!nonzzero_18504) {
            ctx->error = msgprintf("Error: %s\n\nBacktrace:\n%s",
                                   "division by zero",
                                   "-> #0  noise.fut:38:83-93\n   #1  noise.fut:68:23-53\n   #2  /prelude/functional.fut:9:42-44\n   #3  noise.fut:66:20-68:54\n   #4  noise.fut:92:18-48\n   #5  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t noise_2d_arg_18506 = sdiv64(lenX_18471, defunc_0_f_res_18501);
        double i64_res_18507 = sitofp_i32_f64(i_19728);
        double y_18508 = fpow64(2.0, i64_res_18507);
        double noise_2d_arg_18509 = 1.0 / y_18508;
        int32_t unsign_arg_18510 = mul32(48271, unsign_arg_18494);
        int32_t unsign_arg_18511 = umod32(unsign_arg_18510, 2147483647);
        bool bounds_invalid_upwards_18512 = slt64(noise_2d_arg_18506,
                                                  (int64_t) 0);
        bool valid_18513 = !bounds_invalid_upwards_18512;
        bool range_valid_c_18514;
        
        if (!valid_18513) {
            ctx->error =
                msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                          "Range ", (long long) (int64_t) 0, "..",
                          (long long) (int64_t) 1, "..<",
                          (long long) noise_2d_arg_18506, " is invalid.",
                          "-> #0  /prelude/array.fut:90:3-10\n   #1  /prelude/array.fut:195:11-16\n   #2  ../lib/github.com/diku-dk/cpprandom/random.fut:174:8-56\n   #3  noise.fut:17:14-40\n   #4  noise.fut:38:27-94\n   #5  noise.fut:68:23-53\n   #6  /prelude/functional.fut:9:42-44\n   #7  noise.fut:66:20-68:54\n   #8  noise.fut:92:18-48\n   #9  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t segmap_usable_groups_19267 = sdiv_up64(noise_2d_arg_18506,
                                                       segmap_group_sizze_19266);
        int64_t binop_y_20290 = (int64_t) 4 * noise_2d_arg_18506;
        int64_t bytes_20291 = smax64((int64_t) 0, binop_y_20290);
        struct memblock_device mem_20292;
        
        mem_20292.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20292, bytes_20291, "mem_20292")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19247, 1,
                                                sizeof(noise_2d_arg_18506),
                                                &noise_2d_arg_18506));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19247, 2,
                                                sizeof(unsign_arg_18511),
                                                &unsign_arg_18511));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19247, 3,
                                                sizeof(mem_20292.mem),
                                                &mem_20292.mem));
        if (1 * ((size_t) segmap_usable_groups_19267 *
                 (size_t) segmap_group_sizze_19266) != 0) {
            const size_t global_work_sizze_20790[1] =
                         {(size_t) segmap_usable_groups_19267 *
                         (size_t) segmap_group_sizze_19266};
            const size_t local_work_sizze_20794[1] =
                         {(size_t) segmap_group_sizze_19266};
            int64_t time_start_20791 = 0, time_end_20792 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "main.segmap_19247", global_work_sizze_20790[0],
                        local_work_sizze_20794[0], (int) 0);
                time_start_20791 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_19247,
                                                            1, NULL,
                                                            global_work_sizze_20790,
                                                            local_work_sizze_20794,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_19247_runs,
                                                                                                      &ctx->mainzisegmap_19247_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20792 = get_wall_time();
                
                long time_diff_20793 = time_end_20792 - time_start_20791;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "main.segmap_19247", time_diff_20793);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        
        int64_t nest_sizze_19287 = noise_2d_arg_18506 * noise_2d_arg_18506;
        int64_t segmap_usable_groups_19289 = sdiv_up64(nest_sizze_19287,
                                                       segmap_group_sizze_19288);
        int64_t binop_y_20295 = (int64_t) 8 * nest_sizze_19287;
        int64_t bytes_20296 = smax64((int64_t) 0, binop_y_20295);
        struct memblock_device mem_20297;
        
        mem_20297.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20297, bytes_20296, "mem_20297")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19201, 1,
                                                sizeof(noise_2d_arg_18506),
                                                &noise_2d_arg_18506));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19201, 2,
                                                sizeof(noise_2d_arg_18509),
                                                &noise_2d_arg_18509));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19201, 3,
                                                sizeof(mem_20292.mem),
                                                &mem_20292.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19201, 4,
                                                sizeof(mem_20297.mem),
                                                &mem_20297.mem));
        if (1 * ((size_t) segmap_usable_groups_19289 *
                 (size_t) segmap_group_sizze_19288) != 0) {
            const size_t global_work_sizze_20795[1] =
                         {(size_t) segmap_usable_groups_19289 *
                         (size_t) segmap_group_sizze_19288};
            const size_t local_work_sizze_20799[1] =
                         {(size_t) segmap_group_sizze_19288};
            int64_t time_start_20796 = 0, time_end_20797 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "main.segmap_19201", global_work_sizze_20795[0],
                        local_work_sizze_20799[0], (int) 0);
                time_start_20796 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_19201,
                                                            1, NULL,
                                                            global_work_sizze_20795,
                                                            local_work_sizze_20799,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_19201_runs,
                                                                                                      &ctx->mainzisegmap_19201_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20797 = get_wall_time();
                
                long time_diff_20798 = time_end_20797 - time_start_20796;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "main.segmap_19201", time_diff_20798);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_20292, "mem_20292") != 0)
            return 1;
        
        bool bounds_invalid_upwards_18547 = slt64(defunc_0_f_res_18501,
                                                  (int64_t) 0);
        bool valid_18548 = !bounds_invalid_upwards_18547;
        bool range_valid_c_18549;
        
        if (!valid_18548) {
            ctx->error =
                msgprintf("Error: %s%lld%s%lld%s%lld%s\n\nBacktrace:\n%s",
                          "Range ", (long long) (int64_t) 0, "..",
                          (long long) (int64_t) 1, "..<",
                          (long long) defunc_0_f_res_18501, " is invalid.",
                          "-> #0  /prelude/array.fut:90:3-10\n   #1  noise.fut:44:35-45\n   #2  /prelude/functional.fut:9:42-44\n   #3  noise.fut:42:42-44:47\n   #4  noise.fut:46:14-26\n   #5  noise.fut:68:23-53\n   #6  /prelude/functional.fut:9:42-44\n   #7  noise.fut:66:20-68:54\n   #8  noise.fut:92:18-48\n   #9  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_20297, "mem_20297") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20292, "mem_20292") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t flat_dim_18552 = defunc_0_f_res_18501 * noise_2d_arg_18506;
        bool dim_match_18553 = lenX_18471 == flat_dim_18552;
        bool empty_or_match_cert_18554;
        
        if (!dim_match_18553) {
            ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                   "Value of (core language) shape (",
                                   (long long) flat_dim_18552,
                                   ") cannot match shape of type `[",
                                   (long long) lenX_18471, "]t`.",
                                   "-> #0  /prelude/array.fut:127:3-20\n   #1  /prelude/functional.fut:9:42-44\n   #2  noise.fut:42:42-45:22\n   #3  noise.fut:46:14-26\n   #4  noise.fut:68:23-53\n   #5  /prelude/functional.fut:9:42-44\n   #6  noise.fut:66:20-68:54\n   #7  noise.fut:92:18-48\n   #8  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_20297, "mem_20297") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20292, "mem_20292") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t nest_sizze_19388 = noise_2d_arg_18506 * flat_dim_18552;
        int64_t segmap_usable_groups_19390 = sdiv_up64(nest_sizze_19388,
                                                       segmap_group_sizze_19389);
        int64_t binop_x_20300 = defunc_0_f_res_18501 * nest_sizze_19287;
        int64_t binop_y_20301 = (int64_t) 8 * binop_x_20300;
        int64_t bytes_20302 = smax64((int64_t) 0, binop_y_20301);
        struct memblock_device mem_20303;
        
        mem_20303.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20303, bytes_20302, "mem_20303")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19333, 1,
                                                sizeof(defunc_0_f_res_18501),
                                                &defunc_0_f_res_18501));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19333, 2,
                                                sizeof(i64_res_18502),
                                                &i64_res_18502));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19333, 3,
                                                sizeof(noise_2d_arg_18506),
                                                &noise_2d_arg_18506));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19333, 4,
                                                sizeof(mem_20297.mem),
                                                &mem_20297.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19333, 5,
                                                sizeof(mem_20303.mem),
                                                &mem_20303.mem));
        if (1 * ((size_t) segmap_usable_groups_19390 *
                 (size_t) segmap_group_sizze_19389) != 0) {
            const size_t global_work_sizze_20800[1] =
                         {(size_t) segmap_usable_groups_19390 *
                         (size_t) segmap_group_sizze_19389};
            const size_t local_work_sizze_20804[1] =
                         {(size_t) segmap_group_sizze_19389};
            int64_t time_start_20801 = 0, time_end_20802 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "main.segmap_19333", global_work_sizze_20800[0],
                        local_work_sizze_20804[0], (int) 0);
                time_start_20801 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_19333,
                                                            1, NULL,
                                                            global_work_sizze_20800,
                                                            local_work_sizze_20804,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_19333_runs,
                                                                                                      &ctx->mainzisegmap_19333_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20802 = get_wall_time();
                
                long time_diff_20803 = time_end_20802 - time_start_20801;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "main.segmap_19333", time_diff_20803);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_20297, "mem_20297") != 0)
            return 1;
        
        bool empty_or_match_cert_18569;
        
        if (!dim_match_18553) {
            ctx->error = msgprintf("Error: %s%lld%s%lld%s\n\nBacktrace:\n%s",
                                   "Value of (core language) shape (",
                                   (long long) flat_dim_18552,
                                   ") cannot match shape of type `[",
                                   (long long) lenX_18471, "]t`.",
                                   "-> #0  /prelude/array.fut:127:3-20\n   #1  /prelude/functional.fut:9:42-44\n   #2  noise.fut:42:42-45:22\n   #3  /prelude/functional.fut:9:42-44\n   #4  noise.fut:46:14-48:14\n   #5  noise.fut:68:23-53\n   #6  /prelude/functional.fut:9:42-44\n   #7  noise.fut:66:20-68:54\n   #8  noise.fut:92:18-48\n   #9  noise.fut:88:1-97:37\n");
            if (memblock_unref_device(ctx, &mem_20303, "mem_20303") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20297, "mem_20297") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20292, "mem_20292") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_param_20286,
                                      "mem_param_20286") != 0)
                return 1;
            if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") !=
                0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") !=
                0)
                return 1;
            return 1;
        }
        
        int64_t nest_sizze_19480 = lenX_18471 * flat_dim_18552;
        int64_t segmap_usable_groups_19482 = sdiv_up64(nest_sizze_19480,
                                                       segmap_group_sizze_19481);
        int64_t binop_x_20305 = lenX_18471 * noise_2d_arg_18506;
        int64_t binop_x_20306 = defunc_0_f_res_18501 * binop_x_20305;
        int64_t binop_y_20307 = (int64_t) 8 * binop_x_20306;
        int64_t bytes_20308 = smax64((int64_t) 0, binop_y_20307);
        struct memblock_device mem_20309;
        
        mem_20309.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20309, bytes_20308, "mem_20309")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 1,
                                                sizeof(lenX_18471),
                                                &lenX_18471));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 2,
                                                sizeof(defunc_0_f_res_18501),
                                                &defunc_0_f_res_18501));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 3,
                                                sizeof(i64_res_18502),
                                                &i64_res_18502));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 4,
                                                sizeof(noise_2d_arg_18506),
                                                &noise_2d_arg_18506));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 5,
                                                sizeof(flat_dim_18552),
                                                &flat_dim_18552));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 6,
                                                sizeof(mem_20303.mem),
                                                &mem_20303.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19425, 7,
                                                sizeof(mem_20309.mem),
                                                &mem_20309.mem));
        if (1 * ((size_t) segmap_usable_groups_19482 *
                 (size_t) segmap_group_sizze_19481) != 0) {
            const size_t global_work_sizze_20805[1] =
                         {(size_t) segmap_usable_groups_19482 *
                         (size_t) segmap_group_sizze_19481};
            const size_t local_work_sizze_20809[1] =
                         {(size_t) segmap_group_sizze_19481};
            int64_t time_start_20806 = 0, time_end_20807 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "main.segmap_19425", global_work_sizze_20805[0],
                        local_work_sizze_20809[0], (int) 0);
                time_start_20806 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_19425,
                                                            1, NULL,
                                                            global_work_sizze_20805,
                                                            local_work_sizze_20809,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_19425_runs,
                                                                                                      &ctx->mainzisegmap_19425_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20807 = get_wall_time();
                
                long time_diff_20808 = time_end_20807 - time_start_20806;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "main.segmap_19425", time_diff_20808);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_20303, "mem_20303") != 0)
            return 1;
        
        struct memblock_device mem_20314;
        
        mem_20314.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20314, bytes_20277, "mem_20314")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 1,
                                                sizeof(lenX_18471),
                                                &lenX_18471));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 2,
                                                sizeof(defunc_0_f_res_18501),
                                                &defunc_0_f_res_18501));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 3,
                                                sizeof(noise_2d_arg_18506),
                                                &noise_2d_arg_18506));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 4,
                                                sizeof(flat_dim_18552),
                                                &flat_dim_18552));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 5,
                                                sizeof(mem_param_20286.mem),
                                                &mem_param_20286.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 6,
                                                sizeof(mem_20309.mem),
                                                &mem_20309.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19503, 7,
                                                sizeof(mem_20314.mem),
                                                &mem_20314.mem));
        if (1 * ((size_t) segmap_usable_groups_19527 *
                 (size_t) segmap_group_sizze_19526) != 0) {
            const size_t global_work_sizze_20810[1] =
                         {(size_t) segmap_usable_groups_19527 *
                         (size_t) segmap_group_sizze_19526};
            const size_t local_work_sizze_20814[1] =
                         {(size_t) segmap_group_sizze_19526};
            int64_t time_start_20811 = 0, time_end_20812 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "main.segmap_19503", global_work_sizze_20810[0],
                        local_work_sizze_20814[0], (int) 0);
                time_start_20811 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->mainzisegmap_19503,
                                                            1, NULL,
                                                            global_work_sizze_20810,
                                                            local_work_sizze_20814,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->mainzisegmap_19503_runs,
                                                                                                      &ctx->mainzisegmap_19503_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20812 = get_wall_time();
                
                long time_diff_20813 = time_end_20812 - time_start_20811;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "main.segmap_19503", time_diff_20813);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_20309, "mem_20309") != 0)
            return 1;
        
        struct memblock_device mem_param_tmp_20607;
        
        mem_param_tmp_20607.references = NULL;
        if (memblock_set_device(ctx, &mem_param_tmp_20607, &mem_20314,
                                "mem_20314") != 0)
            return 1;
        if (memblock_set_device(ctx, &mem_param_20286, &mem_param_tmp_20607,
                                "mem_param_tmp_20607") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_param_tmp_20607,
                                  "mem_param_tmp_20607") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20314, "mem_20314") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20309, "mem_20309") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20303, "mem_20303") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20297, "mem_20297") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20292, "mem_20292") != 0)
            return 1;
    }
    if (memblock_set_device(ctx, &ext_mem_20317, &mem_param_20286,
                            "mem_param_20286") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
        return 1;
    
    int64_t segmap_group_sizze_19618;
    
    segmap_group_sizze_19618 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19581;
    
    int64_t segmap_usable_groups_19619 = sdiv_up64(binop_x_20275,
                                                   segmap_group_sizze_19618);
    int64_t bytes_20327 = smax64((int64_t) 0, binop_x_20275);
    struct memblock_device mem_20328;
    
    mem_20328.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20328, bytes_20327, "mem_20328")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19578, 1,
                                            sizeof(lenX_18471), &lenX_18471));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19578, 2,
                                            sizeof(ext_mem_20317.mem),
                                            &ext_mem_20317.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19578, 3,
                                            sizeof(mem_20328.mem),
                                            &mem_20328.mem));
    if (1 * ((size_t) segmap_usable_groups_19619 *
             (size_t) segmap_group_sizze_19618) != 0) {
        const size_t global_work_sizze_20815[1] =
                     {(size_t) segmap_usable_groups_19619 *
                     (size_t) segmap_group_sizze_19618};
        const size_t local_work_sizze_20819[1] =
                     {(size_t) segmap_group_sizze_19618};
        int64_t time_start_20816 = 0, time_end_20817 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "main.segmap_19578", global_work_sizze_20815[0],
                    local_work_sizze_20819[0], (int) 0);
            time_start_20816 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->mainzisegmap_19578,
                                                        1, NULL,
                                                        global_work_sizze_20815,
                                                        local_work_sizze_20819,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->mainzisegmap_19578_runs,
                                                                                                  &ctx->mainzisegmap_19578_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20817 = get_wall_time();
            
            long time_diff_20818 = time_end_20817 - time_start_20816;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "main.segmap_19578",
                    time_diff_20818);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") != 0)
        return 1;
    
    int64_t y_19631 = (int64_t) 3 * lenX_18471;
    int64_t nest_sizze_19632 = lenX_18471 * y_19631;
    int64_t segmap_group_sizze_19633;
    
    segmap_group_sizze_19633 =
        *ctx->tuning_params.mainzisegmap_group_sizze_19563;
    
    int64_t segmap_usable_groups_19634 = sdiv_up64(nest_sizze_19632,
                                                   segmap_group_sizze_19633);
    int64_t binop_y_20331 = (int64_t) 3 * binop_x_20275;
    int64_t bytes_20332 = smax64((int64_t) 0, binop_y_20331);
    struct memblock_device mem_20333;
    
    mem_20333.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20333, bytes_20332, "mem_20333")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19559, 1,
                                            sizeof(lenX_18471), &lenX_18471));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19559, 2,
                                            sizeof(mem_20328.mem),
                                            &mem_20328.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->mainzisegmap_19559, 3,
                                            sizeof(mem_20333.mem),
                                            &mem_20333.mem));
    if (1 * ((size_t) segmap_usable_groups_19634 *
             (size_t) segmap_group_sizze_19633) != 0) {
        const size_t global_work_sizze_20820[1] =
                     {(size_t) segmap_usable_groups_19634 *
                     (size_t) segmap_group_sizze_19633};
        const size_t local_work_sizze_20824[1] =
                     {(size_t) segmap_group_sizze_19633};
        int64_t time_start_20821 = 0, time_end_20822 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "main.segmap_19559", global_work_sizze_20820[0],
                    local_work_sizze_20824[0], (int) 0);
            time_start_20821 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->mainzisegmap_19559,
                                                        1, NULL,
                                                        global_work_sizze_20820,
                                                        local_work_sizze_20824,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->mainzisegmap_19559_runs,
                                                                                                  &ctx->mainzisegmap_19559_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20822 = get_wall_time();
            
            long time_diff_20823 = time_end_20822 - time_start_20821;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n", "main.segmap_19559",
                    time_diff_20823);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_unref_device(ctx, &mem_20328, "mem_20328") != 0)
        return 1;
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20333, "mem_20333") != 0)
        return 1;
    (*mem_out_p_20789).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20789, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20333, "mem_20333") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20328, "mem_20328") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_param_20286, "mem_param_20286") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ext_mem_20317, "ext_mem_20317") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixAbs(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20825,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2080U_18346, int64_t nz2082U_18347)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t nest_sizze_18702 = nz2080U_18346 * nz2082U_18347;
    int64_t segmap_group_sizze_18703;
    
    segmap_group_sizze_18703 =
        *ctx->tuning_params.matrixAbszisegmap_group_sizze_18685;
    
    int64_t segmap_usable_groups_18704 = sdiv_up64(nest_sizze_18702,
                                                   segmap_group_sizze_18703);
    int64_t binop_y_20278 = (int64_t) 4 * nest_sizze_18702;
    int64_t bytes_20279 = smax64((int64_t) 0, binop_y_20278);
    struct memblock_device mem_20280;
    
    mem_20280.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20280, bytes_20279, "mem_20280")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAbszisegmap_18682, 1,
                                            sizeof(nz2080U_18346),
                                            &nz2080U_18346));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAbszisegmap_18682, 2,
                                            sizeof(nz2082U_18347),
                                            &nz2082U_18347));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAbszisegmap_18682, 3,
                                            sizeof(as_mem_20275.mem),
                                            &as_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAbszisegmap_18682, 4,
                                            sizeof(mem_20280.mem),
                                            &mem_20280.mem));
    if (1 * ((size_t) segmap_usable_groups_18704 *
             (size_t) segmap_group_sizze_18703) != 0) {
        const size_t global_work_sizze_20826[1] =
                     {(size_t) segmap_usable_groups_18704 *
                     (size_t) segmap_group_sizze_18703};
        const size_t local_work_sizze_20830[1] =
                     {(size_t) segmap_group_sizze_18703};
        int64_t time_start_20827 = 0, time_end_20828 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "matrixAbs.segmap_18682", global_work_sizze_20826[0],
                    local_work_sizze_20830[0], (int) 0);
            time_start_20827 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->matrixAbszisegmap_18682,
                                                        1, NULL,
                                                        global_work_sizze_20826,
                                                        local_work_sizze_20830,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->matrixAbszisegmap_18682_runs,
                                                                                                  &ctx->matrixAbszisegmap_18682_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20828 = get_wall_time();
            
            long time_diff_20829 = time_end_20828 - time_start_20827;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "matrixAbs.segmap_18682", time_diff_20829);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20280, "mem_20280") != 0)
        return 1;
    (*mem_out_p_20825).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20825, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20280, "mem_20280") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixAdd(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20831,
                                  struct memblock_device A_mem_20275,
                                  struct memblock_device B_mem_20276,
                                  int64_t i_18371, int64_t j_18372)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t nest_sizze_18815 = i_18371 * j_18372;
    int64_t segmap_group_sizze_18816;
    
    segmap_group_sizze_18816 =
        *ctx->tuning_params.matrixAddzisegmap_group_sizze_18796;
    
    int64_t segmap_usable_groups_18817 = sdiv_up64(nest_sizze_18815,
                                                   segmap_group_sizze_18816);
    int64_t binop_y_20279 = (int64_t) 4 * nest_sizze_18815;
    int64_t bytes_20280 = smax64((int64_t) 0, binop_y_20279);
    struct memblock_device mem_20281;
    
    mem_20281.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20281, bytes_20280, "mem_20281")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAddzisegmap_18793, 1,
                                            sizeof(i_18371), &i_18371));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAddzisegmap_18793, 2,
                                            sizeof(j_18372), &j_18372));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAddzisegmap_18793, 3,
                                            sizeof(A_mem_20275.mem),
                                            &A_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAddzisegmap_18793, 4,
                                            sizeof(B_mem_20276.mem),
                                            &B_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixAddzisegmap_18793, 5,
                                            sizeof(mem_20281.mem),
                                            &mem_20281.mem));
    if (1 * ((size_t) segmap_usable_groups_18817 *
             (size_t) segmap_group_sizze_18816) != 0) {
        const size_t global_work_sizze_20832[1] =
                     {(size_t) segmap_usable_groups_18817 *
                     (size_t) segmap_group_sizze_18816};
        const size_t local_work_sizze_20836[1] =
                     {(size_t) segmap_group_sizze_18816};
        int64_t time_start_20833 = 0, time_end_20834 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "matrixAdd.segmap_18793", global_work_sizze_20832[0],
                    local_work_sizze_20836[0], (int) 0);
            time_start_20833 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->matrixAddzisegmap_18793,
                                                        1, NULL,
                                                        global_work_sizze_20832,
                                                        local_work_sizze_20836,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->matrixAddzisegmap_18793_runs,
                                                                                                  &ctx->matrixAddzisegmap_18793_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20834 = get_wall_time();
            
            long time_diff_20835 = time_end_20834 - time_start_20833;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "matrixAdd.segmap_18793", time_diff_20835);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20281, "mem_20281") != 0)
        return 1;
    (*mem_out_p_20831).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20831, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20281, "mem_20281") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixMatrixMul(struct futhark_context *ctx,
                                        struct memblock_device *mem_out_p_20837,
                                        struct memblock_device A_mem_20275,
                                        struct memblock_device B_mem_20276,
                                        int64_t i_18444, int64_t j_18445,
                                        int64_t k_18446)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    bool suff_outer_par_19052;
    
    suff_outer_par_19052 =
        *ctx->tuning_params.matrixMatrixMulzisuff_outer_par_0 <= i_18444;
    if (ctx->logging)
        fprintf(ctx->log, "Compared %s <= %ld: %s.\n",
                "matrixMatrixMul.suff_outer_par_0", (long) i_18444,
                suff_outer_par_19052 ? "true" : "false");
    
    int64_t segmap_group_sizze_19072;
    
    segmap_group_sizze_19072 =
        *ctx->tuning_params.matrixMatrixMulzisegmap_group_sizze_19056;
    
    int64_t num_groups_19073;
    int32_t max_num_groups_20595;
    
    max_num_groups_20595 =
        *ctx->tuning_params.matrixMatrixMulzisegmap_num_groups_19058;
    num_groups_19073 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(i_18444,
                                                            segmap_group_sizze_19072),
                                                  sext_i32_i64(max_num_groups_20595))));
    
    int64_t comparatee_19148 = i_18444 * k_18446;
    bool suff_outer_par_19149;
    
    suff_outer_par_19149 =
        *ctx->tuning_params.matrixMatrixMulzisuff_outer_par_1 <=
        comparatee_19148;
    if (ctx->logging)
        fprintf(ctx->log, "Compared %s <= %ld: %s.\n",
                "matrixMatrixMul.suff_outer_par_1", (long) comparatee_19148,
                suff_outer_par_19149 ? "true" : "false");
    
    int64_t nest_sizze_19163 = j_18445 * comparatee_19148;
    int64_t segred_group_sizze_19164;
    
    segred_group_sizze_19164 =
        *ctx->tuning_params.matrixMatrixMulzisegred_group_sizze_19112;
    
    int64_t num_groups_19165;
    int32_t max_num_groups_20596;
    
    max_num_groups_20596 =
        *ctx->tuning_params.matrixMatrixMulzisegred_num_groups_19114;
    num_groups_19165 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(nest_sizze_19163,
                                                            segred_group_sizze_19164),
                                                  sext_i32_i64(max_num_groups_20596))));
    
    int64_t Ty_19811;
    
    Ty_19811 = *ctx->tuning_params.matrixMatrixMulziTy_19808;
    
    int64_t Ry_19812;
    
    Ry_19812 = *ctx->tuning_params.matrixMatrixMulziRy_19810;
    
    int64_t Tx_19813;
    
    Tx_19813 = *ctx->tuning_params.matrixMatrixMulziTx_19807;
    
    int64_t Rx_19814;
    
    Rx_19814 = *ctx->tuning_params.matrixMatrixMulziRx_19809;
    
    int64_t Tk_19815;
    
    Tk_19815 = *ctx->tuning_params.matrixMatrixMulziTk_19806;
    
    int64_t TxRx_19818 = Tx_19813 * Rx_19814;
    int64_t TyRy_19819 = Ty_19811 * Ry_19812;
    int64_t a_loc_szz_19821 = Tk_19815 * TyRy_19819;
    int64_t binop_x_19822 = Tx_19813 * Tk_19815;
    int64_t b_loc_szz_19823 = Rx_19814 * binop_x_19822;
    int64_t group_sizze_19827 = Ty_19811 * Tx_19813;
    int64_t binop_x_20277 = i_18444 * j_18445;
    int64_t bytes_20278 = (int64_t) 4 * binop_x_20277;
    int64_t bytes_20297 = (int64_t) 4 * comparatee_19148;
    int64_t binop_y_20281 = (int64_t) 4 * k_18446;
    int64_t bytes_20282 = smax64((int64_t) 0, binop_y_20281);
    int64_t bytes_20505 = smax64((int64_t) 0, bytes_20297);
    int64_t binop_x_20309 = Ry_19812 * group_sizze_19827;
    int64_t binop_x_20310 = Rx_19814 * binop_x_20309;
    int64_t bytes_20311 = (int64_t) 4 * binop_x_20310;
    int64_t binop_x_20301 = Ry_19812 * Rx_19814;
    int64_t bytes_20302 = (int64_t) 4 * binop_x_20301;
    int64_t binop_y_20313 = (int64_t) 4 * a_loc_szz_19821;
    int64_t bytes_20314 = smax64((int64_t) 0, binop_y_20313);
    int64_t binop_y_20316 = (int64_t) 4 * b_loc_szz_19823;
    int64_t bytes_20317 = smax64((int64_t) 0, binop_y_20316);
    int64_t bytes_20388 = (int64_t) 4 * binop_x_20309;
    int64_t binop_x_20391 = Rx_19814 * group_sizze_19827;
    int64_t bytes_20392 = (int64_t) 4 * binop_x_20391;
    int64_t bytes_20378 = (int64_t) 4 * Ry_19812;
    int64_t bytes_20380 = (int64_t) 4 * Rx_19814;
    int64_t binop_x_20518 = (int64_t) 4 * Ty_19811;
    int64_t binop_x_20519 = Tx_19813 * binop_x_20518;
    int64_t binop_x_20520 = Ry_19812 * binop_x_20519;
    int64_t sizze_20521 = Rx_19814 * binop_x_20520;
    int64_t binop_x_20494 = j_18445 * k_18446;
    int64_t bytes_20495 = (int64_t) 4 * binop_x_20494;
    int64_t binop_x_20529 = (int64_t) 4 * Ty_19811;
    int64_t binop_x_20530 = Tx_19813 * binop_x_20529;
    int64_t binop_x_20531 = Ry_19812 * binop_x_20530;
    int64_t num_bytes_20532 = Rx_19814 * binop_x_20531;
    int64_t binop_x_20537 = (int64_t) 4 * Ty_19811;
    int64_t binop_x_20538 = Tx_19813 * binop_x_20537;
    int64_t binop_x_20539 = Ry_19812 * binop_x_20538;
    int64_t num_bytes_20540 = Rx_19814 * binop_x_20539;
    int64_t maxSubHelper_20554 = umax64(num_bytes_20532, num_bytes_20540);
    int64_t maxSubHelper_20555 = umax64(bytes_20311, sizze_20521);
    int64_t num_threads_20579 = segmap_group_sizze_19072 * num_groups_19073;
    int64_t total_sizze_20580 = bytes_20282 * num_threads_20579;
    struct memblock_device ext_mem_20508;
    
    ext_mem_20508.references = NULL;
    
    int32_t local_memory_capacity_20755;
    
    local_memory_capacity_20755 = ctx->opencl.max_local_memory;
    if (sle64((int64_t) 0, sext_i32_i64(local_memory_capacity_20755)) &&
        suff_outer_par_19052) {
        struct memblock_device mem_20279;
        
        mem_20279.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20279, bytes_20278, "mem_20279")) {
            err = 1;
            goto cleanup;
        }
        if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_20279, (int64_t) 0,
                                                  A_mem_20275, (int64_t) 0,
                                                  (int64_t) 1, j_18445,
                                                  i_18444) != 0) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mem_20298;
        
        mem_20298.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20298, bytes_20297, "mem_20298")) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device color_20548;
        
        color_20548.references = NULL;
        if (memblock_alloc_device(ctx, &color_20548, total_sizze_20580,
                                  "color_20548")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                1, sizeof(i_18444), &i_18444));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                2, sizeof(j_18445), &j_18445));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                3, sizeof(k_18446), &k_18446));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                4, sizeof(num_groups_19073),
                                                &num_groups_19073));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                5, sizeof(num_threads_20579),
                                                &num_threads_20579));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                6, sizeof(B_mem_20276.mem),
                                                &B_mem_20276.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                7, sizeof(mem_20279.mem),
                                                &mem_20279.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                8, sizeof(mem_20298.mem),
                                                &mem_20298.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_19054,
                                                9, sizeof(color_20548.mem),
                                                &color_20548.mem));
        if (1 * ((size_t) num_groups_19073 *
                 (size_t) segmap_group_sizze_19072) != 0) {
            const size_t global_work_sizze_20838[1] =
                         {(size_t) num_groups_19073 *
                         (size_t) segmap_group_sizze_19072};
            const size_t local_work_sizze_20842[1] =
                         {(size_t) segmap_group_sizze_19072};
            int64_t time_start_20839 = 0, time_end_20840 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "matrixMatrixMul.segmap_19054",
                        global_work_sizze_20838[0], local_work_sizze_20842[0],
                        (int) 0);
                time_start_20839 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->matrixMatrixMulzisegmap_19054,
                                                            1, NULL,
                                                            global_work_sizze_20838,
                                                            local_work_sizze_20842,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->matrixMatrixMulzisegmap_19054_runs,
                                                                                                      &ctx->matrixMatrixMulzisegmap_19054_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20840 = get_wall_time();
                
                long time_diff_20841 = time_end_20840 - time_start_20839;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "matrixMatrixMul.segmap_19054", time_diff_20841);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
            return 1;
        if (memblock_unref_device(ctx, &color_20548, "color_20548") != 0)
            return 1;
        
        struct memblock_device mem_20506;
        
        mem_20506.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20506, bytes_20505, "mem_20506")) {
            err = 1;
            goto cleanup;
        }
        if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_20506, (int64_t) 0,
                                                  mem_20298, (int64_t) 0,
                                                  (int64_t) 1, i_18444,
                                                  k_18446) != 0) {
            err = 1;
            goto cleanup;
        }
        if (memblock_unref_device(ctx, &mem_20298, "mem_20298") != 0)
            return 1;
        if (memblock_set_device(ctx, &ext_mem_20508, &mem_20506, "mem_20506") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20506, "mem_20506") != 0)
            return 1;
        if (memblock_unref_device(ctx, &color_20548, "color_20548") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20298, "mem_20298") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
            return 1;
    } else {
        struct memblock_device ext_mem_20502;
        
        ext_mem_20502.references = NULL;
        
        int32_t local_memory_capacity_20754;
        
        local_memory_capacity_20754 = ctx->opencl.max_local_memory;
        if (sle64(bytes_20317 + srem64((int64_t) 8 - srem64(bytes_20317,
                                                            (int64_t) 8),
                                       (int64_t) 8) + (bytes_20314 +
                                                       srem64((int64_t) 8 -
                                                              srem64(bytes_20314,
                                                                     (int64_t) 8),
                                                              (int64_t) 8)),
                  sext_i32_i64(local_memory_capacity_20754)) &&
            suff_outer_par_19149) {
            int64_t tk_div_tx_19816 = sdiv_up64(Tk_19815, Tx_19813);
            int64_t tk_div_ty_19817 = sdiv_up64(Tk_19815, Ty_19811);
            int64_t gridDim_x_19824 = sdiv_up64(k_18446, TxRx_19818);
            int64_t gridDim_y_19825 = sdiv_up64(i_18444, TyRy_19819);
            int64_t grid_sizze_19826 = gridDim_x_19824 * gridDim_y_19825;
            int64_t full_tiles_19855 = squot64(j_18445, Tk_19815);
            int64_t kk_20058 = Tk_19815 * full_tiles_19855;
            struct memblock_device mem_20493;
            
            mem_20493.references = NULL;
            if (memblock_alloc_device(ctx, &mem_20493, bytes_20505,
                                      "mem_20493")) {
                err = 1;
                goto cleanup;
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegMap");
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    1, (size_t) bytes_20314,
                                                    NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    2, (size_t) bytes_20317,
                                                    NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    3, sizeof(i_18444),
                                                    &i_18444));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    4, sizeof(j_18445),
                                                    &j_18445));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    5, sizeof(k_18446),
                                                    &k_18446));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    6, sizeof(gridDim_x_19824),
                                                    &gridDim_x_19824));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    7, sizeof(gridDim_y_19825),
                                                    &gridDim_y_19825));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    8, sizeof(full_tiles_19855),
                                                    &full_tiles_19855));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    9, sizeof(kk_20058),
                                                    &kk_20058));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    10, sizeof(A_mem_20275.mem),
                                                    &A_mem_20275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    11, sizeof(B_mem_20276.mem),
                                                    &B_mem_20276.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                    12, sizeof(mem_20493.mem),
                                                    &mem_20493.mem));
            if (1 * ((size_t) grid_sizze_19826 * (size_t) group_sizze_19827) !=
                0) {
                const size_t global_work_sizze_20843[1] =
                             {(size_t) grid_sizze_19826 *
                             (size_t) group_sizze_19827};
                const size_t local_work_sizze_20847[1] =
                             {(size_t) group_sizze_19827};
                int64_t time_start_20844 = 0, time_end_20845 = 0;
                
                if (ctx->debugging) {
                    fprintf(ctx->log,
                            "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                            "matrixMatrixMul.segmap_intragroup_19830",
                            global_work_sizze_20843[0],
                            local_work_sizze_20847[0], (int) (0 + bytes_20314 +
                                                              bytes_20317));
                    time_start_20844 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->matrixMatrixMulzisegmap_intragroup_19830,
                                                                1, NULL,
                                                                global_work_sizze_20843,
                                                                local_work_sizze_20847,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->matrixMatrixMulzisegmap_intragroup_19830_runs,
                                                                                                          &ctx->matrixMatrixMulzisegmap_intragroup_19830_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_20845 = get_wall_time();
                    
                    long time_diff_20846 = time_end_20845 - time_start_20844;
                    
                    fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                            "matrixMatrixMul.segmap_intragroup_19830",
                            time_diff_20846);
                }
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_set_device(ctx, &ext_mem_20502, &mem_20493,
                                    "mem_20493") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20493, "mem_20493") != 0)
                return 1;
        } else {
            struct memblock_device mem_20496;
            
            mem_20496.references = NULL;
            if (memblock_alloc_device(ctx, &mem_20496, bytes_20495,
                                      "mem_20496")) {
                err = 1;
                goto cleanup;
            }
            if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_20496,
                                                      (int64_t) 0, B_mem_20276,
                                                      (int64_t) 0, (int64_t) 1,
                                                      k_18446, j_18445) != 0) {
                err = 1;
                goto cleanup;
            }
            
            struct memblock_device mem_20501;
            
            mem_20501.references = NULL;
            if (memblock_alloc_device(ctx, &mem_20501, bytes_20505,
                                      "mem_20501")) {
                err = 1;
                goto cleanup;
            }
            if (slt64(j_18445 * (int64_t) 2, segred_group_sizze_19164)) {
                int64_t segment_sizze_nonzzero_20686 = smax64((int64_t) 1,
                                                              j_18445);
                int64_t num_threads_20687 = num_groups_19165 *
                        segred_group_sizze_19164;
                
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "\n# SegRed-small");
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "num_segments",
                            (long long) (i_18444 * k_18446), '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "segment_size",
                            (long long) j_18445, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "segments_per_group",
                            (long long) squot64(segred_group_sizze_19164,
                                                segment_sizze_nonzzero_20686),
                            '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "required_groups",
                            (long long) sext_i64_i32(sdiv_up64(i_18444 *
                                                               k_18446,
                                                               squot64(segred_group_sizze_19164,
                                                                       segment_sizze_nonzzero_20686))),
                            '\n');
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        1,
                                                        (size_t) ((int64_t) 4 *
                                                                  segred_group_sizze_19164),
                                                        NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        2, sizeof(i_18444),
                                                        &i_18444));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        3, sizeof(j_18445),
                                                        &j_18445));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        4, sizeof(k_18446),
                                                        &k_18446));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        5,
                                                        sizeof(num_groups_19165),
                                                        &num_groups_19165));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        6,
                                                        sizeof(segment_sizze_nonzzero_20686),
                                                        &segment_sizze_nonzzero_20686));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        7,
                                                        sizeof(A_mem_20275.mem),
                                                        &A_mem_20275.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        8,
                                                        sizeof(mem_20496.mem),
                                                        &mem_20496.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_small_19118,
                                                        9,
                                                        sizeof(mem_20501.mem),
                                                        &mem_20501.mem));
                if (1 * ((size_t) num_groups_19165 *
                         (size_t) segred_group_sizze_19164) != 0) {
                    const size_t global_work_sizze_20848[1] =
                                 {(size_t) num_groups_19165 *
                                 (size_t) segred_group_sizze_19164};
                    const size_t local_work_sizze_20852[1] =
                                 {(size_t) segred_group_sizze_19164};
                    int64_t time_start_20849 = 0, time_end_20850 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(ctx->log,
                                "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                                "matrixMatrixMul.segred_small_19118",
                                global_work_sizze_20848[0],
                                local_work_sizze_20852[0], (int) (0 +
                                                                  (int64_t) 4 *
                                                                  segred_group_sizze_19164));
                        time_start_20849 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->matrixMatrixMulzisegred_small_19118,
                                                                    1, NULL,
                                                                    global_work_sizze_20848,
                                                                    local_work_sizze_20852,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->matrixMatrixMulzisegred_small_19118_runs,
                                                                                                              &ctx->matrixMatrixMulzisegred_small_19118_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_20850 = get_wall_time();
                        
                        long time_diff_20851 = time_end_20850 -
                             time_start_20849;
                        
                        fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                                "matrixMatrixMul.segred_small_19118",
                                time_diff_20851);
                    }
                }
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "");
            } else {
                int64_t groups_per_segment_20711 = sdiv_up64(num_groups_19165,
                                                             smax64((int64_t) 1,
                                                                    i_18444 *
                                                                    k_18446));
                int64_t elements_per_thread_20712 = sdiv_up64(j_18445,
                                                              segred_group_sizze_19164 *
                                                              groups_per_segment_20711);
                int64_t virt_num_groups_20713 = groups_per_segment_20711 *
                        (i_18444 * k_18446);
                int64_t num_threads_20714 = num_groups_19165 *
                        segred_group_sizze_19164;
                int64_t threads_per_segment_20715 = groups_per_segment_20711 *
                        segred_group_sizze_19164;
                
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "\n# SegRed-large");
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "num_segments",
                            (long long) (i_18444 * k_18446), '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "segment_size",
                            (long long) j_18445, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "virt_num_groups",
                            (long long) virt_num_groups_20713, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "num_groups",
                            (long long) num_groups_19165, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "group_size",
                            (long long) segred_group_sizze_19164, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "elems_per_thread",
                            (long long) elements_per_thread_20712, '\n');
                if (ctx->debugging)
                    fprintf(ctx->log, "%s: %llu%c", "groups_per_segment",
                            (long long) groups_per_segment_20711, '\n');
                
                struct memblock_device segred_tmp_mem_20716;
                
                segred_tmp_mem_20716.references = NULL;
                if (memblock_alloc_device(ctx, &segred_tmp_mem_20716,
                                          (int64_t) 4 * virt_num_groups_20713,
                                          "segred_tmp_mem_20716")) {
                    err = 1;
                    goto cleanup;
                }
                
                struct memblock_device matrixMatrixMulzicounter_mem_20718 =
                                       ctx->matrixMatrixMulzicounter_mem_20718;
                
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        1, (size_t) 1, NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        2,
                                                        (size_t) ((int64_t) 4 *
                                                                  segred_group_sizze_19164),
                                                        NULL));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        3, sizeof(i_18444),
                                                        &i_18444));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        4, sizeof(j_18445),
                                                        &j_18445));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        5, sizeof(k_18446),
                                                        &k_18446));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        6,
                                                        sizeof(num_groups_19165),
                                                        &num_groups_19165));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        7,
                                                        sizeof(groups_per_segment_20711),
                                                        &groups_per_segment_20711));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        8,
                                                        sizeof(elements_per_thread_20712),
                                                        &elements_per_thread_20712));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        9,
                                                        sizeof(virt_num_groups_20713),
                                                        &virt_num_groups_20713));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        10,
                                                        sizeof(threads_per_segment_20715),
                                                        &threads_per_segment_20715));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        11,
                                                        sizeof(A_mem_20275.mem),
                                                        &A_mem_20275.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        12,
                                                        sizeof(mem_20496.mem),
                                                        &mem_20496.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        13,
                                                        sizeof(mem_20501.mem),
                                                        &mem_20501.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        14,
                                                        sizeof(segred_tmp_mem_20716.mem),
                                                        &segred_tmp_mem_20716.mem));
                OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMatrixMulzisegred_large_19118,
                                                        15,
                                                        sizeof(matrixMatrixMulzicounter_mem_20718.mem),
                                                        &matrixMatrixMulzicounter_mem_20718.mem));
                if (1 * ((size_t) num_groups_19165 *
                         (size_t) segred_group_sizze_19164) != 0) {
                    const size_t global_work_sizze_20854[1] =
                                 {(size_t) num_groups_19165 *
                                 (size_t) segred_group_sizze_19164};
                    const size_t local_work_sizze_20858[1] =
                                 {(size_t) segred_group_sizze_19164};
                    int64_t time_start_20855 = 0, time_end_20856 = 0;
                    
                    if (ctx->debugging) {
                        fprintf(ctx->log,
                                "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                                "matrixMatrixMul.segred_large_19118",
                                global_work_sizze_20854[0],
                                local_work_sizze_20858[0], (int) (0 + 1 +
                                                                  (int64_t) 4 *
                                                                  segred_group_sizze_19164));
                        time_start_20855 = get_wall_time();
                    }
                    OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                    ctx->matrixMatrixMulzisegred_large_19118,
                                                                    1, NULL,
                                                                    global_work_sizze_20854,
                                                                    local_work_sizze_20858,
                                                                    0, NULL,
                                                                    ctx->profiling_paused ||
                                                                    !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                              &ctx->matrixMatrixMulzisegred_large_19118_runs,
                                                                                                              &ctx->matrixMatrixMulzisegred_large_19118_total_runtime)));
                    if (ctx->debugging) {
                        OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                        time_end_20856 = get_wall_time();
                        
                        long time_diff_20857 = time_end_20856 -
                             time_start_20855;
                        
                        fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                                "matrixMatrixMul.segred_large_19118",
                                time_diff_20857);
                    }
                }
                if (ctx->debugging)
                    fprintf(ctx->log, "%s\n", "");
                if (memblock_unref_device(ctx, &segred_tmp_mem_20716,
                                          "segred_tmp_mem_20716") != 0)
                    return 1;
            }
            if (memblock_unref_device(ctx, &mem_20496, "mem_20496") != 0)
                return 1;
            if (memblock_set_device(ctx, &ext_mem_20502, &mem_20501,
                                    "mem_20501") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20501, "mem_20501") != 0)
                return 1;
            if (memblock_unref_device(ctx, &mem_20496, "mem_20496") != 0)
                return 1;
        }
        if (memblock_set_device(ctx, &ext_mem_20508, &ext_mem_20502,
                                "ext_mem_20502") != 0)
            return 1;
        if (memblock_unref_device(ctx, &ext_mem_20502, "ext_mem_20502") != 0)
            return 1;
    }
    if (memblock_set_device(ctx, &mem_out_20594, &ext_mem_20508,
                            "ext_mem_20508") != 0)
        return 1;
    (*mem_out_p_20837).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20837, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ext_mem_20508, "ext_mem_20508") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixMul(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20859,
                                  struct memblock_device A_mem_20275,
                                  struct memblock_device B_mem_20276,
                                  int64_t i_18393, int64_t j_18394)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t nest_sizze_18895 = i_18393 * j_18394;
    int64_t segmap_group_sizze_18896;
    
    segmap_group_sizze_18896 =
        *ctx->tuning_params.matrixMulzisegmap_group_sizze_18876;
    
    int64_t segmap_usable_groups_18897 = sdiv_up64(nest_sizze_18895,
                                                   segmap_group_sizze_18896);
    int64_t binop_y_20279 = (int64_t) 4 * nest_sizze_18895;
    int64_t bytes_20280 = smax64((int64_t) 0, binop_y_20279);
    struct memblock_device mem_20281;
    
    mem_20281.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20281, bytes_20280, "mem_20281")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMulzisegmap_18873, 1,
                                            sizeof(i_18393), &i_18393));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMulzisegmap_18873, 2,
                                            sizeof(j_18394), &j_18394));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMulzisegmap_18873, 3,
                                            sizeof(A_mem_20275.mem),
                                            &A_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMulzisegmap_18873, 4,
                                            sizeof(B_mem_20276.mem),
                                            &B_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixMulzisegmap_18873, 5,
                                            sizeof(mem_20281.mem),
                                            &mem_20281.mem));
    if (1 * ((size_t) segmap_usable_groups_18897 *
             (size_t) segmap_group_sizze_18896) != 0) {
        const size_t global_work_sizze_20860[1] =
                     {(size_t) segmap_usable_groups_18897 *
                     (size_t) segmap_group_sizze_18896};
        const size_t local_work_sizze_20864[1] =
                     {(size_t) segmap_group_sizze_18896};
        int64_t time_start_20861 = 0, time_end_20862 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "matrixMul.segmap_18873", global_work_sizze_20860[0],
                    local_work_sizze_20864[0], (int) 0);
            time_start_20861 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->matrixMulzisegmap_18873,
                                                        1, NULL,
                                                        global_work_sizze_20860,
                                                        local_work_sizze_20864,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->matrixMulzisegmap_18873_runs,
                                                                                                  &ctx->matrixMulzisegmap_18873_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20862 = get_wall_time();
            
            long time_diff_20863 = time_end_20862 - time_start_20861;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "matrixMul.segmap_18873", time_diff_20863);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20281, "mem_20281") != 0)
        return 1;
    (*mem_out_p_20859).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20859, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20281, "mem_20281") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixSgn(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20865,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2080U_18354, int64_t nz2082U_18355)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t nest_sizze_18739 = nz2080U_18354 * nz2082U_18355;
    int64_t segmap_group_sizze_18740;
    
    segmap_group_sizze_18740 =
        *ctx->tuning_params.matrixSgnzisegmap_group_sizze_18722;
    
    int64_t segmap_usable_groups_18741 = sdiv_up64(nest_sizze_18739,
                                                   segmap_group_sizze_18740);
    int64_t binop_y_20278 = (int64_t) 4 * nest_sizze_18739;
    int64_t bytes_20279 = smax64((int64_t) 0, binop_y_20278);
    struct memblock_device mem_20280;
    
    mem_20280.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20280, bytes_20279, "mem_20280")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSgnzisegmap_18719, 1,
                                            sizeof(nz2080U_18354),
                                            &nz2080U_18354));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSgnzisegmap_18719, 2,
                                            sizeof(nz2082U_18355),
                                            &nz2082U_18355));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSgnzisegmap_18719, 3,
                                            sizeof(as_mem_20275.mem),
                                            &as_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSgnzisegmap_18719, 4,
                                            sizeof(mem_20280.mem),
                                            &mem_20280.mem));
    if (1 * ((size_t) segmap_usable_groups_18741 *
             (size_t) segmap_group_sizze_18740) != 0) {
        const size_t global_work_sizze_20866[1] =
                     {(size_t) segmap_usable_groups_18741 *
                     (size_t) segmap_group_sizze_18740};
        const size_t local_work_sizze_20870[1] =
                     {(size_t) segmap_group_sizze_18740};
        int64_t time_start_20867 = 0, time_end_20868 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "matrixSgn.segmap_18719", global_work_sizze_20866[0],
                    local_work_sizze_20870[0], (int) 0);
            time_start_20867 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->matrixSgnzisegmap_18719,
                                                        1, NULL,
                                                        global_work_sizze_20866,
                                                        local_work_sizze_20870,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->matrixSgnzisegmap_18719_runs,
                                                                                                  &ctx->matrixSgnzisegmap_18719_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20868 = get_wall_time();
            
            long time_diff_20869 = time_end_20868 - time_start_20867;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "matrixSgn.segmap_18719", time_diff_20869);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20280, "mem_20280") != 0)
        return 1;
    (*mem_out_p_20865).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20865, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20280, "mem_20280") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixSub(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20871,
                                  struct memblock_device A_mem_20275,
                                  struct memblock_device B_mem_20276,
                                  int64_t i_18382, int64_t j_18383)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t nest_sizze_18855 = i_18382 * j_18383;
    int64_t segmap_group_sizze_18856;
    
    segmap_group_sizze_18856 =
        *ctx->tuning_params.matrixSubzisegmap_group_sizze_18836;
    
    int64_t segmap_usable_groups_18857 = sdiv_up64(nest_sizze_18855,
                                                   segmap_group_sizze_18856);
    int64_t binop_y_20279 = (int64_t) 4 * nest_sizze_18855;
    int64_t bytes_20280 = smax64((int64_t) 0, binop_y_20279);
    struct memblock_device mem_20281;
    
    mem_20281.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20281, bytes_20280, "mem_20281")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSubzisegmap_18833, 1,
                                            sizeof(i_18382), &i_18382));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSubzisegmap_18833, 2,
                                            sizeof(j_18383), &j_18383));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSubzisegmap_18833, 3,
                                            sizeof(A_mem_20275.mem),
                                            &A_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSubzisegmap_18833, 4,
                                            sizeof(B_mem_20276.mem),
                                            &B_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixSubzisegmap_18833, 5,
                                            sizeof(mem_20281.mem),
                                            &mem_20281.mem));
    if (1 * ((size_t) segmap_usable_groups_18857 *
             (size_t) segmap_group_sizze_18856) != 0) {
        const size_t global_work_sizze_20872[1] =
                     {(size_t) segmap_usable_groups_18857 *
                     (size_t) segmap_group_sizze_18856};
        const size_t local_work_sizze_20876[1] =
                     {(size_t) segmap_group_sizze_18856};
        int64_t time_start_20873 = 0, time_end_20874 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "matrixSub.segmap_18833", global_work_sizze_20872[0],
                    local_work_sizze_20876[0], (int) 0);
            time_start_20873 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->matrixSubzisegmap_18833,
                                                        1, NULL,
                                                        global_work_sizze_20872,
                                                        local_work_sizze_20876,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->matrixSubzisegmap_18833_runs,
                                                                                                  &ctx->matrixSubzisegmap_18833_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20874 = get_wall_time();
            
            long time_diff_20875 = time_end_20874 - time_start_20873;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "matrixSub.segmap_18833", time_diff_20875);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20281, "mem_20281") != 0)
        return 1;
    (*mem_out_p_20871).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20871, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20281, "mem_20281") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_matrixVectorMul(struct futhark_context *ctx,
                                        struct memblock_device *mem_out_p_20877,
                                        struct memblock_device M_mem_20275,
                                        struct memblock_device v_mem_20276,
                                        int64_t i_18417, int64_t j_18418)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    bool suff_outer_par_18934;
    
    suff_outer_par_18934 =
        *ctx->tuning_params.matrixVectorMulzisuff_outer_par_0 <= i_18417;
    if (ctx->logging)
        fprintf(ctx->log, "Compared %s <= %ld: %s.\n",
                "matrixVectorMul.suff_outer_par_0", (long) i_18417,
                suff_outer_par_18934 ? "true" : "false");
    
    int64_t segmap_group_sizze_18950;
    
    segmap_group_sizze_18950 =
        *ctx->tuning_params.matrixVectorMulzisegmap_group_sizze_18938;
    
    int64_t nest_sizze_18979 = i_18417 * j_18418;
    int64_t segred_group_sizze_18980;
    
    segred_group_sizze_18980 =
        *ctx->tuning_params.matrixVectorMulzisegred_group_sizze_18964;
    
    int64_t num_groups_18981;
    int32_t max_num_groups_20595;
    
    max_num_groups_20595 =
        *ctx->tuning_params.matrixVectorMulzisegred_num_groups_18966;
    num_groups_18981 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(nest_sizze_18979,
                                                            segred_group_sizze_18980),
                                                  sext_i32_i64(max_num_groups_20595))));
    
    int64_t bytes_20278 = (int64_t) 4 * nest_sizze_18979;
    int64_t binop_y_20301 = (int64_t) 4 * i_18417;
    int64_t bytes_20302 = smax64((int64_t) 0, binop_y_20301);
    int64_t bytes_20282 = (int64_t) 4 * segmap_group_sizze_18950;
    int64_t bytes_20287 = smax64((int64_t) 0, bytes_20282);
    int64_t num_bytes_20529 = (int64_t) 4 * segmap_group_sizze_18950;
    int64_t maxSubHelper_20548 = umax64(bytes_20282, num_bytes_20529);
    struct memblock_device ext_mem_20308;
    
    ext_mem_20308.references = NULL;
    
    int32_t local_memory_capacity_20675;
    
    local_memory_capacity_20675 = ctx->opencl.max_local_memory;
    if (sle64(bytes_20287 + srem64((int64_t) 8 - srem64(bytes_20287,
                                                        (int64_t) 8),
                                   (int64_t) 8),
              sext_i32_i64(local_memory_capacity_20675)) &&
        suff_outer_par_18934) {
        int64_t segmap_usable_groups_18951 = sdiv_up64(i_18417,
                                                       segmap_group_sizze_18950);
        struct memblock_device mem_20279;
        
        mem_20279.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20279, bytes_20278, "mem_20279")) {
            err = 1;
            goto cleanup;
        }
        if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_20279, (int64_t) 0,
                                                  M_mem_20275, (int64_t) 0,
                                                  (int64_t) 1, j_18418,
                                                  i_18417) != 0) {
            err = 1;
            goto cleanup;
        }
        
        int64_t num_whole_tiles_19815 = squot64(j_18418,
                                                segmap_group_sizze_18950);
        int64_t residual_input_19901 = srem64(j_18418,
                                              segmap_group_sizze_18950);
        bool cond_19902 = residual_input_19901 == (int64_t) 0;
        struct memblock_device mem_20303;
        
        mem_20303.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20303, bytes_20302, "mem_20303")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                1, (size_t) bytes_20287, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                2, sizeof(i_18417), &i_18417));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                3, sizeof(j_18418), &j_18418));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                4,
                                                sizeof(segmap_usable_groups_18951),
                                                &segmap_usable_groups_18951));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                5,
                                                sizeof(num_whole_tiles_19815),
                                                &num_whole_tiles_19815));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                6, sizeof(residual_input_19901),
                                                &residual_input_19901));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                7, sizeof(cond_19902),
                                                &cond_19902));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                8, sizeof(v_mem_20276.mem),
                                                &v_mem_20276.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                9, sizeof(mem_20279.mem),
                                                &mem_20279.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                10, sizeof(mem_20303.mem),
                                                &mem_20303.mem));
        if (1 * ((size_t) segmap_usable_groups_18951 *
                 (size_t) segmap_group_sizze_18950) != 0) {
            const size_t global_work_sizze_20878[1] =
                         {(size_t) segmap_usable_groups_18951 *
                         (size_t) segmap_group_sizze_18950};
            const size_t local_work_sizze_20882[1] =
                         {(size_t) segmap_group_sizze_18950};
            int64_t time_start_20879 = 0, time_end_20880 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "matrixVectorMul.segmap_intragroup_19807",
                        global_work_sizze_20878[0], local_work_sizze_20882[0],
                        (int) (0 + bytes_20287));
                time_start_20879 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->matrixVectorMulzisegmap_intragroup_19807,
                                                            1, NULL,
                                                            global_work_sizze_20878,
                                                            local_work_sizze_20882,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->matrixVectorMulzisegmap_intragroup_19807_runs,
                                                                                                      &ctx->matrixVectorMulzisegmap_intragroup_19807_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20880 = get_wall_time();
                
                long time_diff_20881 = time_end_20880 - time_start_20879;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "matrixVectorMul.segmap_intragroup_19807",
                        time_diff_20881);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
            return 1;
        if (memblock_set_device(ctx, &ext_mem_20308, &mem_20303, "mem_20303") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20303, "mem_20303") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
            return 1;
    } else {
        struct memblock_device mem_20307;
        
        mem_20307.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20307, bytes_20302, "mem_20307")) {
            err = 1;
            goto cleanup;
        }
        if (slt64(j_18418 * (int64_t) 2, segred_group_sizze_18980)) {
            int64_t segment_sizze_nonzzero_20611 = smax64((int64_t) 1, j_18418);
            int64_t num_threads_20612 = num_groups_18981 *
                    segred_group_sizze_18980;
            
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegRed-small");
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "num_segments",
                        (long long) i_18417, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "segment_size",
                        (long long) j_18418, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "segments_per_group",
                        (long long) squot64(segred_group_sizze_18980,
                                            segment_sizze_nonzzero_20611),
                        '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "required_groups",
                        (long long) sext_i64_i32(sdiv_up64(i_18417,
                                                           squot64(segred_group_sizze_18980,
                                                                   segment_sizze_nonzzero_20611))),
                        '\n');
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    1, (size_t) ((int64_t) 4 *
                                                                 segred_group_sizze_18980),
                                                    NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    2, sizeof(i_18417),
                                                    &i_18417));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    3, sizeof(j_18418),
                                                    &j_18418));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    4, sizeof(num_groups_18981),
                                                    &num_groups_18981));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    5,
                                                    sizeof(segment_sizze_nonzzero_20611),
                                                    &segment_sizze_nonzzero_20611));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    6, sizeof(M_mem_20275.mem),
                                                    &M_mem_20275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    7, sizeof(v_mem_20276.mem),
                                                    &v_mem_20276.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_small_18970,
                                                    8, sizeof(mem_20307.mem),
                                                    &mem_20307.mem));
            if (1 * ((size_t) num_groups_18981 *
                     (size_t) segred_group_sizze_18980) != 0) {
                const size_t global_work_sizze_20883[1] =
                             {(size_t) num_groups_18981 *
                             (size_t) segred_group_sizze_18980};
                const size_t local_work_sizze_20887[1] =
                             {(size_t) segred_group_sizze_18980};
                int64_t time_start_20884 = 0, time_end_20885 = 0;
                
                if (ctx->debugging) {
                    fprintf(ctx->log,
                            "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                            "matrixVectorMul.segred_small_18970",
                            global_work_sizze_20883[0],
                            local_work_sizze_20887[0], (int) (0 + (int64_t) 4 *
                                                              segred_group_sizze_18980));
                    time_start_20884 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->matrixVectorMulzisegred_small_18970,
                                                                1, NULL,
                                                                global_work_sizze_20883,
                                                                local_work_sizze_20887,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->matrixVectorMulzisegred_small_18970_runs,
                                                                                                          &ctx->matrixVectorMulzisegred_small_18970_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_20885 = get_wall_time();
                    
                    long time_diff_20886 = time_end_20885 - time_start_20884;
                    
                    fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                            "matrixVectorMul.segred_small_18970",
                            time_diff_20886);
                }
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
        } else {
            int64_t groups_per_segment_20634 = sdiv_up64(num_groups_18981,
                                                         smax64((int64_t) 1,
                                                                i_18417));
            int64_t elements_per_thread_20635 = sdiv_up64(j_18418,
                                                          segred_group_sizze_18980 *
                                                          groups_per_segment_20634);
            int64_t virt_num_groups_20636 = groups_per_segment_20634 * i_18417;
            int64_t num_threads_20637 = num_groups_18981 *
                    segred_group_sizze_18980;
            int64_t threads_per_segment_20638 = groups_per_segment_20634 *
                    segred_group_sizze_18980;
            
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegRed-large");
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "num_segments",
                        (long long) i_18417, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "segment_size",
                        (long long) j_18418, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "virt_num_groups",
                        (long long) virt_num_groups_20636, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "num_groups",
                        (long long) num_groups_18981, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "group_size",
                        (long long) segred_group_sizze_18980, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "elems_per_thread",
                        (long long) elements_per_thread_20635, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "groups_per_segment",
                        (long long) groups_per_segment_20634, '\n');
            
            struct memblock_device segred_tmp_mem_20639;
            
            segred_tmp_mem_20639.references = NULL;
            if (memblock_alloc_device(ctx, &segred_tmp_mem_20639, (int64_t) 4 *
                                      virt_num_groups_20636,
                                      "segred_tmp_mem_20639")) {
                err = 1;
                goto cleanup;
            }
            
            struct memblock_device matrixVectorMulzicounter_mem_20641 =
                                   ctx->matrixVectorMulzicounter_mem_20641;
            
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    1, (size_t) 1, NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    2, (size_t) ((int64_t) 4 *
                                                                 segred_group_sizze_18980),
                                                    NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    3, sizeof(i_18417),
                                                    &i_18417));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    4, sizeof(j_18418),
                                                    &j_18418));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    5, sizeof(num_groups_18981),
                                                    &num_groups_18981));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    6,
                                                    sizeof(groups_per_segment_20634),
                                                    &groups_per_segment_20634));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    7,
                                                    sizeof(elements_per_thread_20635),
                                                    &elements_per_thread_20635));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    8,
                                                    sizeof(virt_num_groups_20636),
                                                    &virt_num_groups_20636));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    9,
                                                    sizeof(threads_per_segment_20638),
                                                    &threads_per_segment_20638));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    10, sizeof(M_mem_20275.mem),
                                                    &M_mem_20275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    11, sizeof(v_mem_20276.mem),
                                                    &v_mem_20276.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    12, sizeof(mem_20307.mem),
                                                    &mem_20307.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    13,
                                                    sizeof(segred_tmp_mem_20639.mem),
                                                    &segred_tmp_mem_20639.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->matrixVectorMulzisegred_large_18970,
                                                    14,
                                                    sizeof(matrixVectorMulzicounter_mem_20641.mem),
                                                    &matrixVectorMulzicounter_mem_20641.mem));
            if (1 * ((size_t) num_groups_18981 *
                     (size_t) segred_group_sizze_18980) != 0) {
                const size_t global_work_sizze_20889[1] =
                             {(size_t) num_groups_18981 *
                             (size_t) segred_group_sizze_18980};
                const size_t local_work_sizze_20893[1] =
                             {(size_t) segred_group_sizze_18980};
                int64_t time_start_20890 = 0, time_end_20891 = 0;
                
                if (ctx->debugging) {
                    fprintf(ctx->log,
                            "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                            "matrixVectorMul.segred_large_18970",
                            global_work_sizze_20889[0],
                            local_work_sizze_20893[0], (int) (0 + 1 +
                                                              (int64_t) 4 *
                                                              segred_group_sizze_18980));
                    time_start_20890 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->matrixVectorMulzisegred_large_18970,
                                                                1, NULL,
                                                                global_work_sizze_20889,
                                                                local_work_sizze_20893,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->matrixVectorMulzisegred_large_18970_runs,
                                                                                                          &ctx->matrixVectorMulzisegred_large_18970_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_20891 = get_wall_time();
                    
                    long time_diff_20892 = time_end_20891 - time_start_20890;
                    
                    fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                            "matrixVectorMul.segred_large_18970",
                            time_diff_20892);
                }
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &segred_tmp_mem_20639,
                                      "segred_tmp_mem_20639") != 0)
                return 1;
        }
        if (memblock_set_device(ctx, &ext_mem_20308, &mem_20307, "mem_20307") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20307, "mem_20307") != 0)
            return 1;
    }
    if (memblock_set_device(ctx, &mem_out_20594, &ext_mem_20308,
                            "ext_mem_20308") != 0)
        return 1;
    (*mem_out_p_20877).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20877, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ext_mem_20308, "ext_mem_20308") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_normalizzeV(struct futhark_context *ctx,
                                    struct memblock_device *mem_out_p_20894,
                                    struct memblock_device v_mem_20275,
                                    int64_t iz2083U_18599)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segred_group_sizze_19652;
    
    segred_group_sizze_19652 =
        *ctx->tuning_params.normalizzeVzisegred_group_sizze_19651;
    
    int64_t num_groups_19654;
    int32_t max_num_groups_20595;
    
    max_num_groups_20595 =
        *ctx->tuning_params.normalizzeVzisegred_num_groups_19653;
    num_groups_19654 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(iz2083U_18599,
                                                            segred_group_sizze_19652),
                                                  sext_i32_i64(max_num_groups_20595))));
    
    struct memblock_device mem_20278;
    
    mem_20278.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20278, (int64_t) 4, "mem_20278")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device normalizzeVzicounter_mem_20596 =
                           ctx->normalizzeVzicounter_mem_20596;
    struct memblock_device segred_tmp_mem_20598;
    
    segred_tmp_mem_20598.references = NULL;
    if (memblock_alloc_device(ctx, &segred_tmp_mem_20598, (int64_t) 4 *
                              num_groups_19654, "segred_tmp_mem_20598")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t num_threads_20600 = num_groups_19654 * segred_group_sizze_19652;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegRed");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            1, (size_t) ((int64_t) 4 *
                                                         segred_group_sizze_19652),
                                            NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            2, (size_t) 1, NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            3, sizeof(iz2083U_18599),
                                            &iz2083U_18599));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            4, sizeof(num_groups_19654),
                                            &num_groups_19654));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            5, sizeof(num_threads_20600),
                                            &num_threads_20600));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            6, sizeof(v_mem_20275.mem),
                                            &v_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            7, sizeof(mem_20278.mem),
                                            &mem_20278.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            8,
                                            sizeof(normalizzeVzicounter_mem_20596.mem),
                                            &normalizzeVzicounter_mem_20596.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegred_nonseg_19659,
                                            9, sizeof(segred_tmp_mem_20598.mem),
                                            &segred_tmp_mem_20598.mem));
    if (1 * ((size_t) num_groups_19654 * (size_t) segred_group_sizze_19652) !=
        0) {
        const size_t global_work_sizze_20896[1] = {(size_t) num_groups_19654 *
                     (size_t) segred_group_sizze_19652};
        const size_t local_work_sizze_20900[1] =
                     {(size_t) segred_group_sizze_19652};
        int64_t time_start_20897 = 0, time_end_20898 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "normalizeV.segred_nonseg_19659",
                    global_work_sizze_20896[0], local_work_sizze_20900[0],
                    (int) (0 + (int64_t) 4 * segred_group_sizze_19652 + 1));
            time_start_20897 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->normalizzeVzisegred_nonseg_19659,
                                                        1, NULL,
                                                        global_work_sizze_20896,
                                                        local_work_sizze_20900,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->normalizzeVzisegred_nonseg_19659_runs,
                                                                                                  &ctx->normalizzeVzisegred_nonseg_19659_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20898 = get_wall_time();
            
            long time_diff_20899 = time_end_20898 - time_start_20897;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "normalizeV.segred_nonseg_19659", time_diff_20899);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
    float read_res_20901;
    
    OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                 mem_20278.mem,
                                                 ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                 (int64_t) 0 * sizeof(float),
                                                 sizeof(float), &read_res_20901,
                                                 0, NULL,
                                                 ctx->profiling_paused ||
                                                 !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                           &ctx->copy_scalar_from_dev_runs,
                                                                                           &ctx->copy_scalar_from_dev_total_runtime)));
    if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
        return 1;
    
    float defunc_0_f_res_18601 = read_res_20901;
    
    if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
        return 1;
    
    float defunc_0_f_res_18607;
    
    defunc_0_f_res_18607 = futrts_sqrt32(defunc_0_f_res_18601);
    
    float f_18608 = 1.0F / defunc_0_f_res_18607;
    int64_t segmap_group_sizze_19669;
    
    segmap_group_sizze_19669 =
        *ctx->tuning_params.normalizzeVzisegmap_group_sizze_19663;
    
    int64_t segmap_usable_groups_19670 = sdiv_up64(iz2083U_18599,
                                                   segmap_group_sizze_19669);
    int64_t binop_y_20280 = (int64_t) 4 * iz2083U_18599;
    int64_t bytes_20281 = smax64((int64_t) 0, binop_y_20280);
    struct memblock_device mem_20282;
    
    mem_20282.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20282, bytes_20281, "mem_20282")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegmap_19661, 1,
                                            sizeof(iz2083U_18599),
                                            &iz2083U_18599));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegmap_19661, 2,
                                            sizeof(f_18608), &f_18608));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegmap_19661, 3,
                                            sizeof(v_mem_20275.mem),
                                            &v_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->normalizzeVzisegmap_19661, 4,
                                            sizeof(mem_20282.mem),
                                            &mem_20282.mem));
    if (1 * ((size_t) segmap_usable_groups_19670 *
             (size_t) segmap_group_sizze_19669) != 0) {
        const size_t global_work_sizze_20902[1] =
                     {(size_t) segmap_usable_groups_19670 *
                     (size_t) segmap_group_sizze_19669};
        const size_t local_work_sizze_20906[1] =
                     {(size_t) segmap_group_sizze_19669};
        int64_t time_start_20903 = 0, time_end_20904 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "normalizeV.segmap_19661", global_work_sizze_20902[0],
                    local_work_sizze_20906[0], (int) 0);
            time_start_20903 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->normalizzeVzisegmap_19661,
                                                        1, NULL,
                                                        global_work_sizze_20902,
                                                        local_work_sizze_20906,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->normalizzeVzisegmap_19661_runs,
                                                                                                  &ctx->normalizzeVzisegmap_19661_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20904 = get_wall_time();
            
            long time_diff_20905 = time_end_20904 - time_start_20903;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "normalizeV.segmap_19661", time_diff_20905);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20282, "mem_20282") != 0)
        return 1;
    (*mem_out_p_20894).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20894, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20282, "mem_20282") != 0)
        return 1;
    if (memblock_unref_device(ctx, &segred_tmp_mem_20598,
                              "segred_tmp_mem_20598") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_scaleM(struct futhark_context *ctx,
                               struct memblock_device *mem_out_p_20907,
                               struct memblock_device as_mem_20275,
                               int64_t nz2081U_18362, int64_t nz2083U_18363,
                               float f_18364)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t nest_sizze_18776 = nz2081U_18362 * nz2083U_18363;
    int64_t segmap_group_sizze_18777;
    
    segmap_group_sizze_18777 =
        *ctx->tuning_params.scaleMzisegmap_group_sizze_18759;
    
    int64_t segmap_usable_groups_18778 = sdiv_up64(nest_sizze_18776,
                                                   segmap_group_sizze_18777);
    int64_t binop_y_20278 = (int64_t) 4 * nest_sizze_18776;
    int64_t bytes_20279 = smax64((int64_t) 0, binop_y_20278);
    struct memblock_device mem_20280;
    
    mem_20280.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20280, bytes_20279, "mem_20280")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleMzisegmap_18756, 1,
                                            sizeof(nz2081U_18362),
                                            &nz2081U_18362));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleMzisegmap_18756, 2,
                                            sizeof(nz2083U_18363),
                                            &nz2083U_18363));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleMzisegmap_18756, 3,
                                            sizeof(f_18364), &f_18364));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleMzisegmap_18756, 4,
                                            sizeof(as_mem_20275.mem),
                                            &as_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleMzisegmap_18756, 5,
                                            sizeof(mem_20280.mem),
                                            &mem_20280.mem));
    if (1 * ((size_t) segmap_usable_groups_18778 *
             (size_t) segmap_group_sizze_18777) != 0) {
        const size_t global_work_sizze_20908[1] =
                     {(size_t) segmap_usable_groups_18778 *
                     (size_t) segmap_group_sizze_18777};
        const size_t local_work_sizze_20912[1] =
                     {(size_t) segmap_group_sizze_18777};
        int64_t time_start_20909 = 0, time_end_20910 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "scaleM.segmap_18756", global_work_sizze_20908[0],
                    local_work_sizze_20912[0], (int) 0);
            time_start_20909 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->scaleMzisegmap_18756,
                                                        1, NULL,
                                                        global_work_sizze_20908,
                                                        local_work_sizze_20912,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->scaleMzisegmap_18756_runs,
                                                                                                  &ctx->scaleMzisegmap_18756_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20910 = get_wall_time();
            
            long time_diff_20911 = time_end_20910 - time_start_20909;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "scaleM.segmap_18756", time_diff_20911);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20280, "mem_20280") != 0)
        return 1;
    (*mem_out_p_20907).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20907, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20280, "mem_20280") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_scaleV(struct futhark_context *ctx,
                               struct memblock_device *mem_out_p_20913,
                               struct memblock_device as_mem_20275,
                               int64_t nz2082U_18411, float f_18412)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segmap_group_sizze_18928;
    
    segmap_group_sizze_18928 =
        *ctx->tuning_params.scaleVzisegmap_group_sizze_18922;
    
    int64_t segmap_usable_groups_18929 = sdiv_up64(nz2082U_18411,
                                                   segmap_group_sizze_18928);
    int64_t binop_y_20277 = (int64_t) 4 * nz2082U_18411;
    int64_t bytes_20278 = smax64((int64_t) 0, binop_y_20277);
    struct memblock_device mem_20279;
    
    mem_20279.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20279, bytes_20278, "mem_20279")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleVzisegmap_18920, 1,
                                            sizeof(nz2082U_18411),
                                            &nz2082U_18411));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleVzisegmap_18920, 2,
                                            sizeof(f_18412), &f_18412));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleVzisegmap_18920, 3,
                                            sizeof(as_mem_20275.mem),
                                            &as_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->scaleVzisegmap_18920, 4,
                                            sizeof(mem_20279.mem),
                                            &mem_20279.mem));
    if (1 * ((size_t) segmap_usable_groups_18929 *
             (size_t) segmap_group_sizze_18928) != 0) {
        const size_t global_work_sizze_20914[1] =
                     {(size_t) segmap_usable_groups_18929 *
                     (size_t) segmap_group_sizze_18928};
        const size_t local_work_sizze_20918[1] =
                     {(size_t) segmap_group_sizze_18928};
        int64_t time_start_20915 = 0, time_end_20916 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "scaleV.segmap_18920", global_work_sizze_20914[0],
                    local_work_sizze_20918[0], (int) 0);
            time_start_20915 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->scaleVzisegmap_18920,
                                                        1, NULL,
                                                        global_work_sizze_20914,
                                                        local_work_sizze_20918,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->scaleVzisegmap_18920_runs,
                                                                                                  &ctx->scaleVzisegmap_18920_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20916 = get_wall_time();
            
            long time_diff_20917 = time_end_20916 - time_start_20915;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "scaleV.segmap_18920", time_diff_20917);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20279, "mem_20279") != 0)
        return 1;
    (*mem_out_p_20913).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20913, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorAbs(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20919,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2081U_18322)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segmap_group_sizze_18621;
    
    segmap_group_sizze_18621 =
        *ctx->tuning_params.vectorAbszisegmap_group_sizze_18615;
    
    int64_t segmap_usable_groups_18622 = sdiv_up64(nz2081U_18322,
                                                   segmap_group_sizze_18621);
    int64_t binop_y_20277 = (int64_t) 4 * nz2081U_18322;
    int64_t bytes_20278 = smax64((int64_t) 0, binop_y_20277);
    struct memblock_device mem_20279;
    
    mem_20279.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20279, bytes_20278, "mem_20279")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAbszisegmap_18613, 1,
                                            sizeof(nz2081U_18322),
                                            &nz2081U_18322));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAbszisegmap_18613, 2,
                                            sizeof(as_mem_20275.mem),
                                            &as_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAbszisegmap_18613, 3,
                                            sizeof(mem_20279.mem),
                                            &mem_20279.mem));
    if (1 * ((size_t) segmap_usable_groups_18622 *
             (size_t) segmap_group_sizze_18621) != 0) {
        const size_t global_work_sizze_20920[1] =
                     {(size_t) segmap_usable_groups_18622 *
                     (size_t) segmap_group_sizze_18621};
        const size_t local_work_sizze_20924[1] =
                     {(size_t) segmap_group_sizze_18621};
        int64_t time_start_20921 = 0, time_end_20922 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "vectorAbs.segmap_18613", global_work_sizze_20920[0],
                    local_work_sizze_20924[0], (int) 0);
            time_start_20921 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->vectorAbszisegmap_18613,
                                                        1, NULL,
                                                        global_work_sizze_20920,
                                                        local_work_sizze_20924,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->vectorAbszisegmap_18613_runs,
                                                                                                  &ctx->vectorAbszisegmap_18613_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20922 = get_wall_time();
            
            long time_diff_20923 = time_end_20922 - time_start_20921;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "vectorAbs.segmap_18613", time_diff_20923);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20279, "mem_20279") != 0)
        return 1;
    (*mem_out_p_20919).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20919, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorAdd(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20925,
                                  struct memblock_device a_mem_20275,
                                  struct memblock_device b_mem_20276,
                                  int64_t i_18332)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segmap_group_sizze_18650;
    
    segmap_group_sizze_18650 =
        *ctx->tuning_params.vectorAddzisegmap_group_sizze_18643;
    
    int64_t segmap_usable_groups_18651 = sdiv_up64(i_18332,
                                                   segmap_group_sizze_18650);
    int64_t binop_y_20278 = (int64_t) 4 * i_18332;
    int64_t bytes_20279 = smax64((int64_t) 0, binop_y_20278);
    struct memblock_device mem_20280;
    
    mem_20280.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20280, bytes_20279, "mem_20280")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAddzisegmap_18641, 1,
                                            sizeof(i_18332), &i_18332));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAddzisegmap_18641, 2,
                                            sizeof(a_mem_20275.mem),
                                            &a_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAddzisegmap_18641, 3,
                                            sizeof(b_mem_20276.mem),
                                            &b_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorAddzisegmap_18641, 4,
                                            sizeof(mem_20280.mem),
                                            &mem_20280.mem));
    if (1 * ((size_t) segmap_usable_groups_18651 *
             (size_t) segmap_group_sizze_18650) != 0) {
        const size_t global_work_sizze_20926[1] =
                     {(size_t) segmap_usable_groups_18651 *
                     (size_t) segmap_group_sizze_18650};
        const size_t local_work_sizze_20930[1] =
                     {(size_t) segmap_group_sizze_18650};
        int64_t time_start_20927 = 0, time_end_20928 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "vectorAdd.segmap_18641", global_work_sizze_20926[0],
                    local_work_sizze_20930[0], (int) 0);
            time_start_20927 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->vectorAddzisegmap_18641,
                                                        1, NULL,
                                                        global_work_sizze_20926,
                                                        local_work_sizze_20930,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->vectorAddzisegmap_18641_runs,
                                                                                                  &ctx->vectorAddzisegmap_18641_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20928 = get_wall_time();
            
            long time_diff_20929 = time_end_20928 - time_start_20927;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "vectorAdd.segmap_18641", time_diff_20929);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20280, "mem_20280") != 0)
        return 1;
    (*mem_out_p_20925).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20925, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20280, "mem_20280") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorMatrixMul(struct futhark_context *ctx,
                                        struct memblock_device *mem_out_p_20931,
                                        struct memblock_device v_mem_20275,
                                        struct memblock_device M_mem_20276,
                                        int64_t i_18430, int64_t j_18431)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    bool suff_outer_par_18993;
    
    suff_outer_par_18993 =
        *ctx->tuning_params.vectorMatrixMulzisuff_outer_par_0 <= j_18431;
    if (ctx->logging)
        fprintf(ctx->log, "Compared %s <= %ld: %s.\n",
                "vectorMatrixMul.suff_outer_par_0", (long) j_18431,
                suff_outer_par_18993 ? "true" : "false");
    
    int64_t segmap_group_sizze_19009;
    
    segmap_group_sizze_19009 =
        *ctx->tuning_params.vectorMatrixMulzisegmap_group_sizze_18997;
    
    int64_t nest_sizze_19038 = i_18430 * j_18431;
    int64_t segred_group_sizze_19039;
    
    segred_group_sizze_19039 =
        *ctx->tuning_params.vectorMatrixMulzisegred_group_sizze_19023;
    
    int64_t num_groups_19040;
    int32_t max_num_groups_20595;
    
    max_num_groups_20595 =
        *ctx->tuning_params.vectorMatrixMulzisegred_num_groups_19025;
    num_groups_19040 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(nest_sizze_19038,
                                                            segred_group_sizze_19039),
                                                  sext_i32_i64(max_num_groups_20595))));
    
    int64_t binop_y_20298 = (int64_t) 4 * j_18431;
    int64_t bytes_20299 = smax64((int64_t) 0, binop_y_20298);
    int64_t bytes_20279 = (int64_t) 4 * segmap_group_sizze_19009;
    int64_t bytes_20284 = smax64((int64_t) 0, bytes_20279);
    int64_t bytes_20302 = (int64_t) 4 * nest_sizze_19038;
    int64_t num_bytes_20529 = (int64_t) 4 * segmap_group_sizze_19009;
    struct memblock_device ext_mem_20308;
    
    ext_mem_20308.references = NULL;
    
    int32_t local_memory_capacity_20675;
    
    local_memory_capacity_20675 = ctx->opencl.max_local_memory;
    if (sle64(bytes_20284 + srem64((int64_t) 8 - srem64(bytes_20284,
                                                        (int64_t) 8),
                                   (int64_t) 8),
              sext_i32_i64(local_memory_capacity_20675)) &&
        suff_outer_par_18993) {
        int64_t segmap_usable_groups_19010 = sdiv_up64(j_18431,
                                                       segmap_group_sizze_19009);
        int64_t num_whole_tiles_19815 = squot64(i_18430,
                                                segmap_group_sizze_19009);
        int64_t residual_input_19901 = srem64(i_18430,
                                              segmap_group_sizze_19009);
        bool cond_19902 = residual_input_19901 == (int64_t) 0;
        struct memblock_device mem_20300;
        
        mem_20300.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20300, bytes_20299, "mem_20300")) {
            err = 1;
            goto cleanup;
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "\n# SegMap");
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                1, (size_t) bytes_20284, NULL));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                2, sizeof(i_18430), &i_18430));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                3, sizeof(j_18431), &j_18431));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                4,
                                                sizeof(segmap_usable_groups_19010),
                                                &segmap_usable_groups_19010));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                5,
                                                sizeof(num_whole_tiles_19815),
                                                &num_whole_tiles_19815));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                6, sizeof(residual_input_19901),
                                                &residual_input_19901));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                7, sizeof(cond_19902),
                                                &cond_19902));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                8, sizeof(v_mem_20275.mem),
                                                &v_mem_20275.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                9, sizeof(M_mem_20276.mem),
                                                &M_mem_20276.mem));
        OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                10, sizeof(mem_20300.mem),
                                                &mem_20300.mem));
        if (1 * ((size_t) segmap_usable_groups_19010 *
                 (size_t) segmap_group_sizze_19009) != 0) {
            const size_t global_work_sizze_20932[1] =
                         {(size_t) segmap_usable_groups_19010 *
                         (size_t) segmap_group_sizze_19009};
            const size_t local_work_sizze_20936[1] =
                         {(size_t) segmap_group_sizze_19009};
            int64_t time_start_20933 = 0, time_end_20934 = 0;
            
            if (ctx->debugging) {
                fprintf(ctx->log,
                        "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                        "vectorMatrixMul.segmap_intragroup_19807",
                        global_work_sizze_20932[0], local_work_sizze_20936[0],
                        (int) (0 + bytes_20284));
                time_start_20933 = get_wall_time();
            }
            OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                            ctx->vectorMatrixMulzisegmap_intragroup_19807,
                                                            1, NULL,
                                                            global_work_sizze_20932,
                                                            local_work_sizze_20936,
                                                            0, NULL,
                                                            ctx->profiling_paused ||
                                                            !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                      &ctx->vectorMatrixMulzisegmap_intragroup_19807_runs,
                                                                                                      &ctx->vectorMatrixMulzisegmap_intragroup_19807_total_runtime)));
            if (ctx->debugging) {
                OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                time_end_20934 = get_wall_time();
                
                long time_diff_20935 = time_end_20934 - time_start_20933;
                
                fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                        "vectorMatrixMul.segmap_intragroup_19807",
                        time_diff_20935);
            }
        }
        if (ctx->debugging)
            fprintf(ctx->log, "%s\n", "");
        if (memblock_set_device(ctx, &ext_mem_20308, &mem_20300, "mem_20300") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20300, "mem_20300") != 0)
            return 1;
    } else {
        struct memblock_device mem_20303;
        
        mem_20303.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20303, bytes_20302, "mem_20303")) {
            err = 1;
            goto cleanup;
        }
        if (futrts_builtinzhgpu_map_transpose_f32(ctx, mem_20303, (int64_t) 0,
                                                  M_mem_20276, (int64_t) 0,
                                                  (int64_t) 1, j_18431,
                                                  i_18430) != 0) {
            err = 1;
            goto cleanup;
        }
        
        struct memblock_device mem_20307;
        
        mem_20307.references = NULL;
        if (memblock_alloc_device(ctx, &mem_20307, bytes_20299, "mem_20307")) {
            err = 1;
            goto cleanup;
        }
        if (slt64(i_18430 * (int64_t) 2, segred_group_sizze_19039)) {
            int64_t segment_sizze_nonzzero_20611 = smax64((int64_t) 1, i_18430);
            int64_t num_threads_20612 = num_groups_19040 *
                    segred_group_sizze_19039;
            
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegRed-small");
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "num_segments",
                        (long long) j_18431, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "segment_size",
                        (long long) i_18430, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "segments_per_group",
                        (long long) squot64(segred_group_sizze_19039,
                                            segment_sizze_nonzzero_20611),
                        '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "required_groups",
                        (long long) sext_i64_i32(sdiv_up64(j_18431,
                                                           squot64(segred_group_sizze_19039,
                                                                   segment_sizze_nonzzero_20611))),
                        '\n');
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    1, (size_t) ((int64_t) 4 *
                                                                 segred_group_sizze_19039),
                                                    NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    2, sizeof(i_18430),
                                                    &i_18430));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    3, sizeof(j_18431),
                                                    &j_18431));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    4, sizeof(num_groups_19040),
                                                    &num_groups_19040));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    5,
                                                    sizeof(segment_sizze_nonzzero_20611),
                                                    &segment_sizze_nonzzero_20611));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    6, sizeof(v_mem_20275.mem),
                                                    &v_mem_20275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    7, sizeof(mem_20303.mem),
                                                    &mem_20303.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_small_19029,
                                                    8, sizeof(mem_20307.mem),
                                                    &mem_20307.mem));
            if (1 * ((size_t) num_groups_19040 *
                     (size_t) segred_group_sizze_19039) != 0) {
                const size_t global_work_sizze_20937[1] =
                             {(size_t) num_groups_19040 *
                             (size_t) segred_group_sizze_19039};
                const size_t local_work_sizze_20941[1] =
                             {(size_t) segred_group_sizze_19039};
                int64_t time_start_20938 = 0, time_end_20939 = 0;
                
                if (ctx->debugging) {
                    fprintf(ctx->log,
                            "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                            "vectorMatrixMul.segred_small_19029",
                            global_work_sizze_20937[0],
                            local_work_sizze_20941[0], (int) (0 + (int64_t) 4 *
                                                              segred_group_sizze_19039));
                    time_start_20938 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->vectorMatrixMulzisegred_small_19029,
                                                                1, NULL,
                                                                global_work_sizze_20937,
                                                                local_work_sizze_20941,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->vectorMatrixMulzisegred_small_19029_runs,
                                                                                                          &ctx->vectorMatrixMulzisegred_small_19029_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_20939 = get_wall_time();
                    
                    long time_diff_20940 = time_end_20939 - time_start_20938;
                    
                    fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                            "vectorMatrixMul.segred_small_19029",
                            time_diff_20940);
                }
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
        } else {
            int64_t groups_per_segment_20634 = sdiv_up64(num_groups_19040,
                                                         smax64((int64_t) 1,
                                                                j_18431));
            int64_t elements_per_thread_20635 = sdiv_up64(i_18430,
                                                          segred_group_sizze_19039 *
                                                          groups_per_segment_20634);
            int64_t virt_num_groups_20636 = groups_per_segment_20634 * j_18431;
            int64_t num_threads_20637 = num_groups_19040 *
                    segred_group_sizze_19039;
            int64_t threads_per_segment_20638 = groups_per_segment_20634 *
                    segred_group_sizze_19039;
            
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "\n# SegRed-large");
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "num_segments",
                        (long long) j_18431, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "segment_size",
                        (long long) i_18430, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "virt_num_groups",
                        (long long) virt_num_groups_20636, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "num_groups",
                        (long long) num_groups_19040, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "group_size",
                        (long long) segred_group_sizze_19039, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "elems_per_thread",
                        (long long) elements_per_thread_20635, '\n');
            if (ctx->debugging)
                fprintf(ctx->log, "%s: %llu%c", "groups_per_segment",
                        (long long) groups_per_segment_20634, '\n');
            
            struct memblock_device segred_tmp_mem_20639;
            
            segred_tmp_mem_20639.references = NULL;
            if (memblock_alloc_device(ctx, &segred_tmp_mem_20639, (int64_t) 4 *
                                      virt_num_groups_20636,
                                      "segred_tmp_mem_20639")) {
                err = 1;
                goto cleanup;
            }
            
            struct memblock_device vectorMatrixMulzicounter_mem_20641 =
                                   ctx->vectorMatrixMulzicounter_mem_20641;
            
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    1, (size_t) 1, NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    2, (size_t) ((int64_t) 4 *
                                                                 segred_group_sizze_19039),
                                                    NULL));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    3, sizeof(i_18430),
                                                    &i_18430));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    4, sizeof(j_18431),
                                                    &j_18431));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    5, sizeof(num_groups_19040),
                                                    &num_groups_19040));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    6,
                                                    sizeof(groups_per_segment_20634),
                                                    &groups_per_segment_20634));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    7,
                                                    sizeof(elements_per_thread_20635),
                                                    &elements_per_thread_20635));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    8,
                                                    sizeof(virt_num_groups_20636),
                                                    &virt_num_groups_20636));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    9,
                                                    sizeof(threads_per_segment_20638),
                                                    &threads_per_segment_20638));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    10, sizeof(v_mem_20275.mem),
                                                    &v_mem_20275.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    11, sizeof(mem_20303.mem),
                                                    &mem_20303.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    12, sizeof(mem_20307.mem),
                                                    &mem_20307.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    13,
                                                    sizeof(segred_tmp_mem_20639.mem),
                                                    &segred_tmp_mem_20639.mem));
            OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMatrixMulzisegred_large_19029,
                                                    14,
                                                    sizeof(vectorMatrixMulzicounter_mem_20641.mem),
                                                    &vectorMatrixMulzicounter_mem_20641.mem));
            if (1 * ((size_t) num_groups_19040 *
                     (size_t) segred_group_sizze_19039) != 0) {
                const size_t global_work_sizze_20943[1] =
                             {(size_t) num_groups_19040 *
                             (size_t) segred_group_sizze_19039};
                const size_t local_work_sizze_20947[1] =
                             {(size_t) segred_group_sizze_19039};
                int64_t time_start_20944 = 0, time_end_20945 = 0;
                
                if (ctx->debugging) {
                    fprintf(ctx->log,
                            "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                            "vectorMatrixMul.segred_large_19029",
                            global_work_sizze_20943[0],
                            local_work_sizze_20947[0], (int) (0 + 1 +
                                                              (int64_t) 4 *
                                                              segred_group_sizze_19039));
                    time_start_20944 = get_wall_time();
                }
                OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                                ctx->vectorMatrixMulzisegred_large_19029,
                                                                1, NULL,
                                                                global_work_sizze_20943,
                                                                local_work_sizze_20947,
                                                                0, NULL,
                                                                ctx->profiling_paused ||
                                                                !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                          &ctx->vectorMatrixMulzisegred_large_19029_runs,
                                                                                                          &ctx->vectorMatrixMulzisegred_large_19029_total_runtime)));
                if (ctx->debugging) {
                    OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
                    time_end_20945 = get_wall_time();
                    
                    long time_diff_20946 = time_end_20945 - time_start_20944;
                    
                    fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                            "vectorMatrixMul.segred_large_19029",
                            time_diff_20946);
                }
            }
            if (ctx->debugging)
                fprintf(ctx->log, "%s\n", "");
            if (memblock_unref_device(ctx, &segred_tmp_mem_20639,
                                      "segred_tmp_mem_20639") != 0)
                return 1;
        }
        if (memblock_unref_device(ctx, &mem_20303, "mem_20303") != 0)
            return 1;
        if (memblock_set_device(ctx, &ext_mem_20308, &mem_20307, "mem_20307") !=
            0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20307, "mem_20307") != 0)
            return 1;
        if (memblock_unref_device(ctx, &mem_20303, "mem_20303") != 0)
            return 1;
    }
    if (memblock_set_device(ctx, &mem_out_20594, &ext_mem_20308,
                            "ext_mem_20308") != 0)
        return 1;
    (*mem_out_p_20931).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20931, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &ext_mem_20308, "ext_mem_20308") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorMul(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20948,
                                  struct memblock_device a_mem_20275,
                                  struct memblock_device b_mem_20276,
                                  int64_t i_18404)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segmap_group_sizze_18913;
    
    segmap_group_sizze_18913 =
        *ctx->tuning_params.vectorMulzisegmap_group_sizze_18906;
    
    int64_t segmap_usable_groups_18914 = sdiv_up64(i_18404,
                                                   segmap_group_sizze_18913);
    int64_t binop_y_20278 = (int64_t) 4 * i_18404;
    int64_t bytes_20279 = smax64((int64_t) 0, binop_y_20278);
    struct memblock_device mem_20280;
    
    mem_20280.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20280, bytes_20279, "mem_20280")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMulzisegmap_18904, 1,
                                            sizeof(i_18404), &i_18404));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMulzisegmap_18904, 2,
                                            sizeof(a_mem_20275.mem),
                                            &a_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMulzisegmap_18904, 3,
                                            sizeof(b_mem_20276.mem),
                                            &b_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorMulzisegmap_18904, 4,
                                            sizeof(mem_20280.mem),
                                            &mem_20280.mem));
    if (1 * ((size_t) segmap_usable_groups_18914 *
             (size_t) segmap_group_sizze_18913) != 0) {
        const size_t global_work_sizze_20949[1] =
                     {(size_t) segmap_usable_groups_18914 *
                     (size_t) segmap_group_sizze_18913};
        const size_t local_work_sizze_20953[1] =
                     {(size_t) segmap_group_sizze_18913};
        int64_t time_start_20950 = 0, time_end_20951 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "vectorMul.segmap_18904", global_work_sizze_20949[0],
                    local_work_sizze_20953[0], (int) 0);
            time_start_20950 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->vectorMulzisegmap_18904,
                                                        1, NULL,
                                                        global_work_sizze_20949,
                                                        local_work_sizze_20953,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->vectorMulzisegmap_18904_runs,
                                                                                                  &ctx->vectorMulzisegmap_18904_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20951 = get_wall_time();
            
            long time_diff_20952 = time_end_20951 - time_start_20950;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "vectorMul.segmap_18904", time_diff_20952);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20280, "mem_20280") != 0)
        return 1;
    (*mem_out_p_20948).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20948, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20280, "mem_20280") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorNorm(struct futhark_context *ctx,
                                   float *out_prim_out_20954,
                                   struct memblock_device v_mem_20275,
                                   int64_t iz2083U_18590)
{
    (void) ctx;
    
    int err = 0;
    float prim_out_20594;
    int64_t segred_group_sizze_19642;
    
    segred_group_sizze_19642 =
        *ctx->tuning_params.vectorNormzisegred_group_sizze_19641;
    
    int64_t num_groups_19644;
    int32_t max_num_groups_20595;
    
    max_num_groups_20595 =
        *ctx->tuning_params.vectorNormzisegred_num_groups_19643;
    num_groups_19644 = sext_i64_i32(smax64((int64_t) 1,
                                           smin64(sdiv_up64(iz2083U_18590,
                                                            segred_group_sizze_19642),
                                                  sext_i32_i64(max_num_groups_20595))));
    
    struct memblock_device mem_20278;
    
    mem_20278.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20278, (int64_t) 4, "mem_20278")) {
        err = 1;
        goto cleanup;
    }
    
    struct memblock_device vectorNormzicounter_mem_20596 =
                           ctx->vectorNormzicounter_mem_20596;
    struct memblock_device segred_tmp_mem_20598;
    
    segred_tmp_mem_20598.references = NULL;
    if (memblock_alloc_device(ctx, &segred_tmp_mem_20598, (int64_t) 4 *
                              num_groups_19644, "segred_tmp_mem_20598")) {
        err = 1;
        goto cleanup;
    }
    
    int64_t num_threads_20600 = num_groups_19644 * segred_group_sizze_19642;
    
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegRed");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            1, (size_t) ((int64_t) 4 *
                                                         segred_group_sizze_19642),
                                            NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            2, (size_t) 1, NULL));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            3, sizeof(iz2083U_18590),
                                            &iz2083U_18590));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            4, sizeof(num_groups_19644),
                                            &num_groups_19644));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            5, sizeof(num_threads_20600),
                                            &num_threads_20600));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            6, sizeof(v_mem_20275.mem),
                                            &v_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            7, sizeof(mem_20278.mem),
                                            &mem_20278.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            8,
                                            sizeof(vectorNormzicounter_mem_20596.mem),
                                            &vectorNormzicounter_mem_20596.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorNormzisegred_nonseg_19649,
                                            9, sizeof(segred_tmp_mem_20598.mem),
                                            &segred_tmp_mem_20598.mem));
    if (1 * ((size_t) num_groups_19644 * (size_t) segred_group_sizze_19642) !=
        0) {
        const size_t global_work_sizze_20956[1] = {(size_t) num_groups_19644 *
                     (size_t) segred_group_sizze_19642};
        const size_t local_work_sizze_20960[1] =
                     {(size_t) segred_group_sizze_19642};
        int64_t time_start_20957 = 0, time_end_20958 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "vectorNorm.segred_nonseg_19649",
                    global_work_sizze_20956[0], local_work_sizze_20960[0],
                    (int) (0 + (int64_t) 4 * segred_group_sizze_19642 + 1));
            time_start_20957 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->vectorNormzisegred_nonseg_19649,
                                                        1, NULL,
                                                        global_work_sizze_20956,
                                                        local_work_sizze_20960,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->vectorNormzisegred_nonseg_19649_runs,
                                                                                                  &ctx->vectorNormzisegred_nonseg_19649_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20958 = get_wall_time();
            
            long time_diff_20959 = time_end_20958 - time_start_20957;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "vectorNorm.segred_nonseg_19649", time_diff_20959);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    
    float read_res_20961;
    
    OPENCL_SUCCEED_OR_RETURN(clEnqueueReadBuffer(ctx->opencl.queue,
                                                 mem_20278.mem,
                                                 ctx->failure_is_an_option ? CL_FALSE : CL_TRUE,
                                                 (int64_t) 0 * sizeof(float),
                                                 sizeof(float), &read_res_20961,
                                                 0, NULL,
                                                 ctx->profiling_paused ||
                                                 !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                           &ctx->copy_scalar_from_dev_runs,
                                                                                           &ctx->copy_scalar_from_dev_total_runtime)));
    if (ctx->failure_is_an_option && futhark_context_sync(ctx) != 0)
        return 1;
    
    float defunc_0_f_res_18592 = read_res_20961;
    
    if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
        return 1;
    
    float defunc_0_f_res_18598;
    
    defunc_0_f_res_18598 = futrts_sqrt32(defunc_0_f_res_18592);
    prim_out_20594 = defunc_0_f_res_18598;
    *out_prim_out_20954 = prim_out_20594;
    if (memblock_unref_device(ctx, &segred_tmp_mem_20598,
                              "segred_tmp_mem_20598") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20278, "mem_20278") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorSgn(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20962,
                                  struct memblock_device as_mem_20275,
                                  int64_t nz2081U_18327)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segmap_group_sizze_18635;
    
    segmap_group_sizze_18635 =
        *ctx->tuning_params.vectorSgnzisegmap_group_sizze_18629;
    
    int64_t segmap_usable_groups_18636 = sdiv_up64(nz2081U_18327,
                                                   segmap_group_sizze_18635);
    int64_t binop_y_20277 = (int64_t) 4 * nz2081U_18327;
    int64_t bytes_20278 = smax64((int64_t) 0, binop_y_20277);
    struct memblock_device mem_20279;
    
    mem_20279.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20279, bytes_20278, "mem_20279")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSgnzisegmap_18627, 1,
                                            sizeof(nz2081U_18327),
                                            &nz2081U_18327));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSgnzisegmap_18627, 2,
                                            sizeof(as_mem_20275.mem),
                                            &as_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSgnzisegmap_18627, 3,
                                            sizeof(mem_20279.mem),
                                            &mem_20279.mem));
    if (1 * ((size_t) segmap_usable_groups_18636 *
             (size_t) segmap_group_sizze_18635) != 0) {
        const size_t global_work_sizze_20963[1] =
                     {(size_t) segmap_usable_groups_18636 *
                     (size_t) segmap_group_sizze_18635};
        const size_t local_work_sizze_20967[1] =
                     {(size_t) segmap_group_sizze_18635};
        int64_t time_start_20964 = 0, time_end_20965 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "vectorSgn.segmap_18627", global_work_sizze_20963[0],
                    local_work_sizze_20967[0], (int) 0);
            time_start_20964 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->vectorSgnzisegmap_18627,
                                                        1, NULL,
                                                        global_work_sizze_20963,
                                                        local_work_sizze_20967,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->vectorSgnzisegmap_18627_runs,
                                                                                                  &ctx->vectorSgnzisegmap_18627_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20965 = get_wall_time();
            
            long time_diff_20966 = time_end_20965 - time_start_20964;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "vectorSgn.segmap_18627", time_diff_20966);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20279, "mem_20279") != 0)
        return 1;
    (*mem_out_p_20962).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20962, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20279, "mem_20279") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}
static int futrts_entry_vectorSub(struct futhark_context *ctx,
                                  struct memblock_device *mem_out_p_20968,
                                  struct memblock_device a_mem_20275,
                                  struct memblock_device b_mem_20276,
                                  int64_t i_18339)
{
    (void) ctx;
    
    int err = 0;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int64_t segmap_group_sizze_18666;
    
    segmap_group_sizze_18666 =
        *ctx->tuning_params.vectorSubzisegmap_group_sizze_18659;
    
    int64_t segmap_usable_groups_18667 = sdiv_up64(i_18339,
                                                   segmap_group_sizze_18666);
    int64_t binop_y_20278 = (int64_t) 4 * i_18339;
    int64_t bytes_20279 = smax64((int64_t) 0, binop_y_20278);
    struct memblock_device mem_20280;
    
    mem_20280.references = NULL;
    if (memblock_alloc_device(ctx, &mem_20280, bytes_20279, "mem_20280")) {
        err = 1;
        goto cleanup;
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "\n# SegMap");
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSubzisegmap_18657, 1,
                                            sizeof(i_18339), &i_18339));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSubzisegmap_18657, 2,
                                            sizeof(a_mem_20275.mem),
                                            &a_mem_20275.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSubzisegmap_18657, 3,
                                            sizeof(b_mem_20276.mem),
                                            &b_mem_20276.mem));
    OPENCL_SUCCEED_OR_RETURN(clSetKernelArg(ctx->vectorSubzisegmap_18657, 4,
                                            sizeof(mem_20280.mem),
                                            &mem_20280.mem));
    if (1 * ((size_t) segmap_usable_groups_18667 *
             (size_t) segmap_group_sizze_18666) != 0) {
        const size_t global_work_sizze_20969[1] =
                     {(size_t) segmap_usable_groups_18667 *
                     (size_t) segmap_group_sizze_18666};
        const size_t local_work_sizze_20973[1] =
                     {(size_t) segmap_group_sizze_18666};
        int64_t time_start_20970 = 0, time_end_20971 = 0;
        
        if (ctx->debugging) {
            fprintf(ctx->log,
                    "Launching %s with global work size [%zu] and local work size [%zu]; local memory: %d bytes.\n",
                    "vectorSub.segmap_18657", global_work_sizze_20969[0],
                    local_work_sizze_20973[0], (int) 0);
            time_start_20970 = get_wall_time();
        }
        OPENCL_SUCCEED_OR_RETURN(clEnqueueNDRangeKernel(ctx->opencl.queue,
                                                        ctx->vectorSubzisegmap_18657,
                                                        1, NULL,
                                                        global_work_sizze_20969,
                                                        local_work_sizze_20973,
                                                        0, NULL,
                                                        ctx->profiling_paused ||
                                                        !ctx->profiling ? NULL : opencl_get_event(&ctx->opencl,
                                                                                                  &ctx->vectorSubzisegmap_18657_runs,
                                                                                                  &ctx->vectorSubzisegmap_18657_total_runtime)));
        if (ctx->debugging) {
            OPENCL_SUCCEED_FATAL(clFinish(ctx->opencl.queue));
            time_end_20971 = get_wall_time();
            
            long time_diff_20972 = time_end_20971 - time_start_20970;
            
            fprintf(ctx->log, "kernel %s runtime: %ldus\n",
                    "vectorSub.segmap_18657", time_diff_20972);
        }
    }
    if (ctx->debugging)
        fprintf(ctx->log, "%s\n", "");
    if (memblock_set_device(ctx, &mem_out_20594, &mem_20280, "mem_20280") != 0)
        return 1;
    (*mem_out_p_20968).references = NULL;
    if (memblock_set_device(ctx, &*mem_out_p_20968, &mem_out_20594,
                            "mem_out_20594") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_20280, "mem_20280") != 0)
        return 1;
    if (memblock_unref_device(ctx, &mem_out_20594, "mem_out_20594") != 0)
        return 1;
    
  cleanup:
    { }
    return err;
}

int futhark_entry_dot(struct futhark_context *ctx, float *out0, const
                      struct futhark_f32_1d *in0, const
                      struct futhark_f32_1d *in1)
{
    struct memblock_device a_mem_20275;
    
    a_mem_20275.references = NULL;
    
    struct memblock_device b_mem_20276;
    
    b_mem_20276.references = NULL;
    
    int64_t i_18461;
    float prim_out_20594;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    a_mem_20275 = in0->mem;
    i_18461 = in0->shape[0];
    b_mem_20276 = in1->mem;
    i_18461 = in1->shape[0];
    if (!(i_18461 == in0->shape[0] && i_18461 == in1->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_dot(ctx, &prim_out_20594, a_mem_20275, b_mem_20276,
                               i_18461);
        if (ret == 0) {
            *out0 = prim_out_20594;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_main(struct futhark_context *ctx, struct futhark_u8_3d **out0,
                       const int64_t in0)
{
    int64_t lenX_18471;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    lenX_18471 = in0;
    if (ret == 0) {
        ret = futrts_entry_main(ctx, &mem_out_20594, lenX_18471);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_u8_3d *) malloc(sizeof(struct futhark_u8_3d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = lenX_18471;
            (*out0)->shape[1] = lenX_18471;
            (*out0)->shape[2] = (int64_t) 3;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixAbs(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0)
{
    struct memblock_device as_mem_20275;
    
    as_mem_20275.references = NULL;
    
    int64_t nz2080U_18346;
    int64_t nz2082U_18347;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    as_mem_20275 = in0->mem;
    nz2082U_18347 = in0->shape[0];
    nz2080U_18346 = in0->shape[1];
    if (!(nz2082U_18347 == in0->shape[0] && nz2080U_18346 == in0->shape[1])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixAbs(ctx, &mem_out_20594, as_mem_20275,
                                     nz2080U_18346, nz2082U_18347);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = nz2082U_18347;
            (*out0)->shape[1] = nz2080U_18346;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixAdd(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0, const
                            struct futhark_f32_2d *in1)
{
    struct memblock_device A_mem_20275;
    
    A_mem_20275.references = NULL;
    
    struct memblock_device B_mem_20276;
    
    B_mem_20276.references = NULL;
    
    int64_t i_18371;
    int64_t j_18372;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    A_mem_20275 = in0->mem;
    i_18371 = in0->shape[0];
    j_18372 = in0->shape[1];
    B_mem_20276 = in1->mem;
    i_18371 = in1->shape[0];
    j_18372 = in1->shape[1];
    if (!((i_18371 == in0->shape[0] && j_18372 == in0->shape[1]) && (i_18371 ==
                                                                     in1->shape[0] &&
                                                                     j_18372 ==
                                                                     in1->shape[1]))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixAdd(ctx, &mem_out_20594, A_mem_20275,
                                     B_mem_20276, i_18371, j_18372);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18371;
            (*out0)->shape[1] = j_18372;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixMatrixMul(struct futhark_context *ctx,
                                  struct futhark_f32_2d **out0, const
                                  struct futhark_f32_2d *in0, const
                                  struct futhark_f32_2d *in1)
{
    struct memblock_device A_mem_20275;
    
    A_mem_20275.references = NULL;
    
    struct memblock_device B_mem_20276;
    
    B_mem_20276.references = NULL;
    
    int64_t i_18444;
    int64_t j_18445;
    int64_t k_18446;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    A_mem_20275 = in0->mem;
    i_18444 = in0->shape[0];
    j_18445 = in0->shape[1];
    B_mem_20276 = in1->mem;
    j_18445 = in1->shape[0];
    k_18446 = in1->shape[1];
    if (!((i_18444 == in0->shape[0] && j_18445 == in0->shape[1]) && (j_18445 ==
                                                                     in1->shape[0] &&
                                                                     k_18446 ==
                                                                     in1->shape[1]))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixMatrixMul(ctx, &mem_out_20594, A_mem_20275,
                                           B_mem_20276, i_18444, j_18445,
                                           k_18446);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18444;
            (*out0)->shape[1] = k_18446;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixMul(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0, const
                            struct futhark_f32_2d *in1)
{
    struct memblock_device A_mem_20275;
    
    A_mem_20275.references = NULL;
    
    struct memblock_device B_mem_20276;
    
    B_mem_20276.references = NULL;
    
    int64_t i_18393;
    int64_t j_18394;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    A_mem_20275 = in0->mem;
    i_18393 = in0->shape[0];
    j_18394 = in0->shape[1];
    B_mem_20276 = in1->mem;
    i_18393 = in1->shape[0];
    j_18394 = in1->shape[1];
    if (!((i_18393 == in0->shape[0] && j_18394 == in0->shape[1]) && (i_18393 ==
                                                                     in1->shape[0] &&
                                                                     j_18394 ==
                                                                     in1->shape[1]))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixMul(ctx, &mem_out_20594, A_mem_20275,
                                     B_mem_20276, i_18393, j_18394);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18393;
            (*out0)->shape[1] = j_18394;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixSgn(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0)
{
    struct memblock_device as_mem_20275;
    
    as_mem_20275.references = NULL;
    
    int64_t nz2080U_18354;
    int64_t nz2082U_18355;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    as_mem_20275 = in0->mem;
    nz2082U_18355 = in0->shape[0];
    nz2080U_18354 = in0->shape[1];
    if (!(nz2082U_18355 == in0->shape[0] && nz2080U_18354 == in0->shape[1])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixSgn(ctx, &mem_out_20594, as_mem_20275,
                                     nz2080U_18354, nz2082U_18355);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = nz2082U_18355;
            (*out0)->shape[1] = nz2080U_18354;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixSub(struct futhark_context *ctx,
                            struct futhark_f32_2d **out0, const
                            struct futhark_f32_2d *in0, const
                            struct futhark_f32_2d *in1)
{
    struct memblock_device A_mem_20275;
    
    A_mem_20275.references = NULL;
    
    struct memblock_device B_mem_20276;
    
    B_mem_20276.references = NULL;
    
    int64_t i_18382;
    int64_t j_18383;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    A_mem_20275 = in0->mem;
    i_18382 = in0->shape[0];
    j_18383 = in0->shape[1];
    B_mem_20276 = in1->mem;
    i_18382 = in1->shape[0];
    j_18383 = in1->shape[1];
    if (!((i_18382 == in0->shape[0] && j_18383 == in0->shape[1]) && (i_18382 ==
                                                                     in1->shape[0] &&
                                                                     j_18383 ==
                                                                     in1->shape[1]))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixSub(ctx, &mem_out_20594, A_mem_20275,
                                     B_mem_20276, i_18382, j_18383);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18382;
            (*out0)->shape[1] = j_18383;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_matrixVectorMul(struct futhark_context *ctx,
                                  struct futhark_f32_1d **out0, const
                                  struct futhark_f32_2d *in0, const
                                  struct futhark_f32_1d *in1)
{
    struct memblock_device M_mem_20275;
    
    M_mem_20275.references = NULL;
    
    struct memblock_device v_mem_20276;
    
    v_mem_20276.references = NULL;
    
    int64_t i_18417;
    int64_t j_18418;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    M_mem_20275 = in0->mem;
    i_18417 = in0->shape[0];
    j_18418 = in0->shape[1];
    v_mem_20276 = in1->mem;
    j_18418 = in1->shape[0];
    if (!((i_18417 == in0->shape[0] && j_18418 == in0->shape[1]) && j_18418 ==
          in1->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_matrixVectorMul(ctx, &mem_out_20594, M_mem_20275,
                                           v_mem_20276, i_18417, j_18418);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18417;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_normalizeV(struct futhark_context *ctx,
                             struct futhark_f32_1d **out0, const
                             struct futhark_f32_1d *in0)
{
    struct memblock_device v_mem_20275;
    
    v_mem_20275.references = NULL;
    
    int64_t iz2083U_18599;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    v_mem_20275 = in0->mem;
    iz2083U_18599 = in0->shape[0];
    if (!(iz2083U_18599 == in0->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_normalizzeV(ctx, &mem_out_20594, v_mem_20275,
                                       iz2083U_18599);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = iz2083U_18599;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_scaleM(struct futhark_context *ctx,
                         struct futhark_f32_2d **out0, const float in0, const
                         struct futhark_f32_2d *in1)
{
    struct memblock_device as_mem_20275;
    
    as_mem_20275.references = NULL;
    
    int64_t nz2081U_18362;
    int64_t nz2083U_18363;
    float f_18364;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    f_18364 = in0;
    as_mem_20275 = in1->mem;
    nz2083U_18363 = in1->shape[0];
    nz2081U_18362 = in1->shape[1];
    if (!(nz2083U_18363 == in1->shape[0] && nz2081U_18362 == in1->shape[1])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_scaleM(ctx, &mem_out_20594, as_mem_20275,
                                  nz2081U_18362, nz2083U_18363, f_18364);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_2d *) malloc(sizeof(struct futhark_f32_2d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = nz2083U_18363;
            (*out0)->shape[1] = nz2081U_18362;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_scaleV(struct futhark_context *ctx,
                         struct futhark_f32_1d **out0, const float in0, const
                         struct futhark_f32_1d *in1)
{
    struct memblock_device as_mem_20275;
    
    as_mem_20275.references = NULL;
    
    int64_t nz2082U_18411;
    float f_18412;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    f_18412 = in0;
    as_mem_20275 = in1->mem;
    nz2082U_18411 = in1->shape[0];
    if (!(nz2082U_18411 == in1->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_scaleV(ctx, &mem_out_20594, as_mem_20275,
                                  nz2082U_18411, f_18412);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = nz2082U_18411;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorAbs(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0)
{
    struct memblock_device as_mem_20275;
    
    as_mem_20275.references = NULL;
    
    int64_t nz2081U_18322;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    as_mem_20275 = in0->mem;
    nz2081U_18322 = in0->shape[0];
    if (!(nz2081U_18322 == in0->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorAbs(ctx, &mem_out_20594, as_mem_20275,
                                     nz2081U_18322);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = nz2081U_18322;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorAdd(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0, const
                            struct futhark_f32_1d *in1)
{
    struct memblock_device a_mem_20275;
    
    a_mem_20275.references = NULL;
    
    struct memblock_device b_mem_20276;
    
    b_mem_20276.references = NULL;
    
    int64_t i_18332;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    a_mem_20275 = in0->mem;
    i_18332 = in0->shape[0];
    b_mem_20276 = in1->mem;
    i_18332 = in1->shape[0];
    if (!(i_18332 == in0->shape[0] && i_18332 == in1->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorAdd(ctx, &mem_out_20594, a_mem_20275,
                                     b_mem_20276, i_18332);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18332;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorMatrixMul(struct futhark_context *ctx,
                                  struct futhark_f32_1d **out0, const
                                  struct futhark_f32_1d *in0, const
                                  struct futhark_f32_2d *in1)
{
    struct memblock_device v_mem_20275;
    
    v_mem_20275.references = NULL;
    
    struct memblock_device M_mem_20276;
    
    M_mem_20276.references = NULL;
    
    int64_t i_18430;
    int64_t j_18431;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    v_mem_20275 = in0->mem;
    i_18430 = in0->shape[0];
    M_mem_20276 = in1->mem;
    i_18430 = in1->shape[0];
    j_18431 = in1->shape[1];
    if (!(i_18430 == in0->shape[0] && (i_18430 == in1->shape[0] && j_18431 ==
                                       in1->shape[1]))) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorMatrixMul(ctx, &mem_out_20594, v_mem_20275,
                                           M_mem_20276, i_18430, j_18431);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = j_18431;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorMul(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0, const
                            struct futhark_f32_1d *in1)
{
    struct memblock_device a_mem_20275;
    
    a_mem_20275.references = NULL;
    
    struct memblock_device b_mem_20276;
    
    b_mem_20276.references = NULL;
    
    int64_t i_18404;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    a_mem_20275 = in0->mem;
    i_18404 = in0->shape[0];
    b_mem_20276 = in1->mem;
    i_18404 = in1->shape[0];
    if (!(i_18404 == in0->shape[0] && i_18404 == in1->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorMul(ctx, &mem_out_20594, a_mem_20275,
                                     b_mem_20276, i_18404);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18404;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorNorm(struct futhark_context *ctx, float *out0, const
                             struct futhark_f32_1d *in0)
{
    struct memblock_device v_mem_20275;
    
    v_mem_20275.references = NULL;
    
    int64_t iz2083U_18590;
    float prim_out_20594;
    int ret = 0;
    
    lock_lock(&ctx->lock);
    v_mem_20275 = in0->mem;
    iz2083U_18590 = in0->shape[0];
    if (!(iz2083U_18590 == in0->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorNorm(ctx, &prim_out_20594, v_mem_20275,
                                      iz2083U_18590);
        if (ret == 0) {
            *out0 = prim_out_20594;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorSgn(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0)
{
    struct memblock_device as_mem_20275;
    
    as_mem_20275.references = NULL;
    
    int64_t nz2081U_18327;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    as_mem_20275 = in0->mem;
    nz2081U_18327 = in0->shape[0];
    if (!(nz2081U_18327 == in0->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorSgn(ctx, &mem_out_20594, as_mem_20275,
                                     nz2081U_18327);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = nz2081U_18327;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
int futhark_entry_vectorSub(struct futhark_context *ctx,
                            struct futhark_f32_1d **out0, const
                            struct futhark_f32_1d *in0, const
                            struct futhark_f32_1d *in1)
{
    struct memblock_device a_mem_20275;
    
    a_mem_20275.references = NULL;
    
    struct memblock_device b_mem_20276;
    
    b_mem_20276.references = NULL;
    
    int64_t i_18339;
    struct memblock_device mem_out_20594;
    
    mem_out_20594.references = NULL;
    
    int ret = 0;
    
    lock_lock(&ctx->lock);
    a_mem_20275 = in0->mem;
    i_18339 = in0->shape[0];
    b_mem_20276 = in1->mem;
    i_18339 = in1->shape[0];
    if (!(i_18339 == in0->shape[0] && i_18339 == in1->shape[0])) {
        ret = 1;
        if (!ctx->error)
            ctx->error =
                msgprintf("Error: entry point arguments have invalid sizes.\n");
    }
    if (ret == 0) {
        ret = futrts_entry_vectorSub(ctx, &mem_out_20594, a_mem_20275,
                                     b_mem_20276, i_18339);
        if (ret == 0) {
            assert((*out0 =
                    (struct futhark_f32_1d *) malloc(sizeof(struct futhark_f32_1d))) !=
                NULL);
            (*out0)->mem = mem_out_20594;
            (*out0)->shape[0] = i_18339;
        }
    }
    lock_unlock(&ctx->lock);
    return ret;
}
  
